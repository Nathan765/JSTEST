(function() {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const s of document.querySelectorAll('link[rel="modulepreload"]')) n(s);
  new MutationObserver(s => {
      for (const r of s)
          if (r.type === "childList")
              for (const a of r.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && n(a)
  }).observe(document, {
      childList: !0,
      subtree: !0
  });

  function t(s) {
      const r = {};
      return s.integrity && (r.integrity = s.integrity), s.referrerpolicy && (r.referrerPolicy = s.referrerpolicy), s.crossorigin === "use-credentials" ? r.credentials = "include" : s.crossorigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r
  }

  function n(s) {
      if (s.ep) return;
      s.ep = !0;
      const r = t(s);
      fetch(s.href, r)
  }
})();
const jm = "modulepreload",
  Hm = function(i) {
      return "/" + i
  },
  Fu = {},
  Wo = function(e, t, n) {
      if (!t || t.length === 0) return e();
      const s = document.getElementsByTagName("link");
      return Promise.all(t.map(r => {
          if (r = Hm(r), r in Fu) return;
          Fu[r] = !0;
          const a = r.endsWith(".css"),
              l = a ? '[rel="stylesheet"]' : "";
          if (!!n)
              for (let c = s.length - 1; c >= 0; c--) {
                  const h = s[c];
                  if (h.href === r && (!a || h.rel === "stylesheet")) return
              } else if (document.querySelector(`link[href="${r}"]${l}`)) return;
          const u = document.createElement("link");
          if (u.rel = a ? "stylesheet" : jm, a || (u.as = "script", u.crossOrigin = ""), u.href = r, document.head.appendChild(u), a) return new Promise((c, h) => {
              u.addEventListener("load", c), u.addEventListener("error", () => h(new Error(`Unable to preload CSS for ${r}`)))
          })
      })).then(() => e())
  };
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function Uo(i) {
  const e = Object.create(null);
  for (const t of i.split(",")) e[t] = 1;
  return t => t in e
}
const ze = {},
  $n = [],
  Qt = () => {},
  qm = () => !1,
  ta = i => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && (i.charCodeAt(2) > 122 || i.charCodeAt(2) < 97),
  jo = i => i.startsWith("onUpdate:"),
  et = Object.assign,
  Ho = (i, e) => {
      const t = i.indexOf(e);
      t > -1 && i.splice(t, 1)
  },
  Gm = Object.prototype.hasOwnProperty,
  Re = (i, e) => Gm.call(i, e),
  ve = Array.isArray,
  Ln = i => Ws(i) === "[object Map]",
  ia = i => Ws(i) === "[object Set]",
  Au = i => Ws(i) === "[object Date]",
  _e = i => typeof i == "function",
  Qe = i => typeof i == "string",
  ei = i => typeof i == "symbol",
  De = i => i !== null && typeof i == "object",
  bd = i => (De(i) || _e(i)) && _e(i.then) && _e(i.catch),
  wd = Object.prototype.toString,
  Ws = i => wd.call(i),
  Km = i => Ws(i).slice(8, -1),
  kd = i => Ws(i) === "[object Object]",
  qo = i => Qe(i) && i !== "NaN" && i[0] !== "-" && "" + parseInt(i, 10) === i,
  us = Uo(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
  na = i => {
      const e = Object.create(null);
      return t => e[t] || (e[t] = i(t))
  },
  Xm = /-(\w)/g,
  qt = na(i => i.replace(Xm, (e, t) => t ? t.toUpperCase() : "")),
  Jm = /\B([A-Z])/g,
  mn = na(i => i.replace(Jm, "-$1").toLowerCase()),
  sa = na(i => i.charAt(0).toUpperCase() + i.slice(1)),
  kr = na(i => i ? `on${sa(i)}` : ""),
  zi = (i, e) => !Object.is(i, e),
  _r = (i, ...e) => {
      for (let t = 0; t < i.length; t++) i[t](...e)
  },
  _d = (i, e, t, n = !1) => {
      Object.defineProperty(i, e, {
          configurable: !0,
          enumerable: !1,
          writable: n,
          value: t
      })
  },
  Ir = i => {
      const e = parseFloat(i);
      return isNaN(e) ? i : e
  },
  Ym = i => {
      const e = Qe(i) ? Number(i) : NaN;
      return isNaN(e) ? i : e
  };
let Vu;
const Us = () => Vu || (Vu = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});

function tt(i) {
  if (ve(i)) {
      const e = {};
      for (let t = 0; t < i.length; t++) {
          const n = i[t],
              s = Qe(n) ? tg(n) : tt(n);
          if (s)
              for (const r in s) e[r] = s[r]
      }
      return e
  } else if (Qe(i) || De(i)) return i
}
const Qm = /;(?![^(]*\))/g,
  Zm = /:([^]+)/,
  eg = /\/\*[^]*?\*\//g;

function tg(i) {
  const e = {};
  return i.replace(eg, "").split(Qm).forEach(t => {
      if (t) {
          const n = t.split(Zm);
          n.length > 1 && (e[n[0].trim()] = n[1].trim())
      }
  }), e
}

function ie(i) {
  let e = "";
  if (Qe(i)) e = i;
  else if (ve(i))
      for (let t = 0; t < i.length; t++) {
          const n = ie(i[t]);
          n && (e += n + " ")
      } else if (De(i))
          for (const t in i) i[t] && (e += t + " ");
  return e.trim()
}
const ig = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
  ng = Uo(ig);

function xd(i) {
  return !!i || i === ""
}

function sg(i, e) {
  if (i.length !== e.length) return !1;
  let t = !0;
  for (let n = 0; t && n < i.length; n++) t = Vn(i[n], e[n]);
  return t
}

function Vn(i, e) {
  if (i === e) return !0;
  let t = Au(i),
      n = Au(e);
  if (t || n) return t && n ? i.getTime() === e.getTime() : !1;
  if (t = ei(i), n = ei(e), t || n) return i === e;
  if (t = ve(i), n = ve(e), t || n) return t && n ? sg(i, e) : !1;
  if (t = De(i), n = De(e), t || n) {
      if (!t || !n) return !1;
      const s = Object.keys(i).length,
          r = Object.keys(e).length;
      if (s !== r) return !1;
      for (const a in i) {
          const l = i.hasOwnProperty(a),
              o = e.hasOwnProperty(a);
          if (l && !o || !l && o || !Vn(i[a], e[a])) return !1
      }
  }
  return String(i) === String(e)
}

function rg(i, e) {
  return i.findIndex(t => Vn(t, e))
}
const Td = i => !!(i && i.__v_isRef === !0),
  A = i => Qe(i) ? i : i == null ? "" : ve(i) || De(i) && (i.toString === wd || !_e(i.toString)) ? Td(i) ? A(i.value) : JSON.stringify(i, Sd, 2) : String(i),
  Sd = (i, e) => Td(e) ? Sd(i, e.value) : Ln(e) ? {
      [`Map(${e.size})`]: [...e.entries()].reduce((t, [n, s], r) => (t[Pa(n, r) + " =>"] = s, t), {})
  } : ia(e) ? {
      [`Set(${e.size})`]: [...e.values()].map(t => Pa(t))
  } : ei(e) ? Pa(e) : De(e) && !ve(e) && !kd(e) ? String(e) : e,
  Pa = (i, e = "") => {
      var t;
      return ei(i) ? `Symbol(${(t=i.description)!=null?t:e})` : i
  };
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let vt;
class Ed {
  constructor(e = !1) {
      this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = vt, !e && vt && (this.index = (vt.scopes || (vt.scopes = [])).push(this) - 1)
  }
  get active() {
      return this._active
  }
  pause() {
      if (this._active) {
          this._isPaused = !0;
          let e, t;
          if (this.scopes)
              for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].pause();
          for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].pause()
      }
  }
  resume() {
      if (this._active && this._isPaused) {
          this._isPaused = !1;
          let e, t;
          if (this.scopes)
              for (e = 0, t = this.scopes.length; e < t; e++) this.scopes[e].resume();
          for (e = 0, t = this.effects.length; e < t; e++) this.effects[e].resume()
      }
  }
  run(e) {
      if (this._active) {
          const t = vt;
          try {
              return vt = this, e()
          } finally {
              vt = t
          }
      }
  }
  on() {
      vt = this
  }
  off() {
      vt = this.parent
  }
  stop(e) {
      if (this._active) {
          this._active = !1;
          let t, n;
          for (t = 0, n = this.effects.length; t < n; t++) this.effects[t].stop();
          for (this.effects.length = 0, t = 0, n = this.cleanups.length; t < n; t++) this.cleanups[t]();
          if (this.cleanups.length = 0, this.scopes) {
              for (t = 0, n = this.scopes.length; t < n; t++) this.scopes[t].stop(!0);
              this.scopes.length = 0
          }
          if (!this.detached && this.parent && !e) {
              const s = this.parent.scopes.pop();
              s && s !== this && (this.parent.scopes[this.index] = s, s.index = this.index)
          }
          this.parent = void 0
      }
  }
}

function Cd(i) {
  return new Ed(i)
}

function $d() {
  return vt
}

function ag(i, e = !1) {
  vt && vt.cleanups.push(i)
}
let je;
const Ia = new WeakSet;
class Ld {
  constructor(e) {
      this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, vt && vt.active && vt.effects.push(this)
  }
  pause() {
      this.flags |= 64
  }
  resume() {
      this.flags & 64 && (this.flags &= -65, Ia.has(this) && (Ia.delete(this), this.trigger()))
  }
  notify() {
      this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Id(this)
  }
  run() {
      if (!(this.flags & 1)) return this.fn();
      this.flags |= 2, zu(this), Nd(this);
      const e = je,
          t = Zt;
      je = this, Zt = !0;
      try {
          return this.fn()
      } finally {
          Md(this), je = e, Zt = t, this.flags &= -3
      }
  }
  stop() {
      if (this.flags & 1) {
          for (let e = this.deps; e; e = e.nextDep) Xo(e);
          this.deps = this.depsTail = void 0, zu(this), this.onStop && this.onStop(), this.flags &= -2
      }
  }
  trigger() {
      this.flags & 64 ? Ia.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
  }
  runIfDirty() {
      Hl(this) && this.run()
  }
  get dirty() {
      return Hl(this)
  }
}
let Pd = 0,
  cs, hs;

function Id(i, e = !1) {
  if (i.flags |= 8, e) {
      i.next = hs, hs = i;
      return
  }
  i.next = cs, cs = i
}

function Go() {
  Pd++
}

function Ko() {
  if (--Pd > 0) return;
  if (hs) {
      let e = hs;
      for (hs = void 0; e;) {
          const t = e.next;
          e.next = void 0, e.flags &= -9, e = t
      }
  }
  let i;
  for (; cs;) {
      let e = cs;
      for (cs = void 0; e;) {
          const t = e.next;
          if (e.next = void 0, e.flags &= -9, e.flags & 1) try {
              e.trigger()
          } catch (n) {
              i || (i = n)
          }
          e = t
      }
  }
  if (i) throw i
}

function Nd(i) {
  for (let e = i.deps; e; e = e.nextDep) e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e
}

function Md(i) {
  let e, t = i.depsTail,
      n = t;
  for (; n;) {
      const s = n.prevDep;
      n.version === -1 ? (n === t && (t = s), Xo(n), lg(n)) : e = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = s
  }
  i.deps = e, i.depsTail = t
}

function Hl(i) {
  for (let e = i.deps; e; e = e.nextDep)
      if (e.dep.version !== e.version || e.dep.computed && (Rd(e.dep.computed) || e.dep.version !== e.version)) return !0;
  return !!i._dirty
}

function Rd(i) {
  if (i.flags & 4 && !(i.flags & 16) || (i.flags &= -17, i.globalVersion === _s)) return;
  i.globalVersion = _s;
  const e = i.dep;
  if (i.flags |= 2, e.version > 0 && !i.isSSR && i.deps && !Hl(i)) {
      i.flags &= -3;
      return
  }
  const t = je,
      n = Zt;
  je = i, Zt = !0;
  try {
      Nd(i);
      const s = i.fn(i._value);
      (e.version === 0 || zi(s, i._value)) && (i._value = s, e.version++)
  } catch (s) {
      throw e.version++, s
  } finally {
      je = t, Zt = n, Md(i), i.flags &= -3
  }
}

function Xo(i, e = !1) {
  const {
      dep: t,
      prevSub: n,
      nextSub: s
  } = i;
  if (n && (n.nextSub = s, i.prevSub = void 0), s && (s.prevSub = n, i.nextSub = void 0), t.subs === i && (t.subs = n, !n && t.computed)) {
      t.computed.flags &= -5;
      for (let r = t.computed.deps; r; r = r.nextDep) Xo(r, !0)
  }!e && !--t.sc && t.map && t.map.delete(t.key)
}

function lg(i) {
  const {
      prevDep: e,
      nextDep: t
  } = i;
  e && (e.nextDep = t, i.prevDep = void 0), t && (t.prevDep = e, i.nextDep = void 0)
}
let Zt = !0;
const Bd = [];

function Gi() {
  Bd.push(Zt), Zt = !1
}

function Ki() {
  const i = Bd.pop();
  Zt = i === void 0 ? !0 : i
}

function zu(i) {
  const {
      cleanup: e
  } = i;
  if (i.cleanup = void 0, e) {
      const t = je;
      je = void 0;
      try {
          e()
      } finally {
          je = t
      }
  }
}
let _s = 0;
class og {
  constructor(e, t) {
      this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
  }
}
class Jo {
  constructor(e) {
      this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0
  }
  track(e) {
      if (!je || !Zt || je === this.computed) return;
      let t = this.activeLink;
      if (t === void 0 || t.sub !== je) t = this.activeLink = new og(je, this), je.deps ? (t.prevDep = je.depsTail, je.depsTail.nextDep = t, je.depsTail = t) : je.deps = je.depsTail = t, Od(t);
      else if (t.version === -1 && (t.version = this.version, t.nextDep)) {
          const n = t.nextDep;
          n.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = n), t.prevDep = je.depsTail, t.nextDep = void 0, je.depsTail.nextDep = t, je.depsTail = t, je.deps === t && (je.deps = n)
      }
      return t
  }
  trigger(e) {
      this.version++, _s++, this.notify(e)
  }
  notify(e) {
      Go();
      try {
          for (let t = this.subs; t; t = t.prevSub) t.sub.notify() && t.sub.dep.notify()
      } finally {
          Ko()
      }
  }
}

function Od(i) {
  if (i.dep.sc++, i.sub.flags & 4) {
      const e = i.dep.computed;
      if (e && !i.dep.subs) {
          e.flags |= 20;
          for (let n = e.deps; n; n = n.nextDep) Od(n)
      }
      const t = i.dep.subs;
      t !== i && (i.prevSub = t, t && (t.nextSub = i)), i.dep.subs = i
  }
}
const Nr = new WeakMap,
  sn = Symbol(""),
  ql = Symbol(""),
  xs = Symbol("");

function pt(i, e, t) {
  if (Zt && je) {
      let n = Nr.get(i);
      n || Nr.set(i, n = new Map);
      let s = n.get(t);
      s || (n.set(t, s = new Jo), s.map = n, s.key = t), s.track()
  }
}

function wi(i, e, t, n, s, r) {
  const a = Nr.get(i);
  if (!a) {
      _s++;
      return
  }
  const l = o => {
      o && o.trigger()
  };
  if (Go(), e === "clear") a.forEach(l);
  else {
      const o = ve(i),
          u = o && qo(t);
      if (o && t === "length") {
          const c = Number(n);
          a.forEach((h, d) => {
              (d === "length" || d === xs || !ei(d) && d >= c) && l(h)
          })
      } else switch ((t !== void 0 || a.has(void 0)) && l(a.get(t)), u && l(a.get(xs)), e) {
          case "add":
              o ? u && l(a.get("length")) : (l(a.get(sn)), Ln(i) && l(a.get(ql)));
              break;
          case "delete":
              o || (l(a.get(sn)), Ln(i) && l(a.get(ql)));
              break;
          case "set":
              Ln(i) && l(a.get(sn));
              break
      }
  }
  Ko()
}

function ug(i, e) {
  const t = Nr.get(i);
  return t && t.get(e)
}

function vn(i) {
  const e = Pe(i);
  return e === i ? e : (pt(e, "iterate", xs), Vt(i) ? e : e.map(mt))
}

function ra(i) {
  return pt(i = Pe(i), "iterate", xs), i
}
const cg = {
  __proto__: null,
  [Symbol.iterator]() {
      return Na(this, Symbol.iterator, mt)
  },
  concat(...i) {
      return vn(this).concat(...i.map(e => ve(e) ? vn(e) : e))
  },
  entries() {
      return Na(this, "entries", i => (i[1] = mt(i[1]), i))
  },
  every(i, e) {
      return mi(this, "every", i, e, void 0, arguments)
  },
  filter(i, e) {
      return mi(this, "filter", i, e, t => t.map(mt), arguments)
  },
  find(i, e) {
      return mi(this, "find", i, e, mt, arguments)
  },
  findIndex(i, e) {
      return mi(this, "findIndex", i, e, void 0, arguments)
  },
  findLast(i, e) {
      return mi(this, "findLast", i, e, mt, arguments)
  },
  findLastIndex(i, e) {
      return mi(this, "findLastIndex", i, e, void 0, arguments)
  },
  forEach(i, e) {
      return mi(this, "forEach", i, e, void 0, arguments)
  },
  includes(...i) {
      return Ma(this, "includes", i)
  },
  indexOf(...i) {
      return Ma(this, "indexOf", i)
  },
  join(i) {
      return vn(this).join(i)
  },
  lastIndexOf(...i) {
      return Ma(this, "lastIndexOf", i)
  },
  map(i, e) {
      return mi(this, "map", i, e, void 0, arguments)
  },
  pop() {
      return is(this, "pop")
  },
  push(...i) {
      return is(this, "push", i)
  },
  reduce(i, ...e) {
      return Wu(this, "reduce", i, e)
  },
  reduceRight(i, ...e) {
      return Wu(this, "reduceRight", i, e)
  },
  shift() {
      return is(this, "shift")
  },
  some(i, e) {
      return mi(this, "some", i, e, void 0, arguments)
  },
  splice(...i) {
      return is(this, "splice", i)
  },
  toReversed() {
      return vn(this).toReversed()
  },
  toSorted(i) {
      return vn(this).toSorted(i)
  },
  toSpliced(...i) {
      return vn(this).toSpliced(...i)
  },
  unshift(...i) {
      return is(this, "unshift", i)
  },
  values() {
      return Na(this, "values", mt)
  }
};

function Na(i, e, t) {
  const n = ra(i),
      s = n[e]();
  return n !== i && !Vt(i) && (s._next = s.next, s.next = () => {
      const r = s._next();
      return r.value && (r.value = t(r.value)), r
  }), s
}
const hg = Array.prototype;

function mi(i, e, t, n, s, r) {
  const a = ra(i),
      l = a !== i && !Vt(i),
      o = a[e];
  if (o !== hg[e]) {
      const h = o.apply(i, r);
      return l ? mt(h) : h
  }
  let u = t;
  a !== i && (l ? u = function(h, d) {
      return t.call(this, mt(h), d, i)
  } : t.length > 2 && (u = function(h, d) {
      return t.call(this, h, d, i)
  }));
  const c = o.call(a, u, n);
  return l && s ? s(c) : c
}

function Wu(i, e, t, n) {
  const s = ra(i);
  let r = t;
  return s !== i && (Vt(i) ? t.length > 3 && (r = function(a, l, o) {
      return t.call(this, a, l, o, i)
  }) : r = function(a, l, o) {
      return t.call(this, a, mt(l), o, i)
  }), s[e](r, ...n)
}

function Ma(i, e, t) {
  const n = Pe(i);
  pt(n, "iterate", xs);
  const s = n[e](...t);
  return (s === -1 || s === !1) && eu(t[0]) ? (t[0] = Pe(t[0]), n[e](...t)) : s
}

function is(i, e, t = []) {
  Gi(), Go();
  const n = Pe(i)[e].apply(i, t);
  return Ko(), Ki(), n
}
const dg = Uo("__proto__,__v_isRef,__isVue"),
  Dd = new Set(Object.getOwnPropertyNames(Symbol).filter(i => i !== "arguments" && i !== "caller").map(i => Symbol[i]).filter(ei));

function fg(i) {
  ei(i) || (i = String(i));
  const e = Pe(this);
  return pt(e, "has", i), e.hasOwnProperty(i)
}
class Fd {
  constructor(e = !1, t = !1) {
      this._isReadonly = e, this._isShallow = t
  }
  get(e, t, n) {
      if (t === "__v_skip") return e.__v_skip;
      const s = this._isReadonly,
          r = this._isShallow;
      if (t === "__v_isReactive") return !s;
      if (t === "__v_isReadonly") return s;
      if (t === "__v_isShallow") return r;
      if (t === "__v_raw") return n === (s ? r ? xg : Wd : r ? zd : Vd).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(n) ? e : void 0;
      const a = ve(e);
      if (!s) {
          let o;
          if (a && (o = cg[t])) return o;
          if (t === "hasOwnProperty") return fg
      }
      const l = Reflect.get(e, t, Je(e) ? e : n);
      return (ei(t) ? Dd.has(t) : dg(t)) || (s || pt(e, "get", t), r) ? l : Je(l) ? a && qo(t) ? l : l.value : De(l) ? s ? Ud(l) : Wi(l) : l
  }
}
class Ad extends Fd {
  constructor(e = !1) {
      super(!1, e)
  }
  set(e, t, n, s) {
      let r = e[t];
      if (!this._isShallow) {
          const o = ln(r);
          if (!Vt(n) && !ln(n) && (r = Pe(r), n = Pe(n)), !ve(e) && Je(r) && !Je(n)) return o ? !1 : (r.value = n, !0)
      }
      const a = ve(e) && qo(t) ? Number(t) < e.length : Re(e, t),
          l = Reflect.set(e, t, n, Je(e) ? e : s);
      return e === Pe(s) && (a ? zi(n, r) && wi(e, "set", t, n) : wi(e, "add", t, n)), l
  }
  deleteProperty(e, t) {
      const n = Re(e, t);
      e[t];
      const s = Reflect.deleteProperty(e, t);
      return s && n && wi(e, "delete", t, void 0), s
  }
  has(e, t) {
      const n = Reflect.has(e, t);
      return (!ei(t) || !Dd.has(t)) && pt(e, "has", t), n
  }
  ownKeys(e) {
      return pt(e, "iterate", ve(e) ? "length" : sn), Reflect.ownKeys(e)
  }
}
class pg extends Fd {
  constructor(e = !1) {
      super(!0, e)
  }
  set(e, t) {
      return !0
  }
  deleteProperty(e, t) {
      return !0
  }
}
const mg = new Ad,
  gg = new pg,
  yg = new Ad(!0);
const Gl = i => i,
  Zs = i => Reflect.getPrototypeOf(i);

function vg(i, e, t) {
  return function(...n) {
      const s = this.__v_raw,
          r = Pe(s),
          a = Ln(r),
          l = i === "entries" || i === Symbol.iterator && a,
          o = i === "keys" && a,
          u = s[i](...n),
          c = t ? Gl : e ? Kl : mt;
      return !e && pt(r, "iterate", o ? ql : sn), {
          next() {
              const {
                  value: h,
                  done: d
              } = u.next();
              return d ? {
                  value: h,
                  done: d
              } : {
                  value: l ? [c(h[0]), c(h[1])] : c(h),
                  done: d
              }
          },
          [Symbol.iterator]() {
              return this
          }
      }
  }
}

function er(i) {
  return function(...e) {
      return i === "delete" ? !1 : i === "clear" ? void 0 : this
  }
}

function bg(i, e) {
  const t = {
      get(s) {
          const r = this.__v_raw,
              a = Pe(r),
              l = Pe(s);
          i || (zi(s, l) && pt(a, "get", s), pt(a, "get", l));
          const {
              has: o
          } = Zs(a), u = e ? Gl : i ? Kl : mt;
          if (o.call(a, s)) return u(r.get(s));
          if (o.call(a, l)) return u(r.get(l));
          r !== a && r.get(s)
      },
      get size() {
          const s = this.__v_raw;
          return !i && pt(Pe(s), "iterate", sn), Reflect.get(s, "size", s)
      },
      has(s) {
          const r = this.__v_raw,
              a = Pe(r),
              l = Pe(s);
          return i || (zi(s, l) && pt(a, "has", s), pt(a, "has", l)), s === l ? r.has(s) : r.has(s) || r.has(l)
      },
      forEach(s, r) {
          const a = this,
              l = a.__v_raw,
              o = Pe(l),
              u = e ? Gl : i ? Kl : mt;
          return !i && pt(o, "iterate", sn), l.forEach((c, h) => s.call(r, u(c), u(h), a))
      }
  };
  return et(t, i ? {
      add: er("add"),
      set: er("set"),
      delete: er("delete"),
      clear: er("clear")
  } : {
      add(s) {
          !e && !Vt(s) && !ln(s) && (s = Pe(s));
          const r = Pe(this);
          return Zs(r).has.call(r, s) || (r.add(s), wi(r, "add", s, s)), this
      },
      set(s, r) {
          !e && !Vt(r) && !ln(r) && (r = Pe(r));
          const a = Pe(this),
              {
                  has: l,
                  get: o
              } = Zs(a);
          let u = l.call(a, s);
          u || (s = Pe(s), u = l.call(a, s));
          const c = o.call(a, s);
          return a.set(s, r), u ? zi(r, c) && wi(a, "set", s, r) : wi(a, "add", s, r), this
      },
      delete(s) {
          const r = Pe(this),
              {
                  has: a,
                  get: l
              } = Zs(r);
          let o = a.call(r, s);
          o || (s = Pe(s), o = a.call(r, s)), l && l.call(r, s);
          const u = r.delete(s);
          return o && wi(r, "delete", s, void 0), u
      },
      clear() {
          const s = Pe(this),
              r = s.size !== 0,
              a = s.clear();
          return r && wi(s, "clear", void 0, void 0), a
      }
  }), ["keys", "values", "entries", Symbol.iterator].forEach(s => {
      t[s] = vg(s, i, e)
  }), t
}

function Yo(i, e) {
  const t = bg(i, e);
  return (n, s, r) => s === "__v_isReactive" ? !i : s === "__v_isReadonly" ? i : s === "__v_raw" ? n : Reflect.get(Re(t, s) && s in n ? t : n, s, r)
}
const wg = {
      get: Yo(!1, !1)
  },
  kg = {
      get: Yo(!1, !0)
  },
  _g = {
      get: Yo(!0, !1)
  };
const Vd = new WeakMap,
  zd = new WeakMap,
  Wd = new WeakMap,
  xg = new WeakMap;

function Tg(i) {
  switch (i) {
      case "Object":
      case "Array":
          return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
          return 2;
      default:
          return 0
  }
}

function Sg(i) {
  return i.__v_skip || !Object.isExtensible(i) ? 0 : Tg(Km(i))
}

function Wi(i) {
  return ln(i) ? i : Zo(i, !1, mg, wg, Vd)
}

function Qo(i) {
  return Zo(i, !1, yg, kg, zd)
}

function Ud(i) {
  return Zo(i, !0, gg, _g, Wd)
}

function Zo(i, e, t, n, s) {
  if (!De(i) || i.__v_raw && !(e && i.__v_isReactive)) return i;
  const r = s.get(i);
  if (r) return r;
  const a = Sg(i);
  if (a === 0) return i;
  const l = new Proxy(i, a === 2 ? n : t);
  return s.set(i, l), l
}

function Ui(i) {
  return ln(i) ? Ui(i.__v_raw) : !!(i && i.__v_isReactive)
}

function ln(i) {
  return !!(i && i.__v_isReadonly)
}

function Vt(i) {
  return !!(i && i.__v_isShallow)
}

function eu(i) {
  return i ? !!i.__v_raw : !1
}

function Pe(i) {
  const e = i && i.__v_raw;
  return e ? Pe(e) : i
}

function aa(i) {
  return !Re(i, "__v_skip") && Object.isExtensible(i) && _d(i, "__v_skip", !0), i
}
const mt = i => De(i) ? Wi(i) : i,
  Kl = i => De(i) ? Ud(i) : i;

function Je(i) {
  return i ? i.__v_isRef === !0 : !1
}

function M(i) {
  return jd(i, !1)
}

function Eg(i) {
  return jd(i, !0)
}

function jd(i, e) {
  return Je(i) ? i : new Cg(i, e)
}
class Cg {
  constructor(e, t) {
      this.dep = new Jo, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : Pe(e), this._value = t ? e : mt(e), this.__v_isShallow = t
  }
  get value() {
      return this.dep.track(), this._value
  }
  set value(e) {
      const t = this._rawValue,
          n = this.__v_isShallow || Vt(e) || ln(e);
      e = n ? e : Pe(e), zi(e, t) && (this._rawValue = e, this._value = n ? e : mt(e), this.dep.trigger())
  }
}

function pe(i) {
  return Je(i) ? i.value : i
}
const $g = {
  get: (i, e, t) => e === "__v_raw" ? i : pe(Reflect.get(i, e, t)),
  set: (i, e, t, n) => {
      const s = i[e];
      return Je(s) && !Je(t) ? (s.value = t, !0) : Reflect.set(i, e, t, n)
  }
};

function Hd(i) {
  return Ui(i) ? i : new Proxy(i, $g)
}

function Lg(i) {
  const e = ve(i) ? new Array(i.length) : {};
  for (const t in i) e[t] = qd(i, t);
  return e
}
class Pg {
  constructor(e, t, n) {
      this._object = e, this._key = t, this._defaultValue = n, this.__v_isRef = !0, this._value = void 0
  }
  get value() {
      const e = this._object[this._key];
      return this._value = e === void 0 ? this._defaultValue : e
  }
  set value(e) {
      this._object[this._key] = e
  }
  get dep() {
      return ug(Pe(this._object), this._key)
  }
}
class Ig {
  constructor(e) {
      this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0
  }
  get value() {
      return this._value = this._getter()
  }
}

function Uu(i, e, t) {
  return Je(i) ? i : _e(i) ? new Ig(i) : De(i) && arguments.length > 1 ? qd(i, e, t) : M(i)
}

function qd(i, e, t) {
  const n = i[e];
  return Je(n) ? n : new Pg(i, e, t)
}
class Ng {
  constructor(e, t, n) {
      this.fn = e, this.setter = t, this._value = void 0, this.dep = new Jo(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = _s - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = n
  }
  notify() {
      if (this.flags |= 16, !(this.flags & 8) && je !== this) return Id(this, !0), !0
  }
  get value() {
      const e = this.dep.track();
      return Rd(this), e && (e.version = this.dep.version), this._value
  }
  set value(e) {
      this.setter && this.setter(e)
  }
}

function Mg(i, e, t = !1) {
  let n, s;
  return _e(i) ? n = i : (n = i.get, s = i.set), new Ng(n, s, t)
}
const tr = {},
  Mr = new WeakMap;
let tn;

function Rg(i, e = !1, t = tn) {
  if (t) {
      let n = Mr.get(t);
      n || Mr.set(t, n = []), n.push(i)
  }
}

function Bg(i, e, t = ze) {
  const {
      immediate: n,
      deep: s,
      once: r,
      scheduler: a,
      augmentJob: l,
      call: o
  } = t, u = k => s ? k : Vt(k) || s === !1 || s === 0 ? ki(k, 1) : ki(k);
  let c, h, d, f, p = !1,
      g = !1;
  if (Je(i) ? (h = () => i.value, p = Vt(i)) : Ui(i) ? (h = () => u(i), p = !0) : ve(i) ? (g = !0, p = i.some(k => Ui(k) || Vt(k)), h = () => i.map(k => {
          if (Je(k)) return k.value;
          if (Ui(k)) return u(k);
          if (_e(k)) return o ? o(k, 2) : k()
      })) : _e(i) ? e ? h = o ? () => o(i, 2) : i : h = () => {
          if (d) {
              Gi();
              try {
                  d()
              } finally {
                  Ki()
              }
          }
          const k = tn;
          tn = c;
          try {
              return o ? o(i, 3, [f]) : i(f)
          } finally {
              tn = k
          }
      } : h = Qt, e && s) {
      const k = h,
          S = s === !0 ? 1 / 0 : s;
      h = () => ki(k(), S)
  }
  const w = $d(),
      y = () => {
          c.stop(), w && w.active && Ho(w.effects, c)
      };
  if (r && e) {
      const k = e;
      e = (...S) => {
          k(...S), y()
      }
  }
  let b = g ? new Array(i.length).fill(tr) : tr;
  const x = k => {
      if (!(!(c.flags & 1) || !c.dirty && !k))
          if (e) {
              const S = c.run();
              if (s || p || (g ? S.some((B, D) => zi(B, b[D])) : zi(S, b))) {
                  d && d();
                  const B = tn;
                  tn = c;
                  try {
                      const D = [S, b === tr ? void 0 : g && b[0] === tr ? [] : b, f];
                      o ? o(e, 3, D) : e(...D), b = S
                  } finally {
                      tn = B
                  }
              }
          } else c.run()
  };
  return l && l(x), c = new Ld(h), c.scheduler = a ? () => a(x, !1) : x, f = k => Rg(k, !1, c), d = c.onStop = () => {
      const k = Mr.get(c);
      if (k) {
          if (o) o(k, 4);
          else
              for (const S of k) S();
          Mr.delete(c)
      }
  }, e ? n ? x(!0) : b = c.run() : a ? a(x.bind(null, !0), !0) : c.run(), y.pause = c.pause.bind(c), y.resume = c.resume.bind(c), y.stop = y, y
}

function ki(i, e = 1 / 0, t) {
  if (e <= 0 || !De(i) || i.__v_skip || (t = t || new Set, t.has(i))) return i;
  if (t.add(i), e--, Je(i)) ki(i.value, e, t);
  else if (ve(i))
      for (let n = 0; n < i.length; n++) ki(i[n], e, t);
  else if (ia(i) || Ln(i)) i.forEach(n => {
      ki(n, e, t)
  });
  else if (kd(i)) {
      for (const n in i) ki(i[n], e, t);
      for (const n of Object.getOwnPropertySymbols(i)) Object.prototype.propertyIsEnumerable.call(i, n) && ki(i[n], e, t)
  }
  return i
}
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function js(i, e, t, n) {
  try {
      return n ? i(...n) : i()
  } catch (s) {
      la(s, e, t)
  }
}

function ti(i, e, t, n) {
  if (_e(i)) {
      const s = js(i, e, t, n);
      return s && bd(s) && s.catch(r => {
          la(r, e, t)
      }), s
  }
  if (ve(i)) {
      const s = [];
      for (let r = 0; r < i.length; r++) s.push(ti(i[r], e, t, n));
      return s
  }
}

function la(i, e, t, n = !0) {
  const s = e ? e.vnode : null,
      {
          errorHandler: r,
          throwUnhandledErrorInProduction: a
      } = e && e.appContext.config || ze;
  if (e) {
      let l = e.parent;
      const o = e.proxy,
          u = `https://vuejs.org/error-reference/#runtime-${t}`;
      for (; l;) {
          const c = l.ec;
          if (c) {
              for (let h = 0; h < c.length; h++)
                  if (c[h](i, o, u) === !1) return
          }
          l = l.parent
      }
      if (r) {
          Gi(), js(r, null, 10, [i, o, u]), Ki();
          return
      }
  }
  Og(i, t, s, n, a)
}

function Og(i, e, t, n = !0, s = !1) {
  if (s) throw i;
  console.error(i)
}
const bt = [];
let ci = -1;
const Pn = [];
let Bi = null,
  _n = 0;
const Gd = Promise.resolve();
let Rr = null;

function pi(i) {
  const e = Rr || Gd;
  return i ? e.then(this ? i.bind(this) : i) : e
}

function Dg(i) {
  let e = ci + 1,
      t = bt.length;
  for (; e < t;) {
      const n = e + t >>> 1,
          s = bt[n],
          r = Ts(s);
      r < i || r === i && s.flags & 2 ? e = n + 1 : t = n
  }
  return e
}

function tu(i) {
  if (!(i.flags & 1)) {
      const e = Ts(i),
          t = bt[bt.length - 1];
      !t || !(i.flags & 2) && e >= Ts(t) ? bt.push(i) : bt.splice(Dg(e), 0, i), i.flags |= 1, Kd()
  }
}

function Kd() {
  Rr || (Rr = Gd.then(Jd))
}

function Fg(i) {
  ve(i) ? Pn.push(...i) : Bi && i.id === -1 ? Bi.splice(_n + 1, 0, i) : i.flags & 1 || (Pn.push(i), i.flags |= 1), Kd()
}

function ju(i, e, t = ci + 1) {
  for (; t < bt.length; t++) {
      const n = bt[t];
      if (n && n.flags & 2) {
          if (i && n.id !== i.uid) continue;
          bt.splice(t, 1), t--, n.flags & 4 && (n.flags &= -2), n(), n.flags & 4 || (n.flags &= -2)
      }
  }
}

function Xd(i) {
  if (Pn.length) {
      const e = [...new Set(Pn)].sort((t, n) => Ts(t) - Ts(n));
      if (Pn.length = 0, Bi) {
          Bi.push(...e);
          return
      }
      for (Bi = e, _n = 0; _n < Bi.length; _n++) {
          const t = Bi[_n];
          t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), t.flags &= -2
      }
      Bi = null, _n = 0
  }
}
const Ts = i => i.id == null ? i.flags & 2 ? -1 : 1 / 0 : i.id;

function Jd(i) {
  const e = Qt;
  try {
      for (ci = 0; ci < bt.length; ci++) {
          const t = bt[ci];
          t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), js(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2))
      }
  } finally {
      for (; ci < bt.length; ci++) {
          const t = bt[ci];
          t && (t.flags &= -2)
      }
      ci = -1, bt.length = 0, Xd(), Rr = null, (bt.length || Pn.length) && Jd()
  }
}
let nt = null,
  oa = null;

function Br(i) {
  const e = nt;
  return nt = i, oa = i && i.type.__scopeId || null, e
}

function Ag(i) {
  oa = i
}

function Vg() {
  oa = null
}
const zg = i => We;

function We(i, e = nt, t) {
  if (!e || i._n) return i;
  const n = (...s) => {
      n._d && ec(-1);
      const r = Br(e);
      let a;
      try {
          a = i(...s)
      } finally {
          Br(r), n._d && ec(1)
      }
      return a
  };
  return n._n = !0, n._c = !0, n._d = !0, n
}

function Mt(i, e) {
  if (nt === null) return i;
  const t = ma(nt),
      n = i.dirs || (i.dirs = []);
  for (let s = 0; s < e.length; s++) {
      let [r, a, l, o = ze] = e[s];
      r && (_e(r) && (r = {
          mounted: r,
          updated: r
      }), r.deep && ki(a), n.push({
          dir: r,
          instance: t,
          value: a,
          oldValue: void 0,
          arg: l,
          modifiers: o
      }))
  }
  return i
}

function Yi(i, e, t, n) {
  const s = i.dirs,
      r = e && e.dirs;
  for (let a = 0; a < s.length; a++) {
      const l = s[a];
      r && (l.oldValue = r[a].value);
      let o = l.dir[n];
      o && (Gi(), ti(o, t, 8, [i.el, l, i, e]), Ki())
  }
}
const Wg = Symbol("_vte"),
  Yd = i => i.__isTeleport,
  Oi = Symbol("_leaveCb"),
  ir = Symbol("_enterCb");

function Qd() {
  const i = {
      isMounted: !1,
      isLeaving: !1,
      isUnmounting: !1,
      leavingVNodes: new Map
  };
  return Te(() => {
      i.isMounted = !0
  }), da(() => {
      i.isUnmounting = !0
  }), i
}
const Ot = [Function, Array],
  Zd = {
      mode: String,
      appear: Boolean,
      persisted: Boolean,
      onBeforeEnter: Ot,
      onEnter: Ot,
      onAfterEnter: Ot,
      onEnterCancelled: Ot,
      onBeforeLeave: Ot,
      onLeave: Ot,
      onAfterLeave: Ot,
      onLeaveCancelled: Ot,
      onBeforeAppear: Ot,
      onAppear: Ot,
      onAfterAppear: Ot,
      onAppearCancelled: Ot
  },
  ef = i => {
      const e = i.subTree;
      return e.component ? ef(e.component) : e
  },
  Ug = {
      name: "BaseTransition",
      props: Zd,
      setup(i, {
          slots: e
      }) {
          const t = Lf(),
              n = Qd();
          return () => {
              const s = e.default && iu(e.default(), !0);
              if (!s || !s.length) return;
              const r = tf(s),
                  a = Pe(i),
                  {
                      mode: l
                  } = a;
              if (n.isLeaving) return Ra(r);
              const o = Hu(r);
              if (!o) return Ra(r);
              let u = Ss(o, a, n, t, h => u = h);
              o.type !== _t && on(o, u);
              let c = t.subTree && Hu(t.subTree);
              if (c && c.type !== _t && !nn(o, c) && ef(t).type !== _t) {
                  let h = Ss(c, a, n, t);
                  if (on(c, h), l === "out-in" && o.type !== _t) return n.isLeaving = !0, h.afterLeave = () => {
                      n.isLeaving = !1, t.job.flags & 8 || t.update(), delete h.afterLeave, c = void 0
                  }, Ra(r);
                  l === "in-out" && o.type !== _t ? h.delayLeave = (d, f, p) => {
                      const g = nf(n, c);
                      g[String(c.key)] = c, d[Oi] = () => {
                          f(), d[Oi] = void 0, delete u.delayedLeave, c = void 0
                      }, u.delayedLeave = () => {
                          p(), delete u.delayedLeave, c = void 0
                      }
                  } : c = void 0
              } else c && (c = void 0);
              return r
          }
      }
  };

function tf(i) {
  let e = i[0];
  if (i.length > 1) {
      for (const t of i)
          if (t.type !== _t) {
              e = t;
              break
          }
  }
  return e
}
const jg = Ug;

function nf(i, e) {
  const {
      leavingVNodes: t
  } = i;
  let n = t.get(e.type);
  return n || (n = Object.create(null), t.set(e.type, n)), n
}

function Ss(i, e, t, n, s) {
  const {
      appear: r,
      mode: a,
      persisted: l = !1,
      onBeforeEnter: o,
      onEnter: u,
      onAfterEnter: c,
      onEnterCancelled: h,
      onBeforeLeave: d,
      onLeave: f,
      onAfterLeave: p,
      onLeaveCancelled: g,
      onBeforeAppear: w,
      onAppear: y,
      onAfterAppear: b,
      onAppearCancelled: x
  } = e, k = String(i.key), S = nf(t, i), B = (I, $) => {
      I && ti(I, n, 9, $)
  }, D = (I, $) => {
      const V = $[1];
      B(I, $), ve(I) ? I.every(N => N.length <= 1) && V() : I.length <= 1 && V()
  }, P = {
      mode: a,
      persisted: l,
      beforeEnter(I) {
          let $ = o;
          if (!t.isMounted)
              if (r) $ = w || o;
              else return;
          I[Oi] && I[Oi](!0);
          const V = S[k];
          V && nn(i, V) && V.el[Oi] && V.el[Oi](), B($, [I])
      },
      enter(I) {
          let $ = u,
              V = c,
              N = h;
          if (!t.isMounted)
              if (r) $ = y || u, V = b || c, N = x || h;
              else return;
          let O = !1;
          const se = I[ir] = G => {
              O || (O = !0, G ? B(N, [I]) : B(V, [I]), P.delayedLeave && P.delayedLeave(), I[ir] = void 0)
          };
          $ ? D($, [I, se]) : se()
      },
      leave(I, $) {
          const V = String(i.key);
          if (I[ir] && I[ir](!0), t.isUnmounting) return $();
          B(d, [I]);
          let N = !1;
          const O = I[Oi] = se => {
              N || (N = !0, $(), se ? B(g, [I]) : B(p, [I]), I[Oi] = void 0, S[V] === i && delete S[V])
          };
          S[V] = i, f ? D(f, [I, O]) : O()
      },
      clone(I) {
          const $ = Ss(I, e, t, n, s);
          return s && s($), $
      }
  };
  return P
}

function Ra(i) {
  if (ua(i)) return i = ji(i), i.children = null, i
}

function Hu(i) {
  if (!ua(i)) return Yd(i.type) && i.children ? tf(i.children) : i;
  const {
      shapeFlag: e,
      children: t
  } = i;
  if (t) {
      if (e & 16) return t[0];
      if (e & 32 && _e(t.default)) return t.default()
  }
}

function on(i, e) {
  i.shapeFlag & 6 && i.component ? (i.transition = e, on(i.component.subTree, e)) : i.shapeFlag & 128 ? (i.ssContent.transition = e.clone(i.ssContent), i.ssFallback.transition = e.clone(i.ssFallback)) : i.transition = e
}

function iu(i, e = !1, t) {
  let n = [],
      s = 0;
  for (let r = 0; r < i.length; r++) {
      let a = i[r];
      const l = t == null ? a.key : String(t) + String(a.key != null ? a.key : r);
      a.type === F ? (a.patchFlag & 128 && s++, n = n.concat(iu(a.children, e, l))) : (e || a.type !== _t) && n.push(l != null ? ji(a, {
          key: l
      }) : a)
  }
  if (s > 1)
      for (let r = 0; r < n.length; r++) n[r].patchFlag = -2;
  return n
} /*! #__NO_SIDE_EFFECTS__ */
function U(i, e) {
  return _e(i) ? (() => et({
      name: i.name
  }, e, {
      setup: i
  }))() : i
}

function sf(i) {
  i.ids = [i.ids[0] + i.ids[2]++ + "-", 0, 0]
}

function Or(i, e, t, n, s = !1) {
  if (ve(i)) {
      i.forEach((p, g) => Or(p, e && (ve(e) ? e[g] : e), t, n, s));
      return
  }
  if (In(n) && !s) {
      n.shapeFlag & 512 && n.type.__asyncResolved && n.component.subTree.component && Or(i, e, t, n.component.subTree);
      return
  }
  const r = n.shapeFlag & 4 ? ma(n.component) : n.el,
      a = s ? null : r,
      {
          i: l,
          r: o
      } = i,
      u = e && e.r,
      c = l.refs === ze ? l.refs = {} : l.refs,
      h = l.setupState,
      d = Pe(h),
      f = h === ze ? () => !1 : p => Re(d, p);
  if (u != null && u !== o && (Qe(u) ? (c[u] = null, f(u) && (h[u] = null)) : Je(u) && (u.value = null)), _e(o)) js(o, l, 12, [a, c]);
  else {
      const p = Qe(o),
          g = Je(o);
      if (p || g) {
          const w = () => {
              if (i.f) {
                  const y = p ? f(o) ? h[o] : c[o] : o.value;
                  s ? ve(y) && Ho(y, r) : ve(y) ? y.includes(r) || y.push(r) : p ? (c[o] = [r], f(o) && (h[o] = c[o])) : (o.value = [r], i.k && (c[i.k] = o.value))
              } else p ? (c[o] = a, f(o) && (h[o] = a)) : g && (o.value = a, i.k && (c[i.k] = a))
          };
          a ? (w.id = -1, Lt(w, t)) : w()
      }
  }
}
Us().requestIdleCallback;
Us().cancelIdleCallback;
const In = i => !!i.type.__asyncLoader,
  ua = i => i.type.__isKeepAlive;

function Hg(i, e) {
  rf(i, "a", e)
}

function qg(i, e) {
  rf(i, "da", e)
}

function rf(i, e, t = lt) {
  const n = i.__wdc || (i.__wdc = () => {
      let s = t;
      for (; s;) {
          if (s.isDeactivated) return;
          s = s.parent
      }
      return i()
  });
  if (ca(e, n, t), t) {
      let s = t.parent;
      for (; s && s.parent;) ua(s.parent.vnode) && Gg(n, e, t, s), s = s.parent
  }
}

function Gg(i, e, t, n) {
  const s = ca(e, i, n, !0);
  ct(() => {
      Ho(n[e], s)
  }, t)
}

function ca(i, e, t = lt, n = !1) {
  if (t) {
      const s = t[i] || (t[i] = []),
          r = e.__weh || (e.__weh = (...a) => {
              Gi();
              const l = Hs(t),
                  o = ti(e, t, i, a);
              return l(), Ki(), o
          });
      return n ? s.unshift(r) : s.push(r), r
  }
}
const $i = i => (e, t = lt) => {
      (!$s || i === "sp") && ca(i, (...n) => e(...n), t)
  },
  Kg = $i("bm"),
  Te = $i("m"),
  af = $i("bu"),
  ha = $i("u"),
  da = $i("bum"),
  ct = $i("um"),
  Xg = $i("sp"),
  Jg = $i("rtg"),
  Yg = $i("rtc");

function Qg(i, e = lt) {
  ca("ec", i, e)
}
const nu = "components",
  Zg = "directives";

function st(i, e) {
  return su(nu, i, !0, e) || i
}
const lf = Symbol.for("v-ndc");

function Xl(i) {
  return Qe(i) ? su(nu, i, !1) || i : i || lf
}

function e0(i) {
  return su(Zg, i)
}

function su(i, e, t = !0, n = !1) {
  const s = nt || lt;
  if (s) {
      const r = s.type;
      if (i === nu) {
          const l = W0(r, !1);
          if (l && (l === e || l === qt(e) || l === sa(qt(e)))) return r
      }
      const a = qu(s[i] || r[i], e) || qu(s.appContext[i], e);
      return !a && n ? r : a
  }
}

function qu(i, e) {
  return i && (i[e] || i[qt(e)] || i[sa(qt(e))])
}

function ue(i, e, t, n) {
  let s;
  const r = t && t[n],
      a = ve(i);
  if (a || Qe(i)) {
      const l = a && Ui(i);
      let o = !1;
      l && (o = !Vt(i), i = ra(i)), s = new Array(i.length);
      for (let u = 0, c = i.length; u < c; u++) s[u] = e(o ? mt(i[u]) : i[u], u, void 0, r && r[u])
  } else if (typeof i == "number") {
      s = new Array(i);
      for (let l = 0; l < i; l++) s[l] = e(l + 1, l, void 0, r && r[l])
  } else if (De(i))
      if (i[Symbol.iterator]) s = Array.from(i, (l, o) => e(l, o, void 0, r && r[o]));
      else {
          const l = Object.keys(i);
          s = new Array(l.length);
          for (let o = 0, u = l.length; o < u; o++) {
              const c = l[o];
              s[o] = e(i[c], c, o, r && r[o])
          }
      }
  else s = [];
  return t && (t[n] = s), s
}

function nr(i, e, t = {}, n, s) {
  if (nt.ce || nt.parent && In(nt.parent) && nt.parent.ce) return e !== "default" && (t.name = e), _(), xe(F, null, [z("slot", t, n && n())], 64);
  let r = i[e];
  r && r._c && (r._d = !1), _();
  const a = r && of(r(t)),
      l = t.key || a && a.key,
      o = xe(F, {
          key: (l && !ei(l) ? l : `_${e}`) + (!a && n ? "_fb" : "")
      }, a || (n ? n() : []), a && i._ === 1 ? 64 : -2);
  return !s && o.scopeId && (o.slotScopeIds = [o.scopeId + "-s"]), r && r._c && (r._d = !0), o
}

function of(i) {
  return i.some(e => Cs(e) ? !(e.type === _t || e.type === F && !of(e.children)) : !0) ? i : null
}

function t0(i, e) {
  const t = {};
  for (const n in i) t[e && /[A-Z]/.test(n) ? `on:${n}` : kr(n)] = i[n];
  return t
}
const Jl = i => i ? Pf(i) ? ma(i) : Jl(i.parent) : null,
  ds = et(Object.create(null), {
      $: i => i,
      $el: i => i.vnode.el,
      $data: i => i.data,
      $props: i => i.props,
      $attrs: i => i.attrs,
      $slots: i => i.slots,
      $refs: i => i.refs,
      $parent: i => Jl(i.parent),
      $root: i => Jl(i.root),
      $host: i => i.ce,
      $emit: i => i.emit,
      $options: i => ru(i),
      $forceUpdate: i => i.f || (i.f = () => {
          tu(i.update)
      }),
      $nextTick: i => i.n || (i.n = pi.bind(i.proxy)),
      $watch: i => T0.bind(i)
  }),
  Ba = (i, e) => i !== ze && !i.__isScriptSetup && Re(i, e),
  i0 = {
      get({
          _: i
      }, e) {
          if (e === "__v_skip") return !0;
          const {
              ctx: t,
              setupState: n,
              data: s,
              props: r,
              accessCache: a,
              type: l,
              appContext: o
          } = i;
          let u;
          if (e[0] !== "$") {
              const f = a[e];
              if (f !== void 0) switch (f) {
                  case 1:
                      return n[e];
                  case 2:
                      return s[e];
                  case 4:
                      return t[e];
                  case 3:
                      return r[e]
              } else {
                  if (Ba(n, e)) return a[e] = 1, n[e];
                  if (s !== ze && Re(s, e)) return a[e] = 2, s[e];
                  if ((u = i.propsOptions[0]) && Re(u, e)) return a[e] = 3, r[e];
                  if (t !== ze && Re(t, e)) return a[e] = 4, t[e];
                  Yl && (a[e] = 0)
              }
          }
          const c = ds[e];
          let h, d;
          if (c) return e === "$attrs" && pt(i.attrs, "get", ""), c(i);
          if ((h = l.__cssModules) && (h = h[e])) return h;
          if (t !== ze && Re(t, e)) return a[e] = 4, t[e];
          if (d = o.config.globalProperties, Re(d, e)) return d[e]
      },
      set({
          _: i
      }, e, t) {
          const {
              data: n,
              setupState: s,
              ctx: r
          } = i;
          return Ba(s, e) ? (s[e] = t, !0) : n !== ze && Re(n, e) ? (n[e] = t, !0) : Re(i.props, e) || e[0] === "$" && e.slice(1) in i ? !1 : (r[e] = t, !0)
      },
      has({
          _: {
              data: i,
              setupState: e,
              accessCache: t,
              ctx: n,
              appContext: s,
              propsOptions: r
          }
      }, a) {
          let l;
          return !!t[a] || i !== ze && Re(i, a) || Ba(e, a) || (l = r[0]) && Re(l, a) || Re(n, a) || Re(ds, a) || Re(s.config.globalProperties, a)
      },
      defineProperty(i, e, t) {
          return t.get != null ? i._.accessCache[e] = 0 : Re(t, "value") && this.set(i, e, t.value, null), Reflect.defineProperty(i, e, t)
      }
  };

function Gu(i) {
  return ve(i) ? i.reduce((e, t) => (e[t] = null, e), {}) : i
}
let Yl = !0;

function n0(i) {
  const e = ru(i),
      t = i.proxy,
      n = i.ctx;
  Yl = !1, e.beforeCreate && Ku(e.beforeCreate, i, "bc");
  const {
      data: s,
      computed: r,
      methods: a,
      watch: l,
      provide: o,
      inject: u,
      created: c,
      beforeMount: h,
      mounted: d,
      beforeUpdate: f,
      updated: p,
      activated: g,
      deactivated: w,
      beforeDestroy: y,
      beforeUnmount: b,
      destroyed: x,
      unmounted: k,
      render: S,
      renderTracked: B,
      renderTriggered: D,
      errorCaptured: P,
      serverPrefetch: I,
      expose: $,
      inheritAttrs: V,
      components: N,
      directives: O,
      filters: se
  } = e;
  if (u && s0(u, n, null), a)
      for (const le in a) {
          const ae = a[le];
          _e(ae) && (n[le] = ae.bind(t))
      }
  if (s) {
      const le = s.call(t, t);
      De(le) && (i.data = Wi(le))
  }
  if (Yl = !0, r)
      for (const le in r) {
          const ae = r[le],
              $e = _e(ae) ? ae.bind(t, t) : _e(ae.get) ? ae.get.bind(t, t) : Qt,
              Oe = !_e(ae) && _e(ae.set) ? ae.set.bind(t) : Qt,
              Ye = q({
                  get: $e,
                  set: Oe
              });
          Object.defineProperty(n, le, {
              enumerable: !0,
              configurable: !0,
              get: () => Ye.value,
              set: it => Ye.value = it
          })
      }
  if (l)
      for (const le in l) uf(l[le], n, t, le);
  if (o) {
      const le = _e(o) ? o.call(t) : o;
      Reflect.ownKeys(le).forEach(ae => {
          Nn(ae, le[ae])
      })
  }
  c && Ku(c, i, "c");

  function te(le, ae) {
      ve(ae) ? ae.forEach($e => le($e.bind(t))) : ae && le(ae.bind(t))
  }
  if (te(Kg, h), te(Te, d), te(af, f), te(ha, p), te(Hg, g), te(qg, w), te(Qg, P), te(Yg, B), te(Jg, D), te(da, b), te(ct, k), te(Xg, I), ve($))
      if ($.length) {
          const le = i.exposed || (i.exposed = {});
          $.forEach(ae => {
              Object.defineProperty(le, ae, {
                  get: () => t[ae],
                  set: $e => t[ae] = $e
              })
          })
      } else i.exposed || (i.exposed = {});
  S && i.render === Qt && (i.render = S), V != null && (i.inheritAttrs = V), N && (i.components = N), O && (i.directives = O), I && sf(i)
}

function s0(i, e, t = Qt) {
  ve(i) && (i = Ql(i));
  for (const n in i) {
      const s = i[n];
      let r;
      De(s) ? "default" in s ? r = zt(s.from || n, s.default, !0) : r = zt(s.from || n) : r = zt(s), Je(r) ? Object.defineProperty(e, n, {
          enumerable: !0,
          configurable: !0,
          get: () => r.value,
          set: a => r.value = a
      }) : e[n] = r
  }
}

function Ku(i, e, t) {
  ti(ve(i) ? i.map(n => n.bind(e.proxy)) : i.bind(e.proxy), e, t)
}

function uf(i, e, t, n) {
  let s = n.includes(".") ? xf(t, n) : () => t[n];
  if (Qe(i)) {
      const r = e[i];
      _e(r) && Ie(s, r)
  } else if (_e(i)) Ie(s, i.bind(t));
  else if (De(i))
      if (ve(i)) i.forEach(r => uf(r, e, t, n));
      else {
          const r = _e(i.handler) ? i.handler.bind(t) : e[i.handler];
          _e(r) && Ie(s, r, i)
      }
}

function ru(i) {
  const e = i.type,
      {
          mixins: t,
          extends: n
      } = e,
      {
          mixins: s,
          optionsCache: r,
          config: {
              optionMergeStrategies: a
          }
      } = i.appContext,
      l = r.get(e);
  let o;
  return l ? o = l : !s.length && !t && !n ? o = e : (o = {}, s.length && s.forEach(u => Dr(o, u, a, !0)), Dr(o, e, a)), De(e) && r.set(e, o), o
}

function Dr(i, e, t, n = !1) {
  const {
      mixins: s,
      extends: r
  } = e;
  r && Dr(i, r, t, !0), s && s.forEach(a => Dr(i, a, t, !0));
  for (const a in e)
      if (!(n && a === "expose")) {
          const l = r0[a] || t && t[a];
          i[a] = l ? l(i[a], e[a]) : e[a]
      } return i
}
const r0 = {
  data: Xu,
  props: Ju,
  emits: Ju,
  methods: os,
  computed: os,
  beforeCreate: yt,
  created: yt,
  beforeMount: yt,
  mounted: yt,
  beforeUpdate: yt,
  updated: yt,
  beforeDestroy: yt,
  beforeUnmount: yt,
  destroyed: yt,
  unmounted: yt,
  activated: yt,
  deactivated: yt,
  errorCaptured: yt,
  serverPrefetch: yt,
  components: os,
  directives: os,
  watch: l0,
  provide: Xu,
  inject: a0
};

function Xu(i, e) {
  return e ? i ? function() {
      return et(_e(i) ? i.call(this, this) : i, _e(e) ? e.call(this, this) : e)
  } : e : i
}

function a0(i, e) {
  return os(Ql(i), Ql(e))
}

function Ql(i) {
  if (ve(i)) {
      const e = {};
      for (let t = 0; t < i.length; t++) e[i[t]] = i[t];
      return e
  }
  return i
}

function yt(i, e) {
  return i ? [...new Set([].concat(i, e))] : e
}

function os(i, e) {
  return i ? et(Object.create(null), i, e) : e
}

function Ju(i, e) {
  return i ? ve(i) && ve(e) ? [...new Set([...i, ...e])] : et(Object.create(null), Gu(i), Gu(e ?? {})) : e
}

function l0(i, e) {
  if (!i) return e;
  if (!e) return i;
  const t = et(Object.create(null), i);
  for (const n in e) t[n] = yt(i[n], e[n]);
  return t
}

function cf() {
  return {
      app: null,
      config: {
          isNativeTag: qm,
          performance: !1,
          globalProperties: {},
          optionMergeStrategies: {},
          errorHandler: void 0,
          warnHandler: void 0,
          compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: Object.create(null),
      optionsCache: new WeakMap,
      propsCache: new WeakMap,
      emitsCache: new WeakMap
  }
}
let o0 = 0;

function u0(i, e) {
  return function(n, s = null) {
      _e(n) || (n = et({}, n)), s != null && !De(s) && (s = null);
      const r = cf(),
          a = new WeakSet,
          l = [];
      let o = !1;
      const u = r.app = {
          _uid: o0++,
          _component: n,
          _props: s,
          _container: null,
          _context: r,
          _instance: null,
          version: j0,
          get config() {
              return r.config
          },
          set config(c) {},
          use(c, ...h) {
              return a.has(c) || (c && _e(c.install) ? (a.add(c), c.install(u, ...h)) : _e(c) && (a.add(c), c(u, ...h))), u
          },
          mixin(c) {
              return r.mixins.includes(c) || r.mixins.push(c), u
          },
          component(c, h) {
              return h ? (r.components[c] = h, u) : r.components[c]
          },
          directive(c, h) {
              return h ? (r.directives[c] = h, u) : r.directives[c]
          },
          mount(c, h, d) {
              if (!o) {
                  const f = u._ceVNode || z(n, s);
                  return f.appContext = r, d === !0 ? d = "svg" : d === !1 && (d = void 0), h && e ? e(f, c) : i(f, c, d), o = !0, u._container = c, c.__vue_app__ = u, ma(f.component)
              }
          },
          onUnmount(c) {
              l.push(c)
          },
          unmount() {
              o && (ti(l, u._instance, 16), i(null, u._container), delete u._container.__vue_app__)
          },
          provide(c, h) {
              return r.provides[c] = h, u
          },
          runWithContext(c) {
              const h = rn;
              rn = u;
              try {
                  return c()
              } finally {
                  rn = h
              }
          }
      };
      return u
  }
}
let rn = null;

function Nn(i, e) {
  if (lt) {
      let t = lt.provides;
      const n = lt.parent && lt.parent.provides;
      n === t && (t = lt.provides = Object.create(n)), t[i] = e
  }
}

function zt(i, e, t = !1) {
  const n = lt || nt;
  if (n || rn) {
      const s = rn ? rn._context.provides : n ? n.parent == null ? n.vnode.appContext && n.vnode.appContext.provides : n.parent.provides : void 0;
      if (s && i in s) return s[i];
      if (arguments.length > 1) return t && _e(e) ? e.call(n && n.proxy) : e
  }
}

function c0() {
  return !!(lt || nt || rn)
}
const hf = {},
  df = () => Object.create(hf),
  ff = i => Object.getPrototypeOf(i) === hf;

function h0(i, e, t, n = !1) {
  const s = {},
      r = df();
  i.propsDefaults = Object.create(null), pf(i, e, s, r);
  for (const a in i.propsOptions[0]) a in s || (s[a] = void 0);
  t ? i.props = n ? s : Qo(s) : i.type.props ? i.props = s : i.props = r, i.attrs = r
}

function d0(i, e, t, n) {
  const {
      props: s,
      attrs: r,
      vnode: {
          patchFlag: a
      }
  } = i, l = Pe(s), [o] = i.propsOptions;
  let u = !1;
  if ((n || a > 0) && !(a & 16)) {
      if (a & 8) {
          const c = i.vnode.dynamicProps;
          for (let h = 0; h < c.length; h++) {
              let d = c[h];
              if (fa(i.emitsOptions, d)) continue;
              const f = e[d];
              if (o)
                  if (Re(r, d)) f !== r[d] && (r[d] = f, u = !0);
                  else {
                      const p = qt(d);
                      s[p] = Zl(o, l, p, f, i, !1)
                  }
              else f !== r[d] && (r[d] = f, u = !0)
          }
      }
  } else {
      pf(i, e, s, r) && (u = !0);
      let c;
      for (const h in l)(!e || !Re(e, h) && ((c = mn(h)) === h || !Re(e, c))) && (o ? t && (t[h] !== void 0 || t[c] !== void 0) && (s[h] = Zl(o, l, h, void 0, i, !0)) : delete s[h]);
      if (r !== l)
          for (const h in r)(!e || !Re(e, h) && !0) && (delete r[h], u = !0)
  }
  u && wi(i.attrs, "set", "")
}

function pf(i, e, t, n) {
  const [s, r] = i.propsOptions;
  let a = !1,
      l;
  if (e)
      for (let o in e) {
          if (us(o)) continue;
          const u = e[o];
          let c;
          s && Re(s, c = qt(o)) ? !r || !r.includes(c) ? t[c] = u : (l || (l = {}))[c] = u : fa(i.emitsOptions, o) || (!(o in n) || u !== n[o]) && (n[o] = u, a = !0)
      }
  if (r) {
      const o = Pe(t),
          u = l || ze;
      for (let c = 0; c < r.length; c++) {
          const h = r[c];
          t[h] = Zl(s, o, h, u[h], i, !Re(u, h))
      }
  }
  return a
}

function Zl(i, e, t, n, s, r) {
  const a = i[t];
  if (a != null) {
      const l = Re(a, "default");
      if (l && n === void 0) {
          const o = a.default;
          if (a.type !== Function && !a.skipFactory && _e(o)) {
              const {
                  propsDefaults: u
              } = s;
              if (t in u) n = u[t];
              else {
                  const c = Hs(s);
                  n = u[t] = o.call(null, e), c()
              }
          } else n = o;
          s.ce && s.ce._setProp(t, n)
      }
      a[0] && (r && !l ? n = !1 : a[1] && (n === "" || n === mn(t)) && (n = !0))
  }
  return n
}
const f0 = new WeakMap;

function mf(i, e, t = !1) {
  const n = t ? f0 : e.propsCache,
      s = n.get(i);
  if (s) return s;
  const r = i.props,
      a = {},
      l = [];
  let o = !1;
  if (!_e(i)) {
      const c = h => {
          o = !0;
          const [d, f] = mf(h, e, !0);
          et(a, d), f && l.push(...f)
      };
      !t && e.mixins.length && e.mixins.forEach(c), i.extends && c(i.extends), i.mixins && i.mixins.forEach(c)
  }
  if (!r && !o) return De(i) && n.set(i, $n), $n;
  if (ve(r))
      for (let c = 0; c < r.length; c++) {
          const h = qt(r[c]);
          Yu(h) && (a[h] = ze)
      } else if (r)
          for (const c in r) {
              const h = qt(c);
              if (Yu(h)) {
                  const d = r[c],
                      f = a[h] = ve(d) || _e(d) ? {
                          type: d
                      } : et({}, d),
                      p = f.type;
                  let g = !1,
                      w = !0;
                  if (ve(p))
                      for (let y = 0; y < p.length; ++y) {
                          const b = p[y],
                              x = _e(b) && b.name;
                          if (x === "Boolean") {
                              g = !0;
                              break
                          } else x === "String" && (w = !1)
                      } else g = _e(p) && p.name === "Boolean";
                  f[0] = g, f[1] = w, (g || Re(f, "default")) && l.push(h)
              }
          }
  const u = [a, l];
  return De(i) && n.set(i, u), u
}

function Yu(i) {
  return i[0] !== "$" && !us(i)
}
const gf = i => i[0] === "_" || i === "$stable",
  au = i => ve(i) ? i.map(hi) : [hi(i)],
  p0 = (i, e, t) => {
      if (e._n) return e;
      const n = We((...s) => au(e(...s)), t);
      return n._c = !1, n
  },
  yf = (i, e, t) => {
      const n = i._ctx;
      for (const s in i) {
          if (gf(s)) continue;
          const r = i[s];
          if (_e(r)) e[s] = p0(s, r, n);
          else if (r != null) {
              const a = au(r);
              e[s] = () => a
          }
      }
  },
  vf = (i, e) => {
      const t = au(e);
      i.slots.default = () => t
  },
  bf = (i, e, t) => {
      for (const n in e)(t || n !== "_") && (i[n] = e[n])
  },
  m0 = (i, e, t) => {
      const n = i.slots = df();
      if (i.vnode.shapeFlag & 32) {
          const s = e._;
          s ? (bf(n, e, t), t && _d(n, "_", s, !0)) : yf(e, n)
      } else e && vf(i, e)
  },
  g0 = (i, e, t) => {
      const {
          vnode: n,
          slots: s
      } = i;
      let r = !0,
          a = ze;
      if (n.shapeFlag & 32) {
          const l = e._;
          l ? t && l === 1 ? r = !1 : bf(s, e, t) : (r = !e.$stable, yf(e, s)), a = e
      } else e && (vf(i, e), a = {
          default: 1
      });
      if (r)
          for (const l in s) !gf(l) && a[l] == null && delete s[l]
  };

function y0() {
  typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ != "boolean" && (Us().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = !1)
}
const Lt = I0;

function v0(i) {
  return b0(i)
}

function b0(i, e) {
  y0();
  const t = Us();
  t.__VUE__ = !0;
  const {
      insert: n,
      remove: s,
      patchProp: r,
      createElement: a,
      createText: l,
      createComment: o,
      setText: u,
      setElementText: c,
      parentNode: h,
      nextSibling: d,
      setScopeId: f = Qt,
      insertStaticContent: p
  } = i, g = (E, C, R, K = null, j = null, Y = null, ce = void 0, re = null, ne = !!C.dynamicChildren) => {
      if (E === C) return;
      E && !nn(E, C) && (K = H(E), it(E, j, Y, !0), E = null), C.patchFlag === -2 && (ne = !1, C.dynamicChildren = null);
      const {
          type: ee,
          ref: we,
          shapeFlag: de
      } = C;
      switch (ee) {
          case pa:
              w(E, C, R, K);
              break;
          case _t:
              y(E, C, R, K);
              break;
          case xr:
              E == null && b(C, R, K, ce);
              break;
          case F:
              N(E, C, R, K, j, Y, ce, re, ne);
              break;
          default:
              de & 1 ? S(E, C, R, K, j, Y, ce, re, ne) : de & 6 ? O(E, C, R, K, j, Y, ce, re, ne) : (de & 64 || de & 128) && ee.process(E, C, R, K, j, Y, ce, re, ne, me)
      }
      we != null && j && Or(we, E && E.ref, Y, C || E, !C)
  }, w = (E, C, R, K) => {
      if (E == null) n(C.el = l(C.children), R, K);
      else {
          const j = C.el = E.el;
          C.children !== E.children && u(j, C.children)
      }
  }, y = (E, C, R, K) => {
      E == null ? n(C.el = o(C.children || ""), R, K) : C.el = E.el
  }, b = (E, C, R, K) => {
      [E.el, E.anchor] = p(E.children, C, R, K, E.el, E.anchor)
  }, x = ({
      el: E,
      anchor: C
  }, R, K) => {
      let j;
      for (; E && E !== C;) j = d(E), n(E, R, K), E = j;
      n(C, R, K)
  }, k = ({
      el: E,
      anchor: C
  }) => {
      let R;
      for (; E && E !== C;) R = d(E), s(E), E = R;
      s(C)
  }, S = (E, C, R, K, j, Y, ce, re, ne) => {
      C.type === "svg" ? ce = "svg" : C.type === "math" && (ce = "mathml"), E == null ? B(C, R, K, j, Y, ce, re, ne) : I(E, C, j, Y, ce, re, ne)
  }, B = (E, C, R, K, j, Y, ce, re) => {
      let ne, ee;
      const {
          props: we,
          shapeFlag: de,
          transition: ge,
          dirs: ke
      } = E;
      if (ne = E.el = a(E.type, Y, we && we.is, we), de & 8 ? c(ne, E.children) : de & 16 && P(E.children, ne, null, K, j, Oa(E, Y), ce, re), ke && Yi(E, null, K, "created"), D(ne, E, E.scopeId, ce, K), we) {
          for (const Ue in we) Ue !== "value" && !us(Ue) && r(ne, Ue, null, we[Ue], Y, K);
          "value" in we && r(ne, "value", null, we.value, Y), (ee = we.onVnodeBeforeMount) && li(ee, K, E)
      }
      ke && Yi(E, null, K, "beforeMount");
      const Le = w0(j, ge);
      Le && ge.beforeEnter(ne), n(ne, C, R), ((ee = we && we.onVnodeMounted) || Le || ke) && Lt(() => {
          ee && li(ee, K, E), Le && ge.enter(ne), ke && Yi(E, null, K, "mounted")
      }, j)
  }, D = (E, C, R, K, j) => {
      if (R && f(E, R), K)
          for (let Y = 0; Y < K.length; Y++) f(E, K[Y]);
      if (j) {
          let Y = j.subTree;
          if (C === Y || Sf(Y.type) && (Y.ssContent === C || Y.ssFallback === C)) {
              const ce = j.vnode;
              D(E, ce, ce.scopeId, ce.slotScopeIds, j.parent)
          }
      }
  }, P = (E, C, R, K, j, Y, ce, re, ne = 0) => {
      for (let ee = ne; ee < E.length; ee++) {
          const we = E[ee] = re ? Di(E[ee]) : hi(E[ee]);
          g(null, we, C, R, K, j, Y, ce, re)
      }
  }, I = (E, C, R, K, j, Y, ce) => {
      const re = C.el = E.el;
      let {
          patchFlag: ne,
          dynamicChildren: ee,
          dirs: we
      } = C;
      ne |= E.patchFlag & 16;
      const de = E.props || ze,
          ge = C.props || ze;
      let ke;
      if (R && Qi(R, !1), (ke = ge.onVnodeBeforeUpdate) && li(ke, R, C, E), we && Yi(C, E, R, "beforeUpdate"), R && Qi(R, !0), (de.innerHTML && ge.innerHTML == null || de.textContent && ge.textContent == null) && c(re, ""), ee ? $(E.dynamicChildren, ee, re, R, K, Oa(C, j), Y) : ce || ae(E, C, re, null, R, K, Oa(C, j), Y, !1), ne > 0) {
          if (ne & 16) V(re, de, ge, R, j);
          else if (ne & 2 && de.class !== ge.class && r(re, "class", null, ge.class, j), ne & 4 && r(re, "style", de.style, ge.style, j), ne & 8) {
              const Le = C.dynamicProps;
              for (let Ue = 0; Ue < Le.length; Ue++) {
                  const Be = Le[Ue],
                      Et = de[Be],
                      ft = ge[Be];
                  (ft !== Et || Be === "value") && r(re, Be, Et, ft, j, R)
              }
          }
          ne & 1 && E.children !== C.children && c(re, C.children)
      } else !ce && ee == null && V(re, de, ge, R, j);
      ((ke = ge.onVnodeUpdated) || we) && Lt(() => {
          ke && li(ke, R, C, E), we && Yi(C, E, R, "updated")
      }, K)
  }, $ = (E, C, R, K, j, Y, ce) => {
      for (let re = 0; re < C.length; re++) {
          const ne = E[re],
              ee = C[re],
              we = ne.el && (ne.type === F || !nn(ne, ee) || ne.shapeFlag & 70) ? h(ne.el) : R;
          g(ne, ee, we, null, K, j, Y, ce, !0)
      }
  }, V = (E, C, R, K, j) => {
      if (C !== R) {
          if (C !== ze)
              for (const Y in C) !us(Y) && !(Y in R) && r(E, Y, C[Y], null, j, K);
          for (const Y in R) {
              if (us(Y)) continue;
              const ce = R[Y],
                  re = C[Y];
              ce !== re && Y !== "value" && r(E, Y, re, ce, j, K)
          }
          "value" in R && r(E, "value", C.value, R.value, j)
      }
  }, N = (E, C, R, K, j, Y, ce, re, ne) => {
      const ee = C.el = E ? E.el : l(""),
          we = C.anchor = E ? E.anchor : l("");
      let {
          patchFlag: de,
          dynamicChildren: ge,
          slotScopeIds: ke
      } = C;
      ke && (re = re ? re.concat(ke) : ke), E == null ? (n(ee, R, K), n(we, R, K), P(C.children || [], R, we, j, Y, ce, re, ne)) : de > 0 && de & 64 && ge && E.dynamicChildren ? ($(E.dynamicChildren, ge, R, j, Y, ce, re), (C.key != null || j && C === j.subTree) && wf(E, C, !0)) : ae(E, C, R, we, j, Y, ce, re, ne)
  }, O = (E, C, R, K, j, Y, ce, re, ne) => {
      C.slotScopeIds = re, E == null ? C.shapeFlag & 512 ? j.ctx.activate(C, R, K, ce, ne) : se(C, R, K, j, Y, ce, ne) : G(E, C, ne)
  }, se = (E, C, R, K, j, Y, ce) => {
      const re = E.component = D0(E, K, j);
      if (ua(E) && (re.ctx.renderer = me), F0(re, !1, ce), re.asyncDep) {
          if (j && j.registerDep(re, te, ce), !E.el) {
              const ne = re.subTree = z(_t);
              y(null, ne, C, R)
          }
      } else te(re, E, C, R, j, Y, ce)
  }, G = (E, C, R) => {
      const K = C.component = E.component;
      if (L0(E, C, R))
          if (K.asyncDep && !K.asyncResolved) {
              le(K, C, R);
              return
          } else K.next = C, K.update();
      else C.el = E.el, K.vnode = C
  }, te = (E, C, R, K, j, Y, ce) => {
      const re = () => {
          if (E.isMounted) {
              let {
                  next: de,
                  bu: ge,
                  u: ke,
                  parent: Le,
                  vnode: Ue
              } = E;
              {
                  const Ct = kf(E);
                  if (Ct) {
                      de && (de.el = Ue.el, le(E, de, ce)), Ct.asyncDep.then(() => {
                          E.isUnmounted || re()
                      });
                      return
                  }
              }
              let Be = de,
                  Et;
              Qi(E, !1), de ? (de.el = Ue.el, le(E, de, ce)) : de = Ue, ge && _r(ge), (Et = de.props && de.props.onVnodeBeforeUpdate) && li(Et, Le, de, Ue), Qi(E, !0);
              const ft = Da(E),
                  Kt = E.subTree;
              E.subTree = ft, g(Kt, ft, h(Kt.el), H(Kt), E, j, Y), de.el = ft.el, Be === null && P0(E, ft.el), ke && Lt(ke, j), (Et = de.props && de.props.onVnodeUpdated) && Lt(() => li(Et, Le, de, Ue), j)
          } else {
              let de;
              const {
                  el: ge,
                  props: ke
              } = C, {
                  bm: Le,
                  m: Ue,
                  parent: Be,
                  root: Et,
                  type: ft
              } = E, Kt = In(C);
              if (Qi(E, !1), Le && _r(Le), !Kt && (de = ke && ke.onVnodeBeforeMount) && li(de, Be, C), Qi(E, !0), ge && Ke) {
                  const Ct = () => {
                      E.subTree = Da(E), Ke(ge, E.subTree, E, j, null)
                  };
                  Kt && ft.__asyncHydrate ? ft.__asyncHydrate(ge, E, Ct) : Ct()
              } else {
                  Et.ce && Et.ce._injectChildStyle(ft);
                  const Ct = E.subTree = Da(E);
                  g(null, Ct, R, K, E, j, Y), C.el = Ct.el
              }
              if (Ue && Lt(Ue, j), !Kt && (de = ke && ke.onVnodeMounted)) {
                  const Ct = C;
                  Lt(() => li(de, Be, Ct), j)
              }(C.shapeFlag & 256 || Be && In(Be.vnode) && Be.vnode.shapeFlag & 256) && E.a && Lt(E.a, j), E.isMounted = !0, C = R = K = null
          }
      };
      E.scope.on();
      const ne = E.effect = new Ld(re);
      E.scope.off();
      const ee = E.update = ne.run.bind(ne),
          we = E.job = ne.runIfDirty.bind(ne);
      we.i = E, we.id = E.uid, ne.scheduler = () => tu(we), Qi(E, !0), ee()
  }, le = (E, C, R) => {
      C.component = E;
      const K = E.vnode.props;
      E.vnode = C, E.next = null, d0(E, C.props, K, R), g0(E, C.children, R), Gi(), ju(E), Ki()
  }, ae = (E, C, R, K, j, Y, ce, re, ne = !1) => {
      const ee = E && E.children,
          we = E ? E.shapeFlag : 0,
          de = C.children,
          {
              patchFlag: ge,
              shapeFlag: ke
          } = C;
      if (ge > 0) {
          if (ge & 128) {
              Oe(ee, de, R, K, j, Y, ce, re, ne);
              return
          } else if (ge & 256) {
              $e(ee, de, R, K, j, Y, ce, re, ne);
              return
          }
      }
      ke & 8 ? (we & 16 && Bt(ee, j, Y), de !== ee && c(R, de)) : we & 16 ? ke & 16 ? Oe(ee, de, R, K, j, Y, ce, re, ne) : Bt(ee, j, Y, !0) : (we & 8 && c(R, ""), ke & 16 && P(de, R, K, j, Y, ce, re, ne))
  }, $e = (E, C, R, K, j, Y, ce, re, ne) => {
      E = E || $n, C = C || $n;
      const ee = E.length,
          we = C.length,
          de = Math.min(ee, we);
      let ge;
      for (ge = 0; ge < de; ge++) {
          const ke = C[ge] = ne ? Di(C[ge]) : hi(C[ge]);
          g(E[ge], ke, R, null, j, Y, ce, re, ne)
      }
      ee > we ? Bt(E, j, Y, !0, !1, de) : P(C, R, K, j, Y, ce, re, ne, de)
  }, Oe = (E, C, R, K, j, Y, ce, re, ne) => {
      let ee = 0;
      const we = C.length;
      let de = E.length - 1,
          ge = we - 1;
      for (; ee <= de && ee <= ge;) {
          const ke = E[ee],
              Le = C[ee] = ne ? Di(C[ee]) : hi(C[ee]);
          if (nn(ke, Le)) g(ke, Le, R, null, j, Y, ce, re, ne);
          else break;
          ee++
      }
      for (; ee <= de && ee <= ge;) {
          const ke = E[de],
              Le = C[ge] = ne ? Di(C[ge]) : hi(C[ge]);
          if (nn(ke, Le)) g(ke, Le, R, null, j, Y, ce, re, ne);
          else break;
          de--, ge--
      }
      if (ee > de) {
          if (ee <= ge) {
              const ke = ge + 1,
                  Le = ke < we ? C[ke].el : K;
              for (; ee <= ge;) g(null, C[ee] = ne ? Di(C[ee]) : hi(C[ee]), R, Le, j, Y, ce, re, ne), ee++
          }
      } else if (ee > ge)
          for (; ee <= de;) it(E[ee], j, Y, !0), ee++;
      else {
          const ke = ee,
              Le = ee,
              Ue = new Map;
          for (ee = Le; ee <= ge; ee++) {
              const $t = C[ee] = ne ? Di(C[ee]) : hi(C[ee]);
              $t.key != null && Ue.set($t.key, ee)
          }
          let Be, Et = 0;
          const ft = ge - Le + 1;
          let Kt = !1,
              Ct = 0;
          const ts = new Array(ft);
          for (ee = 0; ee < ft; ee++) ts[ee] = 0;
          for (ee = ke; ee <= de; ee++) {
              const $t = E[ee];
              if (Et >= ft) {
                  it($t, j, Y, !0);
                  continue
              }
              let ai;
              if ($t.key != null) ai = Ue.get($t.key);
              else
                  for (Be = Le; Be <= ge; Be++)
                      if (ts[Be - Le] === 0 && nn($t, C[Be])) {
                          ai = Be;
                          break
                      } ai === void 0 ? it($t, j, Y, !0) : (ts[ai - Le] = ee + 1, ai >= Ct ? Ct = ai : Kt = !0, g($t, C[ai], R, null, j, Y, ce, re, ne), Et++)
          }
          const Ou = Kt ? k0(ts) : $n;
          for (Be = Ou.length - 1, ee = ft - 1; ee >= 0; ee--) {
              const $t = Le + ee,
                  ai = C[$t],
                  Du = $t + 1 < we ? C[$t + 1].el : K;
              ts[ee] === 0 ? g(null, ai, R, Du, j, Y, ce, re, ne) : Kt && (Be < 0 || ee !== Ou[Be] ? Ye(ai, R, Du, 2) : Be--)
          }
      }
  }, Ye = (E, C, R, K, j = null) => {
      const {
          el: Y,
          type: ce,
          transition: re,
          children: ne,
          shapeFlag: ee
      } = E;
      if (ee & 6) {
          Ye(E.component.subTree, C, R, K);
          return
      }
      if (ee & 128) {
          E.suspense.move(C, R, K);
          return
      }
      if (ee & 64) {
          ce.move(E, C, R, me);
          return
      }
      if (ce === F) {
          n(Y, C, R);
          for (let de = 0; de < ne.length; de++) Ye(ne[de], C, R, K);
          n(E.anchor, C, R);
          return
      }
      if (ce === xr) {
          x(E, C, R);
          return
      }
      if (K !== 2 && ee & 1 && re)
          if (K === 0) re.beforeEnter(Y), n(Y, C, R), Lt(() => re.enter(Y), j);
          else {
              const {
                  leave: de,
                  delayLeave: ge,
                  afterLeave: ke
              } = re, Le = () => n(Y, C, R), Ue = () => {
                  de(Y, () => {
                      Le(), ke && ke()
                  })
              };
              ge ? ge(Y, Le, Ue) : Ue()
          }
      else n(Y, C, R)
  }, it = (E, C, R, K = !1, j = !1) => {
      const {
          type: Y,
          props: ce,
          ref: re,
          children: ne,
          dynamicChildren: ee,
          shapeFlag: we,
          patchFlag: de,
          dirs: ge,
          cacheIndex: ke
      } = E;
      if (de === -2 && (j = !1), re != null && Or(re, null, R, E, !0), ke != null && (C.renderCache[ke] = void 0), we & 256) {
          C.ctx.deactivate(E);
          return
      }
      const Le = we & 1 && ge,
          Ue = !In(E);
      let Be;
      if (Ue && (Be = ce && ce.onVnodeBeforeUnmount) && li(Be, C, E), we & 6) Qs(E.component, R, K);
      else {
          if (we & 128) {
              E.suspense.unmount(R, K);
              return
          }
          Le && Yi(E, null, C, "beforeUnmount"), we & 64 ? E.type.remove(E, C, R, me, K) : ee && !ee.hasOnce && (Y !== F || de > 0 && de & 64) ? Bt(ee, C, R, !1, !0) : (Y === F && de & 384 || !j && we & 16) && Bt(ne, C, R), K && gn(E)
      }(Ue && (Be = ce && ce.onVnodeUnmounted) || Le) && Lt(() => {
          Be && li(Be, C, E), Le && Yi(E, null, C, "unmounted")
      }, R)
  }, gn = E => {
      const {
          type: C,
          el: R,
          anchor: K,
          transition: j
      } = E;
      if (C === F) {
          yn(R, K);
          return
      }
      if (C === xr) {
          k(E);
          return
      }
      const Y = () => {
          s(R), j && !j.persisted && j.afterLeave && j.afterLeave()
      };
      if (E.shapeFlag & 1 && j && !j.persisted) {
          const {
              leave: ce,
              delayLeave: re
          } = j, ne = () => ce(R, Y);
          re ? re(E.el, Y, ne) : ne()
      } else Y()
  }, yn = (E, C) => {
      let R;
      for (; E !== C;) R = d(E), s(E), E = R;
      s(C)
  }, Qs = (E, C, R) => {
      const {
          bum: K,
          scope: j,
          job: Y,
          subTree: ce,
          um: re,
          m: ne,
          a: ee
      } = E;
      Qu(ne), Qu(ee), K && _r(K), j.stop(), Y && (Y.flags |= 8, it(ce, E, C, R)), re && Lt(re, C), Lt(() => {
          E.isUnmounted = !0
      }, C), C && C.pendingBranch && !C.isUnmounted && E.asyncDep && !E.asyncResolved && E.suspenseId === C.pendingId && (C.deps--, C.deps === 0 && C.resolve())
  }, Bt = (E, C, R, K = !1, j = !1, Y = 0) => {
      for (let ce = Y; ce < E.length; ce++) it(E[ce], C, R, K, j)
  }, H = E => {
      if (E.shapeFlag & 6) return H(E.component.subTree);
      if (E.shapeFlag & 128) return E.suspense.next();
      const C = d(E.anchor || E.el),
          R = C && C[Wg];
      return R ? d(R) : C
  };
  let fe = !1;
  const he = (E, C, R) => {
          E == null ? C._vnode && it(C._vnode, null, null, !0) : g(C._vnode || null, E, C, null, null, null, R), C._vnode = E, fe || (fe = !0, ju(), Xd(), fe = !1)
      },
      me = {
          p: g,
          um: it,
          m: Ye,
          r: gn,
          mt: se,
          mc: P,
          pc: ae,
          pbc: $,
          n: H,
          o: i
      };
  let Ne, Ke;
  return e && ([Ne, Ke] = e(me)), {
      render: he,
      hydrate: Ne,
      createApp: u0(he, Ne)
  }
}

function Oa({
  type: i,
  props: e
}, t) {
  return t === "svg" && i === "foreignObject" || t === "mathml" && i === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t
}

function Qi({
  effect: i,
  job: e
}, t) {
  t ? (i.flags |= 32, e.flags |= 4) : (i.flags &= -33, e.flags &= -5)
}

function w0(i, e) {
  return (!i || i && !i.pendingBranch) && e && !e.persisted
}

function wf(i, e, t = !1) {
  const n = i.children,
      s = e.children;
  if (ve(n) && ve(s))
      for (let r = 0; r < n.length; r++) {
          const a = n[r];
          let l = s[r];
          l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = s[r] = Di(s[r]), l.el = a.el), !t && l.patchFlag !== -2 && wf(a, l)), l.type === pa && (l.el = a.el)
      }
}

function k0(i) {
  const e = i.slice(),
      t = [0];
  let n, s, r, a, l;
  const o = i.length;
  for (n = 0; n < o; n++) {
      const u = i[n];
      if (u !== 0) {
          if (s = t[t.length - 1], i[s] < u) {
              e[n] = s, t.push(n);
              continue
          }
          for (r = 0, a = t.length - 1; r < a;) l = r + a >> 1, i[t[l]] < u ? r = l + 1 : a = l;
          u < i[t[r]] && (r > 0 && (e[n] = t[r - 1]), t[r] = n)
      }
  }
  for (r = t.length, a = t[r - 1]; r-- > 0;) t[r] = a, a = e[a];
  return t
}

function kf(i) {
  const e = i.subTree.component;
  if (e) return e.asyncDep && !e.asyncResolved ? e : kf(e)
}

function Qu(i) {
  if (i)
      for (let e = 0; e < i.length; e++) i[e].flags |= 8
}
const _0 = Symbol.for("v-scx"),
  x0 = () => zt(_0);

function Ie(i, e, t) {
  return _f(i, e, t)
}

function _f(i, e, t = ze) {
  const {
      immediate: n,
      deep: s,
      flush: r,
      once: a
  } = t, l = et({}, t), o = e && n || !e && r !== "post";
  let u;
  if ($s) {
      if (r === "sync") {
          const f = x0();
          u = f.__watcherHandles || (f.__watcherHandles = [])
      } else if (!o) {
          const f = () => {};
          return f.stop = Qt, f.resume = Qt, f.pause = Qt, f
      }
  }
  const c = lt;
  l.call = (f, p, g) => ti(f, c, p, g);
  let h = !1;
  r === "post" ? l.scheduler = f => {
      Lt(f, c && c.suspense)
  } : r !== "sync" && (h = !0, l.scheduler = (f, p) => {
      p ? f() : tu(f)
  }), l.augmentJob = f => {
      e && (f.flags |= 4), h && (f.flags |= 2, c && (f.id = c.uid, f.i = c))
  };
  const d = Bg(i, e, l);
  return $s && (u ? u.push(d) : o && d()), d
}

function T0(i, e, t) {
  const n = this.proxy,
      s = Qe(i) ? i.includes(".") ? xf(n, i) : () => n[i] : i.bind(n, n);
  let r;
  _e(e) ? r = e : (r = e.handler, t = e);
  const a = Hs(this),
      l = _f(s, r.bind(n), t);
  return a(), l
}

function xf(i, e) {
  const t = e.split(".");
  return () => {
      let n = i;
      for (let s = 0; s < t.length && n; s++) n = n[t[s]];
      return n
  }
}
const S0 = (i, e) => e === "modelValue" || e === "model-value" ? i.modelModifiers : i[`${e}Modifiers`] || i[`${qt(e)}Modifiers`] || i[`${mn(e)}Modifiers`];

function E0(i, e, ...t) {
  if (i.isUnmounted) return;
  const n = i.vnode.props || ze;
  let s = t;
  const r = e.startsWith("update:"),
      a = r && S0(n, e.slice(7));
  a && (a.trim && (s = t.map(c => Qe(c) ? c.trim() : c)), a.number && (s = t.map(Ir)));
  let l, o = n[l = kr(e)] || n[l = kr(qt(e))];
  !o && r && (o = n[l = kr(mn(e))]), o && ti(o, i, 6, s);
  const u = n[l + "Once"];
  if (u) {
      if (!i.emitted) i.emitted = {};
      else if (i.emitted[l]) return;
      i.emitted[l] = !0, ti(u, i, 6, s)
  }
}

function Tf(i, e, t = !1) {
  const n = e.emitsCache,
      s = n.get(i);
  if (s !== void 0) return s;
  const r = i.emits;
  let a = {},
      l = !1;
  if (!_e(i)) {
      const o = u => {
          const c = Tf(u, e, !0);
          c && (l = !0, et(a, c))
      };
      !t && e.mixins.length && e.mixins.forEach(o), i.extends && o(i.extends), i.mixins && i.mixins.forEach(o)
  }
  return !r && !l ? (De(i) && n.set(i, null), null) : (ve(r) ? r.forEach(o => a[o] = null) : et(a, r), De(i) && n.set(i, a), a)
}

function fa(i, e) {
  return !i || !ta(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Re(i, e[0].toLowerCase() + e.slice(1)) || Re(i, mn(e)) || Re(i, e))
}

function Da(i) {
  const {
      type: e,
      vnode: t,
      proxy: n,
      withProxy: s,
      propsOptions: [r],
      slots: a,
      attrs: l,
      emit: o,
      render: u,
      renderCache: c,
      props: h,
      data: d,
      setupState: f,
      ctx: p,
      inheritAttrs: g
  } = i, w = Br(i);
  let y, b;
  try {
      if (t.shapeFlag & 4) {
          const k = s || n,
              S = k;
          y = hi(u.call(S, k, c, h, f, d, p)), b = l
      } else {
          const k = e;
          y = hi(k.length > 1 ? k(h, {
              attrs: l,
              slots: a,
              emit: o
          }) : k(h, null)), b = e.props ? l : C0(l)
      }
  } catch (k) {
      fs.length = 0, la(k, i, 1), y = z(_t)
  }
  let x = y;
  if (b && g !== !1) {
      const k = Object.keys(b),
          {
              shapeFlag: S
          } = x;
      k.length && S & 7 && (r && k.some(jo) && (b = $0(b, r)), x = ji(x, b, !1, !0))
  }
  return t.dirs && (x = ji(x, null, !1, !0), x.dirs = x.dirs ? x.dirs.concat(t.dirs) : t.dirs), t.transition && on(x, t.transition), y = x, Br(w), y
}
const C0 = i => {
      let e;
      for (const t in i)(t === "class" || t === "style" || ta(t)) && ((e || (e = {}))[t] = i[t]);
      return e
  },
  $0 = (i, e) => {
      const t = {};
      for (const n in i)(!jo(n) || !(n.slice(9) in e)) && (t[n] = i[n]);
      return t
  };

function L0(i, e, t) {
  const {
      props: n,
      children: s,
      component: r
  } = i, {
      props: a,
      children: l,
      patchFlag: o
  } = e, u = r.emitsOptions;
  if (e.dirs || e.transition) return !0;
  if (t && o >= 0) {
      if (o & 1024) return !0;
      if (o & 16) return n ? Zu(n, a, u) : !!a;
      if (o & 8) {
          const c = e.dynamicProps;
          for (let h = 0; h < c.length; h++) {
              const d = c[h];
              if (a[d] !== n[d] && !fa(u, d)) return !0
          }
      }
  } else return (s || l) && (!l || !l.$stable) ? !0 : n === a ? !1 : n ? a ? Zu(n, a, u) : !0 : !!a;
  return !1
}

function Zu(i, e, t) {
  const n = Object.keys(e);
  if (n.length !== Object.keys(i).length) return !0;
  for (let s = 0; s < n.length; s++) {
      const r = n[s];
      if (e[r] !== i[r] && !fa(t, r)) return !0
  }
  return !1
}

function P0({
  vnode: i,
  parent: e
}, t) {
  for (; e;) {
      const n = e.subTree;
      if (n.suspense && n.suspense.activeBranch === i && (n.el = i.el), n === i)(i = e.vnode).el = t, e = e.parent;
      else break
  }
}
const Sf = i => i.__isSuspense;

function I0(i, e) {
  e && e.pendingBranch ? ve(i) ? e.effects.push(...i) : e.effects.push(i) : Fg(i)
}
const F = Symbol.for("v-fgt"),
  pa = Symbol.for("v-txt"),
  _t = Symbol.for("v-cmt"),
  xr = Symbol.for("v-stc"),
  fs = [];
let It = null;

function _(i = !1) {
  fs.push(It = i ? null : [])
}

function N0() {
  fs.pop(), It = fs[fs.length - 1] || null
}
let Es = 1;

function ec(i, e = !1) {
  Es += i, i < 0 && It && e && (It.hasOnce = !0)
}

function Ef(i) {
  return i.dynamicChildren = Es > 0 ? It || $n : null, N0(), Es > 0 && It && It.push(i), i
}

function T(i, e, t, n, s, r) {
  return Ef(m(i, e, t, n, s, r, !0))
}

function xe(i, e, t, n, s) {
  return Ef(z(i, e, t, n, s, !0))
}

function Cs(i) {
  return i ? i.__v_isVNode === !0 : !1
}

function nn(i, e) {
  return i.type === e.type && i.key === e.key
}
const Cf = ({
      key: i
  }) => i ?? null,
  Tr = ({
      ref: i,
      ref_key: e,
      ref_for: t
  }) => (typeof i == "number" && (i = "" + i), i != null ? Qe(i) || Je(i) || _e(i) ? {
      i: nt,
      r: i,
      k: e,
      f: !!t
  } : i : null);

function m(i, e = null, t = null, n = 0, s = null, r = i === F ? 0 : 1, a = !1, l = !1) {
  const o = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: i,
      props: e,
      key: e && Cf(e),
      ref: e && Tr(e),
      scopeId: oa,
      slotScopeIds: null,
      children: t,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetStart: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag: r,
      patchFlag: n,
      dynamicProps: s,
      dynamicChildren: null,
      appContext: null,
      ctx: nt
  };
  return l ? (lu(o, t), r & 128 && i.normalize(o)) : t && (o.shapeFlag |= Qe(t) ? 8 : 16), Es > 0 && !a && It && (o.patchFlag > 0 || r & 6) && o.patchFlag !== 32 && It.push(o), o
}
const z = M0;

function M0(i, e = null, t = null, n = 0, s = null, r = !1) {
  if ((!i || i === lf) && (i = _t), Cs(i)) {
      const l = ji(i, e, !0);
      return t && lu(l, t), Es > 0 && !r && It && (l.shapeFlag & 6 ? It[It.indexOf(i)] = l : It.push(l)), l.patchFlag = -2, l
  }
  if (U0(i) && (i = i.__vccOpts), e) {
      e = R0(e);
      let {
          class: l,
          style: o
      } = e;
      l && !Qe(l) && (e.class = ie(l)), De(o) && (eu(o) && !ve(o) && (o = et({}, o)), e.style = tt(o))
  }
  const a = Qe(i) ? 1 : Sf(i) ? 128 : Yd(i) ? 64 : De(i) ? 4 : _e(i) ? 2 : 0;
  return m(i, e, t, n, s, a, r, !0)
}

function R0(i) {
  return i ? eu(i) || ff(i) ? et({}, i) : i : null
}

function ji(i, e, t = !1, n = !1) {
  const {
      props: s,
      ref: r,
      patchFlag: a,
      children: l,
      transition: o
  } = i, u = e ? $f(s || {}, e) : s, c = {
      __v_isVNode: !0,
      __v_skip: !0,
      type: i.type,
      props: u,
      key: u && Cf(u),
      ref: e && e.ref ? t && r ? ve(r) ? r.concat(Tr(e)) : [r, Tr(e)] : Tr(e) : r,
      scopeId: i.scopeId,
      slotScopeIds: i.slotScopeIds,
      children: l,
      target: i.target,
      targetStart: i.targetStart,
      targetAnchor: i.targetAnchor,
      staticCount: i.staticCount,
      shapeFlag: i.shapeFlag,
      patchFlag: e && i.type !== F ? a === -1 ? 16 : a | 16 : a,
      dynamicProps: i.dynamicProps,
      dynamicChildren: i.dynamicChildren,
      appContext: i.appContext,
      dirs: i.dirs,
      transition: o,
      component: i.component,
      suspense: i.suspense,
      ssContent: i.ssContent && ji(i.ssContent),
      ssFallback: i.ssFallback && ji(i.ssFallback),
      el: i.el,
      anchor: i.anchor,
      ctx: i.ctx,
      ce: i.ce
  };
  return o && n && on(c, o.clone(c)), c
}

function Xe(i = " ", e = 0) {
  return z(pa, null, i, e)
}

function un(i, e) {
  const t = z(xr, null, i);
  return t.staticCount = e, t
}

function ye(i = "", e = !1) {
  return e ? (_(), xe(_t, null, i)) : z(_t, null, i)
}

function hi(i) {
  return i == null || typeof i == "boolean" ? z(_t) : ve(i) ? z(F, null, i.slice()) : Cs(i) ? Di(i) : z(pa, null, String(i))
}

function Di(i) {
  return i.el === null && i.patchFlag !== -1 || i.memo ? i : ji(i)
}

function lu(i, e) {
  let t = 0;
  const {
      shapeFlag: n
  } = i;
  if (e == null) e = null;
  else if (ve(e)) t = 16;
  else if (typeof e == "object")
      if (n & 65) {
          const s = e.default;
          s && (s._c && (s._d = !1), lu(i, s()), s._c && (s._d = !0));
          return
      } else {
          t = 32;
          const s = e._;
          !s && !ff(e) ? e._ctx = nt : s === 3 && nt && (nt.slots._ === 1 ? e._ = 1 : (e._ = 2, i.patchFlag |= 1024))
      }
  else _e(e) ? (e = {
      default: e,
      _ctx: nt
  }, t = 32) : (e = String(e), n & 64 ? (t = 16, e = [Xe(e)]) : t = 8);
  i.children = e, i.shapeFlag |= t
}

function $f(...i) {
  const e = {};
  for (let t = 0; t < i.length; t++) {
      const n = i[t];
      for (const s in n)
          if (s === "class") e.class !== n.class && (e.class = ie([e.class, n.class]));
          else if (s === "style") e.style = tt([e.style, n.style]);
      else if (ta(s)) {
          const r = e[s],
              a = n[s];
          a && r !== a && !(ve(r) && r.includes(a)) && (e[s] = r ? [].concat(r, a) : a)
      } else s !== "" && (e[s] = n[s])
  }
  return e
}

function li(i, e, t, n = null) {
  ti(i, e, 7, [t, n])
}
const B0 = cf();
let O0 = 0;

function D0(i, e, t) {
  const n = i.type,
      s = (e ? e.appContext : i.appContext) || B0,
      r = {
          uid: O0++,
          vnode: i,
          type: n,
          parent: e,
          appContext: s,
          root: null,
          next: null,
          subTree: null,
          effect: null,
          update: null,
          job: null,
          scope: new Ed(!0),
          render: null,
          proxy: null,
          exposed: null,
          exposeProxy: null,
          withProxy: null,
          provides: e ? e.provides : Object.create(s.provides),
          ids: e ? e.ids : ["", 0, 0],
          accessCache: null,
          renderCache: [],
          components: null,
          directives: null,
          propsOptions: mf(n, s),
          emitsOptions: Tf(n, s),
          emit: null,
          emitted: null,
          propsDefaults: ze,
          inheritAttrs: n.inheritAttrs,
          ctx: ze,
          data: ze,
          props: ze,
          attrs: ze,
          slots: ze,
          refs: ze,
          setupState: ze,
          setupContext: null,
          suspense: t,
          suspenseId: t ? t.pendingId : 0,
          asyncDep: null,
          asyncResolved: !1,
          isMounted: !1,
          isUnmounted: !1,
          isDeactivated: !1,
          bc: null,
          c: null,
          bm: null,
          m: null,
          bu: null,
          u: null,
          um: null,
          bum: null,
          da: null,
          a: null,
          rtg: null,
          rtc: null,
          ec: null,
          sp: null
      };
  return r.ctx = {
      _: r
  }, r.root = e ? e.root : r, r.emit = E0.bind(null, r), i.ce && i.ce(r), r
}
let lt = null;
const Lf = () => lt || nt;
let Fr, eo;
{
  const i = Us(),
      e = (t, n) => {
          let s;
          return (s = i[t]) || (s = i[t] = []), s.push(n), r => {
              s.length > 1 ? s.forEach(a => a(r)) : s[0](r)
          }
      };
  Fr = e("__VUE_INSTANCE_SETTERS__", t => lt = t), eo = e("__VUE_SSR_SETTERS__", t => $s = t)
}
const Hs = i => {
      const e = lt;
      return Fr(i), i.scope.on(), () => {
          i.scope.off(), Fr(e)
      }
  },
  tc = () => {
      lt && lt.scope.off(), Fr(null)
  };

function Pf(i) {
  return i.vnode.shapeFlag & 4
}
let $s = !1;

function F0(i, e = !1, t = !1) {
  e && eo(e);
  const {
      props: n,
      children: s
  } = i.vnode, r = Pf(i);
  h0(i, n, r, e), m0(i, s, t);
  const a = r ? A0(i, e) : void 0;
  return e && eo(!1), a
}

function A0(i, e) {
  const t = i.type;
  i.accessCache = Object.create(null), i.proxy = new Proxy(i.ctx, i0);
  const {
      setup: n
  } = t;
  if (n) {
      Gi();
      const s = i.setupContext = n.length > 1 ? z0(i) : null,
          r = Hs(i),
          a = js(n, i, 0, [i.props, s]),
          l = bd(a);
      if (Ki(), r(), (l || i.sp) && !In(i) && sf(i), l) {
          if (a.then(tc, tc), e) return a.then(o => {
              ic(i, o, e)
          }).catch(o => {
              la(o, i, 0)
          });
          i.asyncDep = a
      } else ic(i, a, e)
  } else If(i, e)
}

function ic(i, e, t) {
  _e(e) ? i.type.__ssrInlineRender ? i.ssrRender = e : i.render = e : De(e) && (i.setupState = Hd(e)), If(i, t)
}
let nc;

function If(i, e, t) {
  const n = i.type;
  if (!i.render) {
      if (!e && nc && !n.render) {
          const s = n.template || ru(i).template;
          if (s) {
              const {
                  isCustomElement: r,
                  compilerOptions: a
              } = i.appContext.config, {
                  delimiters: l,
                  compilerOptions: o
              } = n, u = et(et({
                  isCustomElement: r,
                  delimiters: l
              }, a), o);
              n.render = nc(s, u)
          }
      }
      i.render = n.render || Qt
  } {
      const s = Hs(i);
      Gi();
      try {
          n0(i)
      } finally {
          Ki(), s()
      }
  }
}
const V0 = {
  get(i, e) {
      return pt(i, "get", ""), i[e]
  }
};

function z0(i) {
  const e = t => {
      i.exposed = t || {}
  };
  return {
      attrs: new Proxy(i.attrs, V0),
      slots: i.slots,
      emit: i.emit,
      expose: e
  }
}

function ma(i) {
  return i.exposed ? i.exposeProxy || (i.exposeProxy = new Proxy(Hd(aa(i.exposed)), {
      get(e, t) {
          if (t in e) return e[t];
          if (t in ds) return ds[t](i)
      },
      has(e, t) {
          return t in e || t in ds
      }
  })) : i.proxy
}

function W0(i, e = !0) {
  return _e(i) ? i.displayName || i.name : i.name || e && i.__name
}

function U0(i) {
  return _e(i) && "__vccOpts" in i
}
const q = (i, e) => Mg(i, e, $s);

function wt(i, e, t) {
  const n = arguments.length;
  return n === 2 ? De(e) && !ve(e) ? Cs(e) ? z(i, null, [e]) : z(i, e) : z(i, null, e) : (n > 3 ? t = Array.prototype.slice.call(arguments, 2) : n === 3 && Cs(t) && (t = [t]), z(i, e, t))
}
const j0 = "3.5.13";
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let to;
const sc = typeof window < "u" && window.trustedTypes;
if (sc) try {
  to = sc.createPolicy("vue", {
      createHTML: i => i
  })
} catch {}
const Nf = to ? i => to.createHTML(i) : i => i,
  H0 = "http://www.w3.org/2000/svg",
  q0 = "http://www.w3.org/1998/Math/MathML",
  vi = typeof document < "u" ? document : null,
  rc = vi && vi.createElement("template"),
  G0 = {
      insert: (i, e, t) => {
          e.insertBefore(i, t || null)
      },
      remove: i => {
          const e = i.parentNode;
          e && e.removeChild(i)
      },
      createElement: (i, e, t, n) => {
          const s = e === "svg" ? vi.createElementNS(H0, i) : e === "mathml" ? vi.createElementNS(q0, i) : t ? vi.createElement(i, {
              is: t
          }) : vi.createElement(i);
          return i === "select" && n && n.multiple != null && s.setAttribute("multiple", n.multiple), s
      },
      createText: i => vi.createTextNode(i),
      createComment: i => vi.createComment(i),
      setText: (i, e) => {
          i.nodeValue = e
      },
      setElementText: (i, e) => {
          i.textContent = e
      },
      parentNode: i => i.parentNode,
      nextSibling: i => i.nextSibling,
      querySelector: i => vi.querySelector(i),
      setScopeId(i, e) {
          i.setAttribute(e, "")
      },
      insertStaticContent(i, e, t, n, s, r) {
          const a = t ? t.previousSibling : e.lastChild;
          if (s && (s === r || s.nextSibling))
              for (; e.insertBefore(s.cloneNode(!0), t), !(s === r || !(s = s.nextSibling)););
          else {
              rc.innerHTML = Nf(n === "svg" ? `<svg>${i}</svg>` : n === "mathml" ? `<math>${i}</math>` : i);
              const l = rc.content;
              if (n === "svg" || n === "mathml") {
                  const o = l.firstChild;
                  for (; o.firstChild;) l.appendChild(o.firstChild);
                  l.removeChild(o)
              }
              e.insertBefore(l, t)
          }
          return [a ? a.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild]
      }
  },
  Li = "transition",
  ns = "animation",
  zn = Symbol("_vtc"),
  Mf = {
      name: String,
      type: String,
      css: {
          type: Boolean,
          default: !0
      },
      duration: [String, Number, Object],
      enterFromClass: String,
      enterActiveClass: String,
      enterToClass: String,
      appearFromClass: String,
      appearActiveClass: String,
      appearToClass: String,
      leaveFromClass: String,
      leaveActiveClass: String,
      leaveToClass: String
  },
  Rf = et({}, Zd, Mf),
  K0 = i => (i.displayName = "Transition", i.props = Rf, i),
  ga = K0((i, {
      slots: e
  }) => wt(jg, Bf(i), e)),
  Zi = (i, e = []) => {
      ve(i) ? i.forEach(t => t(...e)) : i && i(...e)
  },
  ac = i => i ? ve(i) ? i.some(e => e.length > 1) : i.length > 1 : !1;

function Bf(i) {
  const e = {};
  for (const N in i) N in Mf || (e[N] = i[N]);
  if (i.css === !1) return e;
  const {
      name: t = "v",
      type: n,
      duration: s,
      enterFromClass: r = `${t}-enter-from`,
      enterActiveClass: a = `${t}-enter-active`,
      enterToClass: l = `${t}-enter-to`,
      appearFromClass: o = r,
      appearActiveClass: u = a,
      appearToClass: c = l,
      leaveFromClass: h = `${t}-leave-from`,
      leaveActiveClass: d = `${t}-leave-active`,
      leaveToClass: f = `${t}-leave-to`
  } = i, p = X0(s), g = p && p[0], w = p && p[1], {
      onBeforeEnter: y,
      onEnter: b,
      onEnterCancelled: x,
      onLeave: k,
      onLeaveCancelled: S,
      onBeforeAppear: B = y,
      onAppear: D = b,
      onAppearCancelled: P = x
  } = e, I = (N, O, se, G) => {
      N._enterCancelled = G, Ni(N, O ? c : l), Ni(N, O ? u : a), se && se()
  }, $ = (N, O) => {
      N._isLeaving = !1, Ni(N, h), Ni(N, f), Ni(N, d), O && O()
  }, V = N => (O, se) => {
      const G = N ? D : b,
          te = () => I(O, N, se);
      Zi(G, [O, te]), lc(() => {
          Ni(O, N ? o : r), ui(O, N ? c : l), ac(G) || oc(O, n, g, te)
      })
  };
  return et(e, {
      onBeforeEnter(N) {
          Zi(y, [N]), ui(N, r), ui(N, a)
      },
      onBeforeAppear(N) {
          Zi(B, [N]), ui(N, o), ui(N, u)
      },
      onEnter: V(!1),
      onAppear: V(!0),
      onLeave(N, O) {
          N._isLeaving = !0;
          const se = () => $(N, O);
          ui(N, h), N._enterCancelled ? (ui(N, d), io()) : (io(), ui(N, d)), lc(() => {
              !N._isLeaving || (Ni(N, h), ui(N, f), ac(k) || oc(N, n, w, se))
          }), Zi(k, [N, se])
      },
      onEnterCancelled(N) {
          I(N, !1, void 0, !0), Zi(x, [N])
      },
      onAppearCancelled(N) {
          I(N, !0, void 0, !0), Zi(P, [N])
      },
      onLeaveCancelled(N) {
          $(N), Zi(S, [N])
      }
  })
}

function X0(i) {
  if (i == null) return null;
  if (De(i)) return [Fa(i.enter), Fa(i.leave)];
  {
      const e = Fa(i);
      return [e, e]
  }
}

function Fa(i) {
  return Ym(i)
}

function ui(i, e) {
  e.split(/\s+/).forEach(t => t && i.classList.add(t)), (i[zn] || (i[zn] = new Set)).add(e)
}

function Ni(i, e) {
  e.split(/\s+/).forEach(n => n && i.classList.remove(n));
  const t = i[zn];
  t && (t.delete(e), t.size || (i[zn] = void 0))
}

function lc(i) {
  requestAnimationFrame(() => {
      requestAnimationFrame(i)
  })
}
let J0 = 0;

function oc(i, e, t, n) {
  const s = i._endId = ++J0,
      r = () => {
          s === i._endId && n()
      };
  if (t != null) return setTimeout(r, t);
  const {
      type: a,
      timeout: l,
      propCount: o
  } = Of(i, e);
  if (!a) return n();
  const u = a + "end";
  let c = 0;
  const h = () => {
          i.removeEventListener(u, d), r()
      },
      d = f => {
          f.target === i && ++c >= o && h()
      };
  setTimeout(() => {
      c < o && h()
  }, l + 1), i.addEventListener(u, d)
}

function Of(i, e) {
  const t = window.getComputedStyle(i),
      n = p => (t[p] || "").split(", "),
      s = n(`${Li}Delay`),
      r = n(`${Li}Duration`),
      a = uc(s, r),
      l = n(`${ns}Delay`),
      o = n(`${ns}Duration`),
      u = uc(l, o);
  let c = null,
      h = 0,
      d = 0;
  e === Li ? a > 0 && (c = Li, h = a, d = r.length) : e === ns ? u > 0 && (c = ns, h = u, d = o.length) : (h = Math.max(a, u), c = h > 0 ? a > u ? Li : ns : null, d = c ? c === Li ? r.length : o.length : 0);
  const f = c === Li && /\b(transform|all)(,|$)/.test(n(`${Li}Property`).toString());
  return {
      type: c,
      timeout: h,
      propCount: d,
      hasTransform: f
  }
}

function uc(i, e) {
  for (; i.length < e.length;) i = i.concat(i);
  return Math.max(...e.map((t, n) => cc(t) + cc(i[n])))
}

function cc(i) {
  return i === "auto" ? 0 : Number(i.slice(0, -1).replace(",", ".")) * 1e3
}

function io() {
  return document.body.offsetHeight
}

function Y0(i, e, t) {
  const n = i[zn];
  n && (e = (e ? [e, ...n] : [...n]).join(" ")), e == null ? i.removeAttribute("class") : t ? i.setAttribute("class", e) : i.className = e
}
const Ar = Symbol("_vod"),
  Df = Symbol("_vsh"),
  Ls = {
      beforeMount(i, {
          value: e
      }, {
          transition: t
      }) {
          i[Ar] = i.style.display === "none" ? "" : i.style.display, t && e ? t.beforeEnter(i) : ss(i, e)
      },
      mounted(i, {
          value: e
      }, {
          transition: t
      }) {
          t && e && t.enter(i)
      },
      updated(i, {
          value: e,
          oldValue: t
      }, {
          transition: n
      }) {
          !e != !t && (n ? e ? (n.beforeEnter(i), ss(i, !0), n.enter(i)) : n.leave(i, () => {
              ss(i, !1)
          }) : ss(i, e))
      },
      beforeUnmount(i, {
          value: e
      }) {
          ss(i, e)
      }
  };

function ss(i, e) {
  i.style.display = e ? i[Ar] : "none", i[Df] = !e
}
const Q0 = Symbol(""),
  Z0 = /(^|;)\s*display\s*:/;

function ey(i, e, t) {
  const n = i.style,
      s = Qe(t);
  let r = !1;
  if (t && !s) {
      if (e)
          if (Qe(e))
              for (const a of e.split(";")) {
                  const l = a.slice(0, a.indexOf(":")).trim();
                  t[l] == null && Sr(n, l, "")
              } else
                  for (const a in e) t[a] == null && Sr(n, a, "");
      for (const a in t) a === "display" && (r = !0), Sr(n, a, t[a])
  } else if (s) {
      if (e !== t) {
          const a = n[Q0];
          a && (t += ";" + a), n.cssText = t, r = Z0.test(t)
      }
  } else e && i.removeAttribute("style");
  Ar in i && (i[Ar] = r ? n.display : "", i[Df] && (n.display = "none"))
}
const hc = /\s*!important$/;

function Sr(i, e, t) {
  if (ve(t)) t.forEach(n => Sr(i, e, n));
  else if (t == null && (t = ""), e.startsWith("--")) i.setProperty(e, t);
  else {
      const n = ty(i, e);
      hc.test(t) ? i.setProperty(mn(n), t.replace(hc, ""), "important") : i[n] = t
  }
}
const dc = ["Webkit", "Moz", "ms"],
  Aa = {};

function ty(i, e) {
  const t = Aa[e];
  if (t) return t;
  let n = qt(e);
  if (n !== "filter" && n in i) return Aa[e] = n;
  n = sa(n);
  for (let s = 0; s < dc.length; s++) {
      const r = dc[s] + n;
      if (r in i) return Aa[e] = r
  }
  return e
}
const fc = "http://www.w3.org/1999/xlink";

function pc(i, e, t, n, s, r = ng(e)) {
  n && e.startsWith("xlink:") ? t == null ? i.removeAttributeNS(fc, e.slice(6, e.length)) : i.setAttributeNS(fc, e, t) : t == null || r && !xd(t) ? i.removeAttribute(e) : i.setAttribute(e, r ? "" : ei(t) ? String(t) : t)
}

function mc(i, e, t, n, s) {
  if (e === "innerHTML" || e === "textContent") {
      t != null && (i[e] = e === "innerHTML" ? Nf(t) : t);
      return
  }
  const r = i.tagName;
  if (e === "value" && r !== "PROGRESS" && !r.includes("-")) {
      const l = r === "OPTION" ? i.getAttribute("value") || "" : i.value,
          o = t == null ? i.type === "checkbox" ? "on" : "" : String(t);
      (l !== o || !("_value" in i)) && (i.value = o), t == null && i.removeAttribute(e), i._value = t;
      return
  }
  let a = !1;
  if (t === "" || t == null) {
      const l = typeof i[e];
      l === "boolean" ? t = xd(t) : t == null && l === "string" ? (t = "", a = !0) : l === "number" && (t = 0, a = !0)
  }
  try {
      i[e] = t
  } catch {}
  a && i.removeAttribute(s || e)
}

function Ai(i, e, t, n) {
  i.addEventListener(e, t, n)
}

function iy(i, e, t, n) {
  i.removeEventListener(e, t, n)
}
const gc = Symbol("_vei");

function ny(i, e, t, n, s = null) {
  const r = i[gc] || (i[gc] = {}),
      a = r[e];
  if (n && a) a.value = n;
  else {
      const [l, o] = sy(e);
      if (n) {
          const u = r[e] = ly(n, s);
          Ai(i, l, u, o)
      } else a && (iy(i, l, a, o), r[e] = void 0)
  }
}
const yc = /(?:Once|Passive|Capture)$/;

function sy(i) {
  let e;
  if (yc.test(i)) {
      e = {};
      let n;
      for (; n = i.match(yc);) i = i.slice(0, i.length - n[0].length), e[n[0].toLowerCase()] = !0
  }
  return [i[2] === ":" ? i.slice(3) : mn(i.slice(2)), e]
}
let Va = 0;
const ry = Promise.resolve(),
  ay = () => Va || (ry.then(() => Va = 0), Va = Date.now());

function ly(i, e) {
  const t = n => {
      if (!n._vts) n._vts = Date.now();
      else if (n._vts <= t.attached) return;
      ti(oy(n, t.value), e, 5, [n])
  };
  return t.value = i, t.attached = ay(), t
}

function oy(i, e) {
  if (ve(e)) {
      const t = i.stopImmediatePropagation;
      return i.stopImmediatePropagation = () => {
          t.call(i), i._stopped = !0
      }, e.map(n => s => !s._stopped && n && n(s))
  } else return e
}
const vc = i => i.charCodeAt(0) === 111 && i.charCodeAt(1) === 110 && i.charCodeAt(2) > 96 && i.charCodeAt(2) < 123,
  uy = (i, e, t, n, s, r) => {
      const a = s === "svg";
      e === "class" ? Y0(i, n, a) : e === "style" ? ey(i, t, n) : ta(e) ? jo(e) || ny(i, e, t, n, r) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : cy(i, e, n, a)) ? (mc(i, e, n), !i.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && pc(i, e, n, a, r, e !== "value")) : i._isVueCE && (/[A-Z]/.test(e) || !Qe(n)) ? mc(i, qt(e), n, r, e) : (e === "true-value" ? i._trueValue = n : e === "false-value" && (i._falseValue = n), pc(i, e, n, a))
  };

function cy(i, e, t, n) {
  if (n) return !!(e === "innerHTML" || e === "textContent" || e in i && vc(e) && _e(t));
  if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && i.tagName === "INPUT" || e === "type" && i.tagName === "TEXTAREA") return !1;
  if (e === "width" || e === "height") {
      const s = i.tagName;
      if (s === "IMG" || s === "VIDEO" || s === "CANVAS" || s === "SOURCE") return !1
  }
  return vc(e) && Qe(t) ? !1 : e in i
}
const Ff = new WeakMap,
  Af = new WeakMap,
  Vr = Symbol("_moveCb"),
  bc = Symbol("_enterCb"),
  hy = i => (delete i.props.mode, i),
  dy = hy({
      name: "TransitionGroup",
      props: et({}, Rf, {
          tag: String,
          moveClass: String
      }),
      setup(i, {
          slots: e
      }) {
          const t = Lf(),
              n = Qd();
          let s, r;
          return ha(() => {
              if (!s.length) return;
              const a = i.moveClass || `${i.name||"v"}-move`;
              if (!gy(s[0].el, t.vnode.el, a)) return;
              s.forEach(fy), s.forEach(py);
              const l = s.filter(my);
              io(), l.forEach(o => {
                  const u = o.el,
                      c = u.style;
                  ui(u, a), c.transform = c.webkitTransform = c.transitionDuration = "";
                  const h = u[Vr] = d => {
                      d && d.target !== u || (!d || /transform$/.test(d.propertyName)) && (u.removeEventListener("transitionend", h), u[Vr] = null, Ni(u, a))
                  };
                  u.addEventListener("transitionend", h)
              })
          }), () => {
              const a = Pe(i),
                  l = Bf(a);
              let o = a.tag || F;
              if (s = [], r)
                  for (let u = 0; u < r.length; u++) {
                      const c = r[u];
                      c.el && c.el instanceof Element && (s.push(c), on(c, Ss(c, l, n, t)), Ff.set(c, c.el.getBoundingClientRect()))
                  }
              r = e.default ? iu(e.default()) : [];
              for (let u = 0; u < r.length; u++) {
                  const c = r[u];
                  c.key != null && on(c, Ss(c, l, n, t))
              }
              return z(o, null, r)
          }
      }
  }),
  Vf = dy;

function fy(i) {
  const e = i.el;
  e[Vr] && e[Vr](), e[bc] && e[bc]()
}

function py(i) {
  Af.set(i, i.el.getBoundingClientRect())
}

function my(i) {
  const e = Ff.get(i),
      t = Af.get(i),
      n = e.left - t.left,
      s = e.top - t.top;
  if (n || s) {
      const r = i.el.style;
      return r.transform = r.webkitTransform = `translate(${n}px,${s}px)`, r.transitionDuration = "0s", i
  }
}

function gy(i, e, t) {
  const n = i.cloneNode(),
      s = i[zn];
  s && s.forEach(l => {
      l.split(/\s+/).forEach(o => o && n.classList.remove(o))
  }), t.split(/\s+/).forEach(l => l && n.classList.add(l)), n.style.display = "none";
  const r = e.nodeType === 1 ? e : e.parentNode;
  r.appendChild(n);
  const {
      hasTransform: a
  } = Of(n);
  return r.removeChild(n), a
}
const Wn = i => {
  const e = i.props["onUpdate:modelValue"] || !1;
  return ve(e) ? t => _r(e, t) : e
};

function yy(i) {
  i.target.composing = !0
}

function wc(i) {
  const e = i.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")))
}
const Si = Symbol("_assign"),
  zr = {
      created(i, {
          modifiers: {
              lazy: e,
              trim: t,
              number: n
          }
      }, s) {
          i[Si] = Wn(s);
          const r = n || s.props && s.props.type === "number";
          Ai(i, e ? "change" : "input", a => {
              if (a.target.composing) return;
              let l = i.value;
              t && (l = l.trim()), r && (l = Ir(l)), i[Si](l)
          }), t && Ai(i, "change", () => {
              i.value = i.value.trim()
          }), e || (Ai(i, "compositionstart", yy), Ai(i, "compositionend", wc), Ai(i, "change", wc))
      },
      mounted(i, {
          value: e
      }) {
          i.value = e ?? ""
      },
      beforeUpdate(i, {
          value: e,
          oldValue: t,
          modifiers: {
              lazy: n,
              trim: s,
              number: r
          }
      }, a) {
          if (i[Si] = Wn(a), i.composing) return;
          const l = (r || i.type === "number") && !/^0\d/.test(i.value) ? Ir(i.value) : i.value,
              o = e ?? "";
          l !== o && (document.activeElement === i && i.type !== "range" && (n && e === t || s && i.value.trim() === o) || (i.value = o))
      }
  },
  vy = {
      created(i, {
          value: e
      }, t) {
          i.checked = Vn(e, t.props.value), i[Si] = Wn(t), Ai(i, "change", () => {
              i[Si](Ps(i))
          })
      },
      beforeUpdate(i, {
          value: e,
          oldValue: t
      }, n) {
          i[Si] = Wn(n), e !== t && (i.checked = Vn(e, n.props.value))
      }
  },
  by = {
      deep: !0,
      created(i, {
          value: e,
          modifiers: {
              number: t
          }
      }, n) {
          const s = ia(e);
          Ai(i, "change", () => {
              const r = Array.prototype.filter.call(i.options, a => a.selected).map(a => t ? Ir(Ps(a)) : Ps(a));
              i[Si](i.multiple ? s ? new Set(r) : r : r[0]), i._assigning = !0, pi(() => {
                  i._assigning = !1
              })
          }), i[Si] = Wn(n)
      },
      mounted(i, {
          value: e
      }) {
          kc(i, e)
      },
      beforeUpdate(i, e, t) {
          i[Si] = Wn(t)
      },
      updated(i, {
          value: e
      }) {
          i._assigning || kc(i, e)
      }
  };

function kc(i, e) {
  const t = i.multiple,
      n = ve(e);
  if (!(t && !n && !ia(e))) {
      for (let s = 0, r = i.options.length; s < r; s++) {
          const a = i.options[s],
              l = Ps(a);
          if (t)
              if (n) {
                  const o = typeof l;
                  o === "string" || o === "number" ? a.selected = e.some(u => String(u) === String(l)) : a.selected = rg(e, l) > -1
              } else a.selected = e.has(l);
          else if (Vn(Ps(a), e)) {
              i.selectedIndex !== s && (i.selectedIndex = s);
              return
          }
      }!t && i.selectedIndex !== -1 && (i.selectedIndex = -1)
  }
}

function Ps(i) {
  return "_value" in i ? i._value : i.value
}
const wy = ["ctrl", "shift", "alt", "meta"],
  ky = {
      stop: i => i.stopPropagation(),
      prevent: i => i.preventDefault(),
      self: i => i.target !== i.currentTarget,
      ctrl: i => !i.ctrlKey,
      shift: i => !i.shiftKey,
      alt: i => !i.altKey,
      meta: i => !i.metaKey,
      left: i => "button" in i && i.button !== 0,
      middle: i => "button" in i && i.button !== 1,
      right: i => "button" in i && i.button !== 2,
      exact: (i, e) => wy.some(t => i[`${t}Key`] && !e.includes(t))
  },
  _y = (i, e) => {
      const t = i._withMods || (i._withMods = {}),
          n = e.join(".");
      return t[n] || (t[n] = (s, ...r) => {
          for (let a = 0; a < e.length; a++) {
              const l = ky[e[a]];
              if (l && l(s, e)) return
          }
          return i(s, ...r)
      })
  },
  xy = et({
      patchProp: uy
  }, G0);
let _c;

function Ty() {
  return _c || (_c = v0(xy))
}
const zf = (...i) => {
  const e = Ty().createApp(...i),
      {
          mount: t
      } = e;
  return e.mount = n => {
      const s = Ey(n);
      if (!s) return;
      const r = e._component;
      !_e(r) && !r.render && !r.template && (r.template = s.innerHTML), s.nodeType === 1 && (s.textContent = "");
      const a = t(s, !1, Sy(s));
      return s instanceof Element && (s.removeAttribute("v-cloak"), s.setAttribute("data-v-app", "")), a
  }, e
};

function Sy(i) {
  if (i instanceof SVGElement) return "svg";
  if (typeof MathMLElement == "function" && i instanceof MathMLElement) return "mathml"
}

function Ey(i) {
  return Qe(i) ? document.querySelector(i) : i
}
var Cy = !1;
/*!
* pinia v2.3.0
* (c) 2024 Eduardo San Martin Morote
* @license MIT
*/
let Wf;
const ya = i => Wf = i,
  Uf = Symbol();

function no(i) {
  return i && typeof i == "object" && Object.prototype.toString.call(i) === "[object Object]" && typeof i.toJSON != "function"
}
var ps;
(function(i) {
  i.direct = "direct", i.patchObject = "patch object", i.patchFunction = "patch function"
})(ps || (ps = {}));

function $y() {
  const i = Cd(!0),
      e = i.run(() => M({}));
  let t = [],
      n = [];
  const s = aa({
      install(r) {
          ya(s), s._a = r, r.provide(Uf, s), r.config.globalProperties.$pinia = s, n.forEach(a => t.push(a)), n = []
      },
      use(r) {
          return !this._a && !Cy ? n.push(r) : t.push(r), this
      },
      _p: t,
      _a: null,
      _e: i,
      _s: new Map,
      state: e
  });
  return s
}
const jf = () => {};

function xc(i, e, t, n = jf) {
  i.push(e);
  const s = () => {
      const r = i.indexOf(e);
      r > -1 && (i.splice(r, 1), n())
  };
  return !t && $d() && ag(s), s
}

function bn(i, ...e) {
  i.slice().forEach(t => {
      t(...e)
  })
}
const Ly = i => i(),
  Tc = Symbol(),
  za = Symbol();

function so(i, e) {
  i instanceof Map && e instanceof Map ? e.forEach((t, n) => i.set(n, t)) : i instanceof Set && e instanceof Set && e.forEach(i.add, i);
  for (const t in e) {
      if (!e.hasOwnProperty(t)) continue;
      const n = e[t],
          s = i[t];
      no(s) && no(n) && i.hasOwnProperty(t) && !Je(n) && !Ui(n) ? i[t] = so(s, n) : i[t] = n
  }
  return i
}
const Py = Symbol();

function Iy(i) {
  return !no(i) || !i.hasOwnProperty(Py)
}
const {
  assign: Mi
} = Object;

function Ny(i) {
  return !!(Je(i) && i.effect)
}

function My(i, e, t, n) {
  const {
      state: s,
      actions: r,
      getters: a
  } = e, l = t.state.value[i];
  let o;

  function u() {
      l || (t.state.value[i] = s ? s() : {});
      const c = Lg(t.state.value[i]);
      return Mi(c, r, Object.keys(a || {}).reduce((h, d) => (h[d] = aa(q(() => {
          ya(t);
          const f = t._s.get(i);
          return a[d].call(f, f)
      })), h), {}))
  }
  return o = Hf(i, u, e, t, n, !0), o
}

function Hf(i, e, t = {}, n, s, r) {
  let a;
  const l = Mi({
          actions: {}
      }, t),
      o = {
          deep: !0
      };
  let u, c, h = [],
      d = [],
      f;
  const p = n.state.value[i];
  !r && !p && (n.state.value[i] = {}), M({});
  let g;

  function w(P) {
      let I;
      u = c = !1, typeof P == "function" ? (P(n.state.value[i]), I = {
          type: ps.patchFunction,
          storeId: i,
          events: f
      }) : (so(n.state.value[i], P), I = {
          type: ps.patchObject,
          payload: P,
          storeId: i,
          events: f
      });
      const $ = g = Symbol();
      pi().then(() => {
          g === $ && (u = !0)
      }), c = !0, bn(h, I, n.state.value[i])
  }
  const y = r ? function() {
      const {
          state: I
      } = t, $ = I ? I() : {};
      this.$patch(V => {
          Mi(V, $)
      })
  } : jf;

  function b() {
      a.stop(), h = [], d = [], n._s.delete(i)
  }
  const x = (P, I = "") => {
          if (Tc in P) return P[za] = I, P;
          const $ = function() {
              ya(n);
              const V = Array.from(arguments),
                  N = [],
                  O = [];

              function se(le) {
                  N.push(le)
              }

              function G(le) {
                  O.push(le)
              }
              bn(d, {
                  args: V,
                  name: $[za],
                  store: S,
                  after: se,
                  onError: G
              });
              let te;
              try {
                  te = P.apply(this && this.$id === i ? this : S, V)
              } catch (le) {
                  throw bn(O, le), le
              }
              return te instanceof Promise ? te.then(le => (bn(N, le), le)).catch(le => (bn(O, le), Promise.reject(le))) : (bn(N, te), te)
          };
          return $[Tc] = !0, $[za] = I, $
      },
      k = {
          _p: n,
          $id: i,
          $onAction: xc.bind(null, d),
          $patch: w,
          $reset: y,
          $subscribe(P, I = {}) {
              const $ = xc(h, P, I.detached, () => V()),
                  V = a.run(() => Ie(() => n.state.value[i], N => {
                      (I.flush === "sync" ? c : u) && P({
                          storeId: i,
                          type: ps.direct,
                          events: f
                      }, N)
                  }, Mi({}, o, I)));
              return $
          },
          $dispose: b
      },
      S = Wi(k);
  n._s.set(i, S);
  const D = (n._a && n._a.runWithContext || Ly)(() => n._e.run(() => (a = Cd()).run(() => e({
      action: x
  }))));
  for (const P in D) {
      const I = D[P];
      if (Je(I) && !Ny(I) || Ui(I)) r || (p && Iy(I) && (Je(I) ? I.value = p[P] : so(I, p[P])), n.state.value[i][P] = I);
      else if (typeof I == "function") {
          const $ = x(I, P);
          D[P] = $, l.actions[P] = I
      }
  }
  return Mi(S, D), Mi(Pe(S), D), Object.defineProperty(S, "$state", {
      get: () => n.state.value[i],
      set: P => {
          w(I => {
              Mi(I, P)
          })
      }
  }), n._p.forEach(P => {
      Mi(S, a.run(() => P({
          store: S,
          app: n._a,
          pinia: n,
          options: l
      })))
  }), p && r && t.hydrate && t.hydrate(S.$state, p), u = !0, c = !0, S
} /*! #__NO_SIDE_EFFECTS__ */
function Xi(i, e, t) {
  let n, s;
  const r = typeof e == "function";
  typeof i == "string" ? (n = i, s = r ? t : e) : (s = i, n = i.id);

  function a(l, o) {
      const u = c0();
      return l = l || (u ? zt(Uf, null) : null), l && ya(l), l = Wf, l._s.has(n) || (r ? Hf(n, e, s, l) : My(n, s, l)), l._s.get(n)
  }
  return a.$id = n, a
}

function ou(i) {
  let e = typeof i;
  if (e == "object") {
      if (Array.isArray(i)) return "array";
      if (i === null) return "null"
  }
  return e
}

function Ry(i) {
  return i !== null && typeof i == "object" && !Array.isArray(i)
}
let _i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""),
  va = [];
for (let i = 0; i < _i.length; i++) va[_i[i].charCodeAt(0)] = i;
va["-".charCodeAt(0)] = _i.indexOf("+");
va["_".charCodeAt(0)] = _i.indexOf("/");

function qf(i) {
  let e = i.length * 3 / 4;
  i[i.length - 2] == "=" ? e -= 2 : i[i.length - 1] == "=" && (e -= 1);
  let t = new Uint8Array(e),
      n = 0,
      s = 0,
      r, a = 0;
  for (let l = 0; l < i.length; l++) {
      if (r = va[i.charCodeAt(l)], r === void 0) switch (i[l]) {
          case "=":
              s = 0;
          case `
`:
          case "\r":
          case "	":
          case " ":
              continue;
          default:
              throw Error("invalid base64 string.")
      }
      switch (s) {
          case 0:
              a = r, s = 1;
              break;
          case 1:
              t[n++] = a << 2 | (r & 48) >> 4, a = r, s = 2;
              break;
          case 2:
              t[n++] = (a & 15) << 4 | (r & 60) >> 2, a = r, s = 3;
              break;
          case 3:
              t[n++] = (a & 3) << 6 | r, s = 0;
              break
      }
  }
  if (s == 1) throw Error("invalid base64 string.");
  return t.subarray(0, n)
}

function Gf(i) {
  let e = "",
      t = 0,
      n, s = 0;
  for (let r = 0; r < i.length; r++) switch (n = i[r], t) {
      case 0:
          e += _i[n >> 2], s = (n & 3) << 4, t = 1;
          break;
      case 1:
          e += _i[s | n >> 4], s = (n & 15) << 2, t = 2;
          break;
      case 2:
          e += _i[s | n >> 6], e += _i[n & 63], t = 0;
          break
  }
  return t && (e += _i[s], e += "=", t == 1 && (e += "=")), e
}
var L;
(function(i) {
  i.symbol = Symbol.for("protobuf-ts/unknown"), i.onRead = (t, n, s, r, a) => {
      (e(n) ? n[i.symbol] : n[i.symbol] = []).push({
          no: s,
          wireType: r,
          data: a
      })
  }, i.onWrite = (t, n, s) => {
      for (let {
              no: r,
              wireType: a,
              data: l
          }
          of i.list(n)) s.tag(r, a).raw(l)
  }, i.list = (t, n) => {
      if (e(t)) {
          let s = t[i.symbol];
          return n ? s.filter(r => r.no == n) : s
      }
      return []
  }, i.last = (t, n) => i.list(t, n).slice(-1)[0];
  const e = t => t && Array.isArray(t[i.symbol])
})(L || (L = {}));

function By(i, e) {
  return Object.assign(Object.assign({}, i), e)
}
var v;
(function(i) {
  i[i.Varint = 0] = "Varint", i[i.Bit64 = 1] = "Bit64", i[i.LengthDelimited = 2] = "LengthDelimited", i[i.StartGroup = 3] = "StartGroup", i[i.EndGroup = 4] = "EndGroup", i[i.Bit32 = 5] = "Bit32"
})(v || (v = {}));

function Oy() {
  let i = 0,
      e = 0;
  for (let n = 0; n < 28; n += 7) {
      let s = this.buf[this.pos++];
      if (i |= (s & 127) << n, (s & 128) == 0) return this.assertBounds(), [i, e]
  }
  let t = this.buf[this.pos++];
  if (i |= (t & 15) << 28, e = (t & 112) >> 4, (t & 128) == 0) return this.assertBounds(), [i, e];
  for (let n = 3; n <= 31; n += 7) {
      let s = this.buf[this.pos++];
      if (e |= (s & 127) << n, (s & 128) == 0) return this.assertBounds(), [i, e]
  }
  throw new Error("invalid varint")
}

function Wa(i, e, t) {
  for (let r = 0; r < 28; r = r + 7) {
      const a = i >>> r,
          l = !(a >>> 7 == 0 && e == 0),
          o = (l ? a | 128 : a) & 255;
      if (t.push(o), !l) return
  }
  const n = i >>> 28 & 15 | (e & 7) << 4,
      s = e >> 3 != 0;
  if (t.push((s ? n | 128 : n) & 255), !!s) {
      for (let r = 3; r < 31; r = r + 7) {
          const a = e >>> r,
              l = a >>> 7 != 0,
              o = (l ? a | 128 : a) & 255;
          if (t.push(o), !l) return
      }
      t.push(e >>> 31 & 1)
  }
}
const Er = (1 << 16) * (1 << 16);

function Kf(i) {
  let e = i[0] == "-";
  e && (i = i.slice(1));
  const t = 1e6;
  let n = 0,
      s = 0;

  function r(a, l) {
      const o = Number(i.slice(a, l));
      s *= t, n = n * t + o, n >= Er && (s = s + (n / Er | 0), n = n % Er)
  }
  return r(-24, -18), r(-18, -12), r(-12, -6), r(-6), [e, n, s]
}

function ro(i, e) {
  if (e >>> 0 <= 2097151) return "" + (Er * e + (i >>> 0));
  let t = i & 16777215,
      n = (i >>> 24 | e << 8) >>> 0 & 16777215,
      s = e >> 16 & 65535,
      r = t + n * 6777216 + s * 6710656,
      a = n + s * 8147497,
      l = s * 2,
      o = 1e7;
  r >= o && (a += Math.floor(r / o), r %= o), a >= o && (l += Math.floor(a / o), a %= o);

  function u(c, h) {
      let d = c ? String(c) : "";
      return h ? "0000000".slice(d.length) + d : d
  }
  return u(l, 0) + u(a, l) + u(r, 1)
}

function Sc(i, e) {
  if (i >= 0) {
      for (; i > 127;) e.push(i & 127 | 128), i = i >>> 7;
      e.push(i)
  } else {
      for (let t = 0; t < 9; t++) e.push(i & 127 | 128), i = i >> 7;
      e.push(1)
  }
}

function Dy() {
  let i = this.buf[this.pos++],
      e = i & 127;
  if ((i & 128) == 0) return this.assertBounds(), e;
  if (i = this.buf[this.pos++], e |= (i & 127) << 7, (i & 128) == 0) return this.assertBounds(), e;
  if (i = this.buf[this.pos++], e |= (i & 127) << 14, (i & 128) == 0) return this.assertBounds(), e;
  if (i = this.buf[this.pos++], e |= (i & 127) << 21, (i & 128) == 0) return this.assertBounds(), e;
  i = this.buf[this.pos++], e |= (i & 15) << 28;
  for (let t = 5;
      (i & 128) !== 0 && t < 10; t++) i = this.buf[this.pos++];
  if ((i & 128) != 0) throw new Error("invalid varint");
  return this.assertBounds(), e >>> 0
}
let Ae;

function Fy() {
  const i = new DataView(new ArrayBuffer(8));
  Ae = globalThis.BigInt !== void 0 && typeof i.getBigInt64 == "function" && typeof i.getBigUint64 == "function" && typeof i.setBigInt64 == "function" && typeof i.setBigUint64 == "function" ? {
      MIN: BigInt("-9223372036854775808"),
      MAX: BigInt("9223372036854775807"),
      UMIN: BigInt("0"),
      UMAX: BigInt("18446744073709551615"),
      C: BigInt,
      V: i
  } : void 0
}
Fy();

function Xf(i) {
  if (!i) throw new Error("BigInt unavailable, see https://github.com/timostamm/protobuf-ts/blob/v1.0.8/MANUAL.md#bigint-support")
}
const Jf = /^-?[0-9]+$/,
  Wr = 4294967296,
  sr = 2147483648;
class Yf {
  constructor(e, t) {
      this.lo = e | 0, this.hi = t | 0
  }
  isZero() {
      return this.lo == 0 && this.hi == 0
  }
  toNumber() {
      let e = this.hi * Wr + (this.lo >>> 0);
      if (!Number.isSafeInteger(e)) throw new Error("cannot convert to safe number");
      return e
  }
}
class gt extends Yf {
  static from(e) {
      if (Ae) switch (typeof e) {
          case "string":
              if (e == "0") return this.ZERO;
              if (e == "") throw new Error("string is no integer");
              e = Ae.C(e);
          case "number":
              if (e === 0) return this.ZERO;
              e = Ae.C(e);
          case "bigint":
              if (!e) return this.ZERO;
              if (e < Ae.UMIN) throw new Error("signed value for ulong");
              if (e > Ae.UMAX) throw new Error("ulong too large");
              return Ae.V.setBigUint64(0, e, !0), new gt(Ae.V.getInt32(0, !0), Ae.V.getInt32(4, !0))
      } else switch (typeof e) {
          case "string":
              if (e == "0") return this.ZERO;
              if (e = e.trim(), !Jf.test(e)) throw new Error("string is no integer");
              let [t, n, s] = Kf(e);
              if (t) throw new Error("signed value for ulong");
              return new gt(n, s);
          case "number":
              if (e == 0) return this.ZERO;
              if (!Number.isSafeInteger(e)) throw new Error("number is no integer");
              if (e < 0) throw new Error("signed value for ulong");
              return new gt(e, e / Wr)
      }
      throw new Error("unknown value " + typeof e)
  }
  toString() {
      return Ae ? this.toBigInt().toString() : ro(this.lo, this.hi)
  }
  toBigInt() {
      return Xf(Ae), Ae.V.setInt32(0, this.lo, !0), Ae.V.setInt32(4, this.hi, !0), Ae.V.getBigUint64(0, !0)
  }
}
gt.ZERO = new gt(0, 0);
class He extends Yf {
  static from(e) {
      if (Ae) switch (typeof e) {
          case "string":
              if (e == "0") return this.ZERO;
              if (e == "") throw new Error("string is no integer");
              e = Ae.C(e);
          case "number":
              if (e === 0) return this.ZERO;
              e = Ae.C(e);
          case "bigint":
              if (!e) return this.ZERO;
              if (e < Ae.MIN) throw new Error("signed long too small");
              if (e > Ae.MAX) throw new Error("signed long too large");
              return Ae.V.setBigInt64(0, e, !0), new He(Ae.V.getInt32(0, !0), Ae.V.getInt32(4, !0))
      } else switch (typeof e) {
          case "string":
              if (e == "0") return this.ZERO;
              if (e = e.trim(), !Jf.test(e)) throw new Error("string is no integer");
              let [t, n, s] = Kf(e);
              if (t) {
                  if (s > sr || s == sr && n != 0) throw new Error("signed long too small")
              } else if (s >= sr) throw new Error("signed long too large");
              let r = new He(n, s);
              return t ? r.negate() : r;
          case "number":
              if (e == 0) return this.ZERO;
              if (!Number.isSafeInteger(e)) throw new Error("number is no integer");
              return e > 0 ? new He(e, e / Wr) : new He(-e, -e / Wr).negate()
      }
      throw new Error("unknown value " + typeof e)
  }
  isNegative() {
      return (this.hi & sr) !== 0
  }
  negate() {
      let e = ~this.hi,
          t = this.lo;
      return t ? t = ~t + 1 : e += 1, new He(t, e)
  }
  toString() {
      if (Ae) return this.toBigInt().toString();
      if (this.isNegative()) {
          let e = this.negate();
          return "-" + ro(e.lo, e.hi)
      }
      return ro(this.lo, this.hi)
  }
  toBigInt() {
      return Xf(Ae), Ae.V.setInt32(0, this.lo, !0), Ae.V.setInt32(4, this.hi, !0), Ae.V.getBigInt64(0, !0)
  }
}
He.ZERO = new He(0, 0);
const Ec = {
  readUnknownField: !0,
  readerFactory: i => new Vy(i)
};

function Ay(i) {
  return i ? Object.assign(Object.assign({}, Ec), i) : Ec
}
class Vy {
  constructor(e, t) {
      this.varint64 = Oy, this.uint32 = Dy, this.buf = e, this.len = e.length, this.pos = 0, this.view = new DataView(e.buffer, e.byteOffset, e.byteLength), this.textDecoder = t ?? new TextDecoder("utf-8", {
          fatal: !0,
          ignoreBOM: !0
      })
  }
  tag() {
      let e = this.uint32(),
          t = e >>> 3,
          n = e & 7;
      if (t <= 0 || n < 0 || n > 5) throw new Error("illegal tag: field no " + t + " wire type " + n);
      return [t, n]
  }
  skip(e) {
      let t = this.pos;
      switch (e) {
          case v.Varint:
              for (; this.buf[this.pos++] & 128;);
              break;
          case v.Bit64:
              this.pos += 4;
          case v.Bit32:
              this.pos += 4;
              break;
          case v.LengthDelimited:
              let n = this.uint32();
              this.pos += n;
              break;
          case v.StartGroup:
              let s;
              for (;
                  (s = this.tag()[1]) !== v.EndGroup;) this.skip(s);
              break;
          default:
              throw new Error("cant skip wire type " + e)
      }
      return this.assertBounds(), this.buf.subarray(t, this.pos)
  }
  assertBounds() {
      if (this.pos > this.len) throw new RangeError("premature EOF")
  }
  int32() {
      return this.uint32() | 0
  }
  sint32() {
      let e = this.uint32();
      return e >>> 1 ^ -(e & 1)
  }
  int64() {
      return new He(...this.varint64())
  }
  uint64() {
      return new gt(...this.varint64())
  }
  sint64() {
      let [e, t] = this.varint64(), n = -(e & 1);
      return e = (e >>> 1 | (t & 1) << 31) ^ n, t = t >>> 1 ^ n, new He(e, t)
  }
  bool() {
      let [e, t] = this.varint64();
      return e !== 0 || t !== 0
  }
  fixed32() {
      return this.view.getUint32((this.pos += 4) - 4, !0)
  }
  sfixed32() {
      return this.view.getInt32((this.pos += 4) - 4, !0)
  }
  fixed64() {
      return new gt(this.sfixed32(), this.sfixed32())
  }
  sfixed64() {
      return new He(this.sfixed32(), this.sfixed32())
  }
  float() {
      return this.view.getFloat32((this.pos += 4) - 4, !0)
  }
  double() {
      return this.view.getFloat64((this.pos += 8) - 8, !0)
  }
  bytes() {
      let e = this.uint32(),
          t = this.pos;
      return this.pos += e, this.assertBounds(), this.buf.subarray(t, t + e)
  }
  string() {
      return this.textDecoder.decode(this.bytes())
  }
}

function Se(i, e) {
  if (!i) throw new Error(e)
}

function zy(i, e) {
  throw new Error(e ?? "Unexpected object: " + i)
}
const Wy = 34028234663852886e22,
  Uy = -34028234663852886e22,
  jy = 4294967295,
  Hy = 2147483647,
  qy = -2147483648;

function ms(i) {
  if (typeof i != "number") throw new Error("invalid int 32: " + typeof i);
  if (!Number.isInteger(i) || i > Hy || i < qy) throw new Error("invalid int 32: " + i)
}

function Ur(i) {
  if (typeof i != "number") throw new Error("invalid uint 32: " + typeof i);
  if (!Number.isInteger(i) || i > jy || i < 0) throw new Error("invalid uint 32: " + i)
}

function uu(i) {
  if (typeof i != "number") throw new Error("invalid float 32: " + typeof i);
  if (!!Number.isFinite(i) && (i > Wy || i < Uy)) throw new Error("invalid float 32: " + i)
}
const Cc = {
  writeUnknownFields: !0,
  writerFactory: () => new Ky
};

function Gy(i) {
  return i ? Object.assign(Object.assign({}, Cc), i) : Cc
}
class Ky {
  constructor(e) {
      this.stack = [], this.textEncoder = e ?? new TextEncoder, this.chunks = [], this.buf = []
  }
  finish() {
      this.chunks.push(new Uint8Array(this.buf));
      let e = 0;
      for (let s = 0; s < this.chunks.length; s++) e += this.chunks[s].length;
      let t = new Uint8Array(e),
          n = 0;
      for (let s = 0; s < this.chunks.length; s++) t.set(this.chunks[s], n), n += this.chunks[s].length;
      return this.chunks = [], t
  }
  fork() {
      return this.stack.push({
          chunks: this.chunks,
          buf: this.buf
      }), this.chunks = [], this.buf = [], this
  }
  join() {
      let e = this.finish(),
          t = this.stack.pop();
      if (!t) throw new Error("invalid state, fork stack empty");
      return this.chunks = t.chunks, this.buf = t.buf, this.uint32(e.byteLength), this.raw(e)
  }
  tag(e, t) {
      return this.uint32((e << 3 | t) >>> 0)
  }
  raw(e) {
      return this.buf.length && (this.chunks.push(new Uint8Array(this.buf)), this.buf = []), this.chunks.push(e), this
  }
  uint32(e) {
      for (Ur(e); e > 127;) this.buf.push(e & 127 | 128), e = e >>> 7;
      return this.buf.push(e), this
  }
  int32(e) {
      return ms(e), Sc(e, this.buf), this
  }
  bool(e) {
      return this.buf.push(e ? 1 : 0), this
  }
  bytes(e) {
      return this.uint32(e.byteLength), this.raw(e)
  }
  string(e) {
      let t = this.textEncoder.encode(e);
      return this.uint32(t.byteLength), this.raw(t)
  }
  float(e) {
      uu(e);
      let t = new Uint8Array(4);
      return new DataView(t.buffer).setFloat32(0, e, !0), this.raw(t)
  }
  double(e) {
      let t = new Uint8Array(8);
      return new DataView(t.buffer).setFloat64(0, e, !0), this.raw(t)
  }
  fixed32(e) {
      Ur(e);
      let t = new Uint8Array(4);
      return new DataView(t.buffer).setUint32(0, e, !0), this.raw(t)
  }
  sfixed32(e) {
      ms(e);
      let t = new Uint8Array(4);
      return new DataView(t.buffer).setInt32(0, e, !0), this.raw(t)
  }
  sint32(e) {
      return ms(e), e = (e << 1 ^ e >> 31) >>> 0, Sc(e, this.buf), this
  }
  sfixed64(e) {
      let t = new Uint8Array(8),
          n = new DataView(t.buffer),
          s = He.from(e);
      return n.setInt32(0, s.lo, !0), n.setInt32(4, s.hi, !0), this.raw(t)
  }
  fixed64(e) {
      let t = new Uint8Array(8),
          n = new DataView(t.buffer),
          s = gt.from(e);
      return n.setInt32(0, s.lo, !0), n.setInt32(4, s.hi, !0), this.raw(t)
  }
  int64(e) {
      let t = He.from(e);
      return Wa(t.lo, t.hi, this.buf), this
  }
  sint64(e) {
      let t = He.from(e),
          n = t.hi >> 31,
          s = t.lo << 1 ^ n,
          r = (t.hi << 1 | t.lo >>> 31) ^ n;
      return Wa(s, r, this.buf), this
  }
  uint64(e) {
      let t = gt.from(e);
      return Wa(t.lo, t.hi, this.buf), this
  }
}
const $c = {
      emitDefaultValues: !1,
      enumAsInteger: !1,
      useProtoFieldName: !1,
      prettySpaces: 0
  },
  Lc = {
      ignoreUnknownFields: !1
  };

function Xy(i) {
  return i ? Object.assign(Object.assign({}, Lc), i) : Lc
}

function Jy(i) {
  return i ? Object.assign(Object.assign({}, $c), i) : $c
}

function Yy(i, e) {
  var t, n;
  let s = Object.assign(Object.assign({}, i), e);
  return s.typeRegistry = [...(t = i?.typeRegistry) !== null && t !== void 0 ? t : [], ...(n = e?.typeRegistry) !== null && n !== void 0 ? n : []], s
}
const J = Symbol.for("protobuf-ts/message-type");

function ao(i) {
  let e = !1;
  const t = [];
  for (let n = 0; n < i.length; n++) {
      let s = i.charAt(n);
      s == "_" ? e = !0 : /\d/.test(s) ? (t.push(s), e = !0) : e ? (t.push(s.toUpperCase()), e = !1) : n == 0 ? t.push(s.toLowerCase()) : t.push(s)
  }
  return t.join("")
}
var W;
(function(i) {
  i[i.DOUBLE = 1] = "DOUBLE", i[i.FLOAT = 2] = "FLOAT", i[i.INT64 = 3] = "INT64", i[i.UINT64 = 4] = "UINT64", i[i.INT32 = 5] = "INT32", i[i.FIXED64 = 6] = "FIXED64", i[i.FIXED32 = 7] = "FIXED32", i[i.BOOL = 8] = "BOOL", i[i.STRING = 9] = "STRING", i[i.BYTES = 12] = "BYTES", i[i.UINT32 = 13] = "UINT32", i[i.SFIXED32 = 15] = "SFIXED32", i[i.SFIXED64 = 16] = "SFIXED64", i[i.SINT32 = 17] = "SINT32", i[i.SINT64 = 18] = "SINT64"
})(W || (W = {}));
var Wt;
(function(i) {
  i[i.BIGINT = 0] = "BIGINT", i[i.STRING = 1] = "STRING", i[i.NUMBER = 2] = "NUMBER"
})(Wt || (Wt = {}));
var jr;
(function(i) {
  i[i.NO = 0] = "NO", i[i.PACKED = 1] = "PACKED", i[i.UNPACKED = 2] = "UNPACKED"
})(jr || (jr = {}));

function Qy(i) {
  var e, t, n, s;
  return i.localName = (e = i.localName) !== null && e !== void 0 ? e : ao(i.name), i.jsonName = (t = i.jsonName) !== null && t !== void 0 ? t : ao(i.name), i.repeat = (n = i.repeat) !== null && n !== void 0 ? n : jr.NO, i.opt = (s = i.opt) !== null && s !== void 0 ? s : i.repeat || i.oneof ? !1 : i.kind == "message", i
}

function Zy(i) {
  if (typeof i != "object" || i === null || !i.hasOwnProperty("oneofKind")) return !1;
  switch (typeof i.oneofKind) {
      case "string":
          return i[i.oneofKind] === void 0 ? !1 : Object.keys(i).length == 2;
      case "undefined":
          return Object.keys(i).length == 1;
      default:
          return !1
  }
}
class ev {
  constructor(e) {
      var t;
      this.fields = (t = e.fields) !== null && t !== void 0 ? t : []
  }
  prepare() {
      if (this.data) return;
      const e = [],
          t = [],
          n = [];
      for (let s of this.fields)
          if (s.oneof) n.includes(s.oneof) || (n.push(s.oneof), e.push(s.oneof), t.push(s.oneof));
          else switch (t.push(s.localName), s.kind) {
              case "scalar":
              case "enum":
                  (!s.opt || s.repeat) && e.push(s.localName);
                  break;
              case "message":
                  s.repeat && e.push(s.localName);
                  break;
              case "map":
                  e.push(s.localName);
                  break
          }
      this.data = {
          req: e,
          known: t,
          oneofs: Object.values(n)
      }
  }
  is(e, t, n = !1) {
      if (t < 0) return !0;
      if (e == null || typeof e != "object") return !1;
      this.prepare();
      let s = Object.keys(e),
          r = this.data;
      if (s.length < r.req.length || r.req.some(a => !s.includes(a)) || !n && s.some(a => !r.known.includes(a))) return !1;
      if (t < 1) return !0;
      for (const a of r.oneofs) {
          const l = e[a];
          if (!Zy(l)) return !1;
          if (l.oneofKind === void 0) continue;
          const o = this.fields.find(u => u.localName === l.oneofKind);
          if (!o || !this.field(l[l.oneofKind], o, n, t)) return !1
      }
      for (const a of this.fields)
          if (a.oneof === void 0 && !this.field(e[a.localName], a, n, t)) return !1;
      return !0
  }
  field(e, t, n, s) {
      let r = t.repeat;
      switch (t.kind) {
          case "scalar":
              return e === void 0 ? t.opt : r ? this.scalars(e, t.T, s, t.L) : this.scalar(e, t.T, t.L);
          case "enum":
              return e === void 0 ? t.opt : r ? this.scalars(e, W.INT32, s) : this.scalar(e, W.INT32);
          case "message":
              return e === void 0 ? !0 : r ? this.messages(e, t.T(), n, s) : this.message(e, t.T(), n, s);
          case "map":
              if (typeof e != "object" || e === null) return !1;
              if (s < 2) return !0;
              if (!this.mapKeys(e, t.K, s)) return !1;
              switch (t.V.kind) {
                  case "scalar":
                      return this.scalars(Object.values(e), t.V.T, s, t.V.L);
                  case "enum":
                      return this.scalars(Object.values(e), W.INT32, s);
                  case "message":
                      return this.messages(Object.values(e), t.V.T(), n, s)
              }
              break
      }
      return !0
  }
  message(e, t, n, s) {
      return n ? t.isAssignable(e, s) : t.is(e, s)
  }
  messages(e, t, n, s) {
      if (!Array.isArray(e)) return !1;
      if (s < 2) return !0;
      if (n) {
          for (let r = 0; r < e.length && r < s; r++)
              if (!t.isAssignable(e[r], s - 1)) return !1
      } else
          for (let r = 0; r < e.length && r < s; r++)
              if (!t.is(e[r], s - 1)) return !1;
      return !0
  }
  scalar(e, t, n) {
      let s = typeof e;
      switch (t) {
          case W.UINT64:
          case W.FIXED64:
          case W.INT64:
          case W.SFIXED64:
          case W.SINT64:
              switch (n) {
                  case Wt.BIGINT:
                      return s == "bigint";
                  case Wt.NUMBER:
                      return s == "number" && !isNaN(e);
                  default:
                      return s == "string"
              }
          case W.BOOL:
              return s == "boolean";
          case W.STRING:
              return s == "string";
          case W.BYTES:
              return e instanceof Uint8Array;
          case W.DOUBLE:
          case W.FLOAT:
              return s == "number" && !isNaN(e);
          default:
              return s == "number" && Number.isInteger(e)
      }
  }
  scalars(e, t, n, s) {
      if (!Array.isArray(e)) return !1;
      if (n < 2) return !0;
      if (Array.isArray(e)) {
          for (let r = 0; r < e.length && r < n; r++)
              if (!this.scalar(e[r], t, s)) return !1
      }
      return !0
  }
  mapKeys(e, t, n) {
      let s = Object.keys(e);
      switch (t) {
          case W.INT32:
          case W.FIXED32:
          case W.SFIXED32:
          case W.SINT32:
          case W.UINT32:
              return this.scalars(s.slice(0, n).map(r => parseInt(r)), t, n);
          case W.BOOL:
              return this.scalars(s.slice(0, n).map(r => r == "true" ? !0 : r == "false" ? !1 : r), t, n);
          default:
              return this.scalars(s, t, n, Wt.STRING)
      }
  }
}

function Jt(i, e) {
  switch (e) {
      case Wt.BIGINT:
          return i.toBigInt();
      case Wt.NUMBER:
          return i.toNumber();
      default:
          return i.toString()
  }
}
class tv {
  constructor(e) {
      this.info = e
  }
  prepare() {
      var e;
      if (this.fMap === void 0) {
          this.fMap = {};
          const t = (e = this.info.fields) !== null && e !== void 0 ? e : [];
          for (const n of t) this.fMap[n.name] = n, this.fMap[n.jsonName] = n, this.fMap[n.localName] = n
      }
  }
  assert(e, t, n) {
      if (!e) {
          let s = ou(n);
          throw (s == "number" || s == "boolean") && (s = n.toString()), new Error(`Cannot parse JSON ${s} for ${this.info.typeName}#${t}`)
      }
  }
  read(e, t, n) {
      this.prepare();
      const s = [];
      for (const [r, a] of Object.entries(e)) {
          const l = this.fMap[r];
          if (!l) {
              if (!n.ignoreUnknownFields) throw new Error(`Found unknown field while reading ${this.info.typeName} from JSON format. JSON key: ${r}`);
              continue
          }
          const o = l.localName;
          let u;
          if (l.oneof) {
              if (a === null && (l.kind !== "enum" || l.T()[0] !== "google.protobuf.NullValue")) continue;
              if (s.includes(l.oneof)) throw new Error(`Multiple members of the oneof group "${l.oneof}" of ${this.info.typeName} are present in JSON.`);
              s.push(l.oneof), u = t[l.oneof] = {
                  oneofKind: o
              }
          } else u = t;
          if (l.kind == "map") {
              if (a === null) continue;
              this.assert(Ry(a), l.name, a);
              const c = u[o];
              for (const [h, d] of Object.entries(a)) {
                  this.assert(d !== null, l.name + " map value", null);
                  let f;
                  switch (l.V.kind) {
                      case "message":
                          f = l.V.T().internalJsonRead(d, n);
                          break;
                      case "enum":
                          if (f = this.enum(l.V.T(), d, l.name, n.ignoreUnknownFields), f === !1) continue;
                          break;
                      case "scalar":
                          f = this.scalar(d, l.V.T, l.V.L, l.name);
                          break
                  }
                  this.assert(f !== void 0, l.name + " map value", d);
                  let p = h;
                  l.K == W.BOOL && (p = p == "true" ? !0 : p == "false" ? !1 : p), p = this.scalar(p, l.K, Wt.STRING, l.name).toString(), c[p] = f
              }
          } else if (l.repeat) {
              if (a === null) continue;
              this.assert(Array.isArray(a), l.name, a);
              const c = u[o];
              for (const h of a) {
                  this.assert(h !== null, l.name, null);
                  let d;
                  switch (l.kind) {
                      case "message":
                          d = l.T().internalJsonRead(h, n);
                          break;
                      case "enum":
                          if (d = this.enum(l.T(), h, l.name, n.ignoreUnknownFields), d === !1) continue;
                          break;
                      case "scalar":
                          d = this.scalar(h, l.T, l.L, l.name);
                          break
                  }
                  this.assert(d !== void 0, l.name, a), c.push(d)
              }
          } else switch (l.kind) {
              case "message":
                  if (a === null && l.T().typeName != "google.protobuf.Value") {
                      this.assert(l.oneof === void 0, l.name + " (oneof member)", null);
                      continue
                  }
                  u[o] = l.T().internalJsonRead(a, n, u[o]);
                  break;
              case "enum":
                  let c = this.enum(l.T(), a, l.name, n.ignoreUnknownFields);
                  if (c === !1) continue;
                  u[o] = c;
                  break;
              case "scalar":
                  u[o] = this.scalar(a, l.T, l.L, l.name);
                  break
          }
      }
  }
  enum(e, t, n, s) {
      if (e[0] == "google.protobuf.NullValue" && Se(t === null || t === "NULL_VALUE", `Unable to parse field ${this.info.typeName}#${n}, enum ${e[0]} only accepts null.`), t === null) return 0;
      switch (typeof t) {
          case "number":
              return Se(Number.isInteger(t), `Unable to parse field ${this.info.typeName}#${n}, enum can only be integral number, got ${t}.`), t;
          case "string":
              let r = t;
              e[2] && t.substring(0, e[2].length) === e[2] && (r = t.substring(e[2].length));
              let a = e[1][r];
              return typeof a > "u" && s ? !1 : (Se(typeof a == "number", `Unable to parse field ${this.info.typeName}#${n}, enum ${e[0]} has no value for "${t}".`), a)
      }
      Se(!1, `Unable to parse field ${this.info.typeName}#${n}, cannot parse enum value from ${typeof t}".`)
  }
  scalar(e, t, n, s) {
      let r;
      try {
          switch (t) {
              case W.DOUBLE:
              case W.FLOAT:
                  if (e === null) return 0;
                  if (e === "NaN") return Number.NaN;
                  if (e === "Infinity") return Number.POSITIVE_INFINITY;
                  if (e === "-Infinity") return Number.NEGATIVE_INFINITY;
                  if (e === "") {
                      r = "empty string";
                      break
                  }
                  if (typeof e == "string" && e.trim().length !== e.length) {
                      r = "extra whitespace";
                      break
                  }
                  if (typeof e != "string" && typeof e != "number") break;
                  let a = Number(e);
                  if (Number.isNaN(a)) {
                      r = "not a number";
                      break
                  }
                  if (!Number.isFinite(a)) {
                      r = "too large or small";
                      break
                  }
                  return t == W.FLOAT && uu(a), a;
              case W.INT32:
              case W.FIXED32:
              case W.SFIXED32:
              case W.SINT32:
              case W.UINT32:
                  if (e === null) return 0;
                  let l;
                  if (typeof e == "number" ? l = e : e === "" ? r = "empty string" : typeof e == "string" && (e.trim().length !== e.length ? r = "extra whitespace" : l = Number(e)), l === void 0) break;
                  return t == W.UINT32 ? Ur(l) : ms(l), l;
              case W.INT64:
              case W.SFIXED64:
              case W.SINT64:
                  if (e === null) return Jt(He.ZERO, n);
                  if (typeof e != "number" && typeof e != "string") break;
                  return Jt(He.from(e), n);
              case W.FIXED64:
              case W.UINT64:
                  if (e === null) return Jt(gt.ZERO, n);
                  if (typeof e != "number" && typeof e != "string") break;
                  return Jt(gt.from(e), n);
              case W.BOOL:
                  if (e === null) return !1;
                  if (typeof e != "boolean") break;
                  return e;
              case W.STRING:
                  if (e === null) return "";
                  if (typeof e != "string") {
                      r = "extra whitespace";
                      break
                  }
                  try {
                      encodeURIComponent(e)
                  } catch (o) {
                      o = "invalid UTF8";
                      break
                  }
                  return e;
              case W.BYTES:
                  if (e === null || e === "") return new Uint8Array(0);
                  if (typeof e != "string") break;
                  return qf(e)
          }
      } catch (a) {
          r = a.message
      }
      this.assert(!1, s + (r ? " - " + r : ""), e)
  }
}
class iv {
  constructor(e) {
      var t;
      this.fields = (t = e.fields) !== null && t !== void 0 ? t : []
  }
  write(e, t) {
      const n = {},
          s = e;
      for (const r of this.fields) {
          if (!r.oneof) {
              let u = this.field(r, s[r.localName], t);
              u !== void 0 && (n[t.useProtoFieldName ? r.name : r.jsonName] = u);
              continue
          }
          const a = s[r.oneof];
          if (a.oneofKind !== r.localName) continue;
          const l = r.kind == "scalar" || r.kind == "enum" ? Object.assign(Object.assign({}, t), {
              emitDefaultValues: !0
          }) : t;
          let o = this.field(r, a[r.localName], l);
          Se(o !== void 0), n[t.useProtoFieldName ? r.name : r.jsonName] = o
      }
      return n
  }
  field(e, t, n) {
      let s;
      if (e.kind == "map") {
          Se(typeof t == "object" && t !== null);
          const r = {};
          switch (e.V.kind) {
              case "scalar":
                  for (const [o, u] of Object.entries(t)) {
                      const c = this.scalar(e.V.T, u, e.name, !1, !0);
                      Se(c !== void 0), r[o.toString()] = c
                  }
                  break;
              case "message":
                  const a = e.V.T();
                  for (const [o, u] of Object.entries(t)) {
                      const c = this.message(a, u, e.name, n);
                      Se(c !== void 0), r[o.toString()] = c
                  }
                  break;
              case "enum":
                  const l = e.V.T();
                  for (const [o, u] of Object.entries(t)) {
                      Se(u === void 0 || typeof u == "number");
                      const c = this.enum(l, u, e.name, !1, !0, n.enumAsInteger);
                      Se(c !== void 0), r[o.toString()] = c
                  }
                  break
          }(n.emitDefaultValues || Object.keys(r).length > 0) && (s = r)
      } else if (e.repeat) {
          Se(Array.isArray(t));
          const r = [];
          switch (e.kind) {
              case "scalar":
                  for (let o = 0; o < t.length; o++) {
                      const u = this.scalar(e.T, t[o], e.name, e.opt, !0);
                      Se(u !== void 0), r.push(u)
                  }
                  break;
              case "enum":
                  const a = e.T();
                  for (let o = 0; o < t.length; o++) {
                      Se(t[o] === void 0 || typeof t[o] == "number");
                      const u = this.enum(a, t[o], e.name, e.opt, !0, n.enumAsInteger);
                      Se(u !== void 0), r.push(u)
                  }
                  break;
              case "message":
                  const l = e.T();
                  for (let o = 0; o < t.length; o++) {
                      const u = this.message(l, t[o], e.name, n);
                      Se(u !== void 0), r.push(u)
                  }
                  break
          }(n.emitDefaultValues || r.length > 0 || n.emitDefaultValues) && (s = r)
      } else switch (e.kind) {
          case "scalar":
              s = this.scalar(e.T, t, e.name, e.opt, n.emitDefaultValues);
              break;
          case "enum":
              s = this.enum(e.T(), t, e.name, e.opt, n.emitDefaultValues, n.enumAsInteger);
              break;
          case "message":
              s = this.message(e.T(), t, e.name, n);
              break
      }
      return s
  }
  enum(e, t, n, s, r, a) {
      if (e[0] == "google.protobuf.NullValue") return !r && !s ? void 0 : null;
      if (t === void 0) {
          Se(s);
          return
      }
      if (!(t === 0 && !r && !s)) return Se(typeof t == "number"), Se(Number.isInteger(t)), a || !e[1].hasOwnProperty(t) ? t : e[2] ? e[2] + e[1][t] : e[1][t]
  }
  message(e, t, n, s) {
      return t === void 0 ? s.emitDefaultValues ? null : void 0 : e.internalJsonWrite(t, s)
  }
  scalar(e, t, n, s, r) {
      if (t === void 0) {
          Se(s);
          return
      }
      const a = r || s;
      switch (e) {
          case W.INT32:
          case W.SFIXED32:
          case W.SINT32:
              return t === 0 ? a ? 0 : void 0 : (ms(t), t);
          case W.FIXED32:
          case W.UINT32:
              return t === 0 ? a ? 0 : void 0 : (Ur(t), t);
          case W.FLOAT:
              uu(t);
          case W.DOUBLE:
              return t === 0 ? a ? 0 : void 0 : (Se(typeof t == "number"), Number.isNaN(t) ? "NaN" : t === Number.POSITIVE_INFINITY ? "Infinity" : t === Number.NEGATIVE_INFINITY ? "-Infinity" : t);
          case W.STRING:
              return t === "" ? a ? "" : void 0 : (Se(typeof t == "string"), t);
          case W.BOOL:
              return t === !1 ? a ? !1 : void 0 : (Se(typeof t == "boolean"), t);
          case W.UINT64:
          case W.FIXED64:
              Se(typeof t == "number" || typeof t == "string" || typeof t == "bigint");
              let l = gt.from(t);
              return l.isZero() && !a ? void 0 : l.toString();
          case W.INT64:
          case W.SFIXED64:
          case W.SINT64:
              Se(typeof t == "number" || typeof t == "string" || typeof t == "bigint");
              let o = He.from(t);
              return o.isZero() && !a ? void 0 : o.toString();
          case W.BYTES:
              return Se(t instanceof Uint8Array), t.byteLength ? Gf(t) : a ? "" : void 0
      }
  }
}

function lo(i, e = Wt.STRING) {
  switch (i) {
      case W.BOOL:
          return !1;
      case W.UINT64:
      case W.FIXED64:
          return Jt(gt.ZERO, e);
      case W.INT64:
      case W.SFIXED64:
      case W.SINT64:
          return Jt(He.ZERO, e);
      case W.DOUBLE:
      case W.FLOAT:
          return 0;
      case W.BYTES:
          return new Uint8Array(0);
      case W.STRING:
          return "";
      default:
          return 0
  }
}
class nv {
  constructor(e) {
      this.info = e
  }
  prepare() {
      var e;
      if (!this.fieldNoToField) {
          const t = (e = this.info.fields) !== null && e !== void 0 ? e : [];
          this.fieldNoToField = new Map(t.map(n => [n.no, n]))
      }
  }
  read(e, t, n, s) {
      this.prepare();
      const r = s === void 0 ? e.len : e.pos + s;
      for (; e.pos < r;) {
          const [a, l] = e.tag(), o = this.fieldNoToField.get(a);
          if (!o) {
              let d = n.readUnknownField;
              if (d == "throw") throw new Error(`Unknown field ${a} (wire type ${l}) for ${this.info.typeName}`);
              let f = e.skip(l);
              d !== !1 && (d === !0 ? L.onRead : d)(this.info.typeName, t, a, l, f);
              continue
          }
          let u = t,
              c = o.repeat,
              h = o.localName;
          switch (o.oneof && (u = u[o.oneof], u.oneofKind !== h && (u = t[o.oneof] = {
                  oneofKind: h
              })), o.kind) {
              case "scalar":
              case "enum":
                  let d = o.kind == "enum" ? W.INT32 : o.T,
                      f = o.kind == "scalar" ? o.L : void 0;
                  if (c) {
                      let w = u[h];
                      if (l == v.LengthDelimited && d != W.STRING && d != W.BYTES) {
                          let y = e.uint32() + e.pos;
                          for (; e.pos < y;) w.push(this.scalar(e, d, f))
                      } else w.push(this.scalar(e, d, f))
                  } else u[h] = this.scalar(e, d, f);
                  break;
              case "message":
                  if (c) {
                      let w = u[h],
                          y = o.T().internalBinaryRead(e, e.uint32(), n);
                      w.push(y)
                  } else u[h] = o.T().internalBinaryRead(e, e.uint32(), n, u[h]);
                  break;
              case "map":
                  let [p, g] = this.mapEntry(o, e, n);
                  u[h][p] = g;
                  break
          }
      }
  }
  mapEntry(e, t, n) {
      let s = t.uint32(),
          r = t.pos + s,
          a, l;
      for (; t.pos < r;) {
          let [o, u] = t.tag();
          switch (o) {
              case 1:
                  e.K == W.BOOL ? a = t.bool().toString() : a = this.scalar(t, e.K, Wt.STRING);
                  break;
              case 2:
                  switch (e.V.kind) {
                      case "scalar":
                          l = this.scalar(t, e.V.T, e.V.L);
                          break;
                      case "enum":
                          l = t.int32();
                          break;
                      case "message":
                          l = e.V.T().internalBinaryRead(t, t.uint32(), n);
                          break
                  }
                  break;
              default:
                  throw new Error(`Unknown field ${o} (wire type ${u}) in map entry for ${this.info.typeName}#${e.name}`)
          }
      }
      if (a === void 0) {
          let o = lo(e.K);
          a = e.K == W.BOOL ? o.toString() : o
      }
      if (l === void 0) switch (e.V.kind) {
          case "scalar":
              l = lo(e.V.T, e.V.L);
              break;
          case "enum":
              l = 0;
              break;
          case "message":
              l = e.V.T().create();
              break
      }
      return [a, l]
  }
  scalar(e, t, n) {
      switch (t) {
          case W.INT32:
              return e.int32();
          case W.STRING:
              return e.string();
          case W.BOOL:
              return e.bool();
          case W.DOUBLE:
              return e.double();
          case W.FLOAT:
              return e.float();
          case W.INT64:
              return Jt(e.int64(), n);
          case W.UINT64:
              return Jt(e.uint64(), n);
          case W.FIXED64:
              return Jt(e.fixed64(), n);
          case W.FIXED32:
              return e.fixed32();
          case W.BYTES:
              return e.bytes();
          case W.UINT32:
              return e.uint32();
          case W.SFIXED32:
              return e.sfixed32();
          case W.SFIXED64:
              return Jt(e.sfixed64(), n);
          case W.SINT32:
              return e.sint32();
          case W.SINT64:
              return Jt(e.sint64(), n)
      }
  }
}
class sv {
  constructor(e) {
      this.info = e
  }
  prepare() {
      if (!this.fields) {
          const e = this.info.fields ? this.info.fields.concat() : [];
          this.fields = e.sort((t, n) => t.no - n.no)
      }
  }
  write(e, t, n) {
      this.prepare();
      for (const r of this.fields) {
          let a, l, o = r.repeat,
              u = r.localName;
          if (r.oneof) {
              const c = e[r.oneof];
              if (c.oneofKind !== u) continue;
              a = c[u], l = !0
          } else a = e[u], l = !1;
          switch (r.kind) {
              case "scalar":
              case "enum":
                  let c = r.kind == "enum" ? W.INT32 : r.T;
                  if (o)
                      if (Se(Array.isArray(a)), o == jr.PACKED) this.packed(t, c, r.no, a);
                      else
                          for (const h of a) this.scalar(t, c, r.no, h, !0);
                  else a === void 0 ? Se(r.opt) : this.scalar(t, c, r.no, a, l || r.opt);
                  break;
              case "message":
                  if (o) {
                      Se(Array.isArray(a));
                      for (const h of a) this.message(t, n, r.T(), r.no, h)
                  } else this.message(t, n, r.T(), r.no, a);
                  break;
              case "map":
                  Se(typeof a == "object" && a !== null);
                  for (const [h, d] of Object.entries(a)) this.mapEntry(t, n, r, h, d);
                  break
          }
      }
      let s = n.writeUnknownFields;
      s !== !1 && (s === !0 ? L.onWrite : s)(this.info.typeName, e, t)
  }
  mapEntry(e, t, n, s, r) {
      e.tag(n.no, v.LengthDelimited), e.fork();
      let a = s;
      switch (n.K) {
          case W.INT32:
          case W.FIXED32:
          case W.UINT32:
          case W.SFIXED32:
          case W.SINT32:
              a = Number.parseInt(s);
              break;
          case W.BOOL:
              Se(s == "true" || s == "false"), a = s == "true";
              break
      }
      switch (this.scalar(e, n.K, 1, a, !0), n.V.kind) {
          case "scalar":
              this.scalar(e, n.V.T, 2, r, !0);
              break;
          case "enum":
              this.scalar(e, W.INT32, 2, r, !0);
              break;
          case "message":
              this.message(e, t, n.V.T(), 2, r);
              break
      }
      e.join()
  }
  message(e, t, n, s, r) {
      r !== void 0 && (n.internalBinaryWrite(r, e.tag(s, v.LengthDelimited).fork(), t), e.join())
  }
  scalar(e, t, n, s, r) {
      let [a, l, o] = this.scalarInfo(t, s);
      (!o || r) && (e.tag(n, a), e[l](s))
  }
  packed(e, t, n, s) {
      if (!s.length) return;
      Se(t !== W.BYTES && t !== W.STRING), e.tag(n, v.LengthDelimited), e.fork();
      let [, r] = this.scalarInfo(t);
      for (let a = 0; a < s.length; a++) e[r](s[a]);
      e.join()
  }
  scalarInfo(e, t) {
      let n = v.Varint,
          s, r = t === void 0,
          a = t === 0;
      switch (e) {
          case W.INT32:
              s = "int32";
              break;
          case W.STRING:
              a = r || !t.length, n = v.LengthDelimited, s = "string";
              break;
          case W.BOOL:
              a = t === !1, s = "bool";
              break;
          case W.UINT32:
              s = "uint32";
              break;
          case W.DOUBLE:
              n = v.Bit64, s = "double";
              break;
          case W.FLOAT:
              n = v.Bit32, s = "float";
              break;
          case W.INT64:
              a = r || He.from(t).isZero(), s = "int64";
              break;
          case W.UINT64:
              a = r || gt.from(t).isZero(), s = "uint64";
              break;
          case W.FIXED64:
              a = r || gt.from(t).isZero(), n = v.Bit64, s = "fixed64";
              break;
          case W.BYTES:
              a = r || !t.byteLength, n = v.LengthDelimited, s = "bytes";
              break;
          case W.FIXED32:
              n = v.Bit32, s = "fixed32";
              break;
          case W.SFIXED32:
              n = v.Bit32, s = "sfixed32";
              break;
          case W.SFIXED64:
              a = r || He.from(t).isZero(), n = v.Bit64, s = "sfixed64";
              break;
          case W.SINT32:
              s = "sint32";
              break;
          case W.SINT64:
              a = r || He.from(t).isZero(), s = "sint64";
              break
      }
      return [n, s, r || a]
  }
}

function rv(i) {
  const e = i.messagePrototype ? Object.create(i.messagePrototype) : Object.defineProperty({}, J, {
      value: i
  });
  for (let t of i.fields) {
      let n = t.localName;
      if (!t.opt)
          if (t.oneof) e[t.oneof] = {
              oneofKind: void 0
          };
          else if (t.repeat) e[n] = [];
      else switch (t.kind) {
          case "scalar":
              e[n] = lo(t.T, t.L);
              break;
          case "enum":
              e[n] = 0;
              break;
          case "map":
              e[n] = {};
              break
      }
  }
  return e
}

function X(i, e, t) {
  let n, s = t,
      r;
  for (let a of i.fields) {
      let l = a.localName;
      if (a.oneof) {
          const o = s[a.oneof];
          if (o?.oneofKind == null) continue;
          if (n = o[l], r = e[a.oneof], r.oneofKind = o.oneofKind, n == null) {
              delete r[l];
              continue
          }
      } else if (n = s[l], r = e, n == null) continue;
      switch (a.repeat && (r[l].length = n.length), a.kind) {
          case "scalar":
          case "enum":
              if (a.repeat)
                  for (let u = 0; u < n.length; u++) r[l][u] = n[u];
              else r[l] = n;
              break;
          case "message":
              let o = a.T();
              if (a.repeat)
                  for (let u = 0; u < n.length; u++) r[l][u] = o.create(n[u]);
              else r[l] === void 0 ? r[l] = o.create(n) : o.mergePartial(r[l], n);
              break;
          case "map":
              switch (a.V.kind) {
                  case "scalar":
                  case "enum":
                      Object.assign(r[l], n);
                      break;
                  case "message":
                      let u = a.V.T();
                      for (let c of Object.keys(n)) r[l][c] = u.create(n[c]);
                      break
              }
              break
      }
  }
}

function av(i, e, t) {
  if (e === t) return !0;
  if (!e || !t) return !1;
  for (let n of i.fields) {
      let s = n.localName,
          r = n.oneof ? e[n.oneof][s] : e[s],
          a = n.oneof ? t[n.oneof][s] : t[s];
      switch (n.kind) {
          case "enum":
          case "scalar":
              let l = n.kind == "enum" ? W.INT32 : n.T;
              if (!(n.repeat ? Pc(l, r, a) : Qf(l, r, a))) return !1;
              break;
          case "map":
              if (!(n.V.kind == "message" ? Ic(n.V.T(), rr(r), rr(a)) : Pc(n.V.kind == "enum" ? W.INT32 : n.V.T, rr(r), rr(a)))) return !1;
              break;
          case "message":
              let o = n.T();
              if (!(n.repeat ? Ic(o, r, a) : o.equals(r, a))) return !1;
              break
      }
  }
  return !0
}
const rr = Object.values;

function Qf(i, e, t) {
  if (e === t) return !0;
  if (i !== W.BYTES) return !1;
  let n = e,
      s = t;
  if (n.length !== s.length) return !1;
  for (let r = 0; r < n.length; r++)
      if (n[r] != s[r]) return !1;
  return !0
}

function Pc(i, e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++)
      if (!Qf(i, e[n], t[n])) return !1;
  return !0
}

function Ic(i, e, t) {
  if (e.length !== t.length) return !1;
  for (let n = 0; n < e.length; n++)
      if (!i.equals(e[n], t[n])) return !1;
  return !0
}
const lv = Object.getOwnPropertyDescriptors(Object.getPrototypeOf({}));
class Z {
  constructor(e, t, n) {
      this.defaultCheckDepth = 16, this.typeName = e, this.fields = t.map(Qy), this.options = n ?? {}, this.messagePrototype = Object.create(null, Object.assign(Object.assign({}, lv), {
          [J]: {
              value: this
          }
      })), this.refTypeCheck = new ev(this), this.refJsonReader = new tv(this), this.refJsonWriter = new iv(this), this.refBinReader = new nv(this), this.refBinWriter = new sv(this)
  }
  create(e) {
      let t = rv(this);
      return e !== void 0 && X(this, t, e), t
  }
  clone(e) {
      let t = this.create();
      return X(this, t, e), t
  }
  equals(e, t) {
      return av(this, e, t)
  }
  is(e, t = this.defaultCheckDepth) {
      return this.refTypeCheck.is(e, t, !1)
  }
  isAssignable(e, t = this.defaultCheckDepth) {
      return this.refTypeCheck.is(e, t, !0)
  }
  mergePartial(e, t) {
      X(this, e, t)
  }
  fromBinary(e, t) {
      let n = Ay(t);
      return this.internalBinaryRead(n.readerFactory(e), e.byteLength, n)
  }
  fromJson(e, t) {
      return this.internalJsonRead(e, Xy(t))
  }
  fromJsonString(e, t) {
      let n = JSON.parse(e);
      return this.fromJson(n, t)
  }
  toJson(e, t) {
      return this.internalJsonWrite(e, Jy(t))
  }
  toJsonString(e, t) {
      var n;
      let s = this.toJson(e, t);
      return JSON.stringify(s, null, (n = t?.prettySpaces) !== null && n !== void 0 ? n : 0)
  }
  toBinary(e, t) {
      let n = Gy(t);
      return this.internalBinaryWrite(e, n.writerFactory(), n).finish()
  }
  internalJsonRead(e, t, n) {
      if (e !== null && typeof e == "object" && !Array.isArray(e)) {
          let s = n ?? this.create();
          return this.refJsonReader.read(e, s, t), s
      }
      throw new Error(`Unable to parse message ${this.typeName} from JSON ${ou(e)}.`)
  }
  internalJsonWrite(e, t) {
      return this.refJsonWriter.write(e, t)
  }
  internalBinaryWrite(e, t, n) {
      return this.refBinWriter.write(e, t, n), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create();
      return this.refBinReader.read(e, r, n, t), r
  }
}

function ov(i, e) {
  var t, n, s;
  let r = i;
  return r.service = e, r.localName = (t = r.localName) !== null && t !== void 0 ? t : ao(r.name), r.serverStreaming = !!r.serverStreaming, r.clientStreaming = !!r.clientStreaming, r.options = (n = r.options) !== null && n !== void 0 ? n : {}, r.idempotency = (s = r.idempotency) !== null && s !== void 0 ? s : void 0, r
}
class Zf {
  constructor(e, t, n) {
      this.typeName = e, this.methods = t.map(s => ov(s, this)), this.options = n ?? {}
  }
}
class Fe extends Error {
  constructor(e, t = "UNKNOWN", n) {
      super(e), this.name = "RpcError", Object.setPrototypeOf(this, new.target.prototype), this.code = t, this.meta = n ?? {}
  }
  toString() {
      const e = [this.name + ": " + this.message];
      this.code && (e.push(""), e.push("Code: " + this.code)), this.serviceName && this.methodName && e.push("Method: " + this.serviceName + "/" + this.methodName);
      let t = Object.entries(this.meta);
      if (t.length) {
          e.push(""), e.push("Meta:");
          for (let [n, s] of t) e.push(`  ${n}: ${s}`)
      }
      return e.join(`
`)
  }
}

function uv(i, e) {
  if (!e) return i;
  let t = {};
  ar(i, t), ar(e, t);
  for (let n of Object.keys(e)) {
      let s = e[n];
      switch (n) {
          case "jsonOptions":
              t.jsonOptions = Yy(i.jsonOptions, t.jsonOptions);
              break;
          case "binaryOptions":
              t.binaryOptions = By(i.binaryOptions, t.binaryOptions);
              break;
          case "meta":
              t.meta = {}, ar(i.meta, t.meta), ar(e.meta, t.meta);
              break;
          case "interceptors":
              t.interceptors = i.interceptors ? i.interceptors.concat(s) : s.concat();
              break
      }
  }
  return t
}

function ar(i, e) {
  if (!i) return;
  let t = e;
  for (let [n, s] of Object.entries(i)) s instanceof Date ? t[n] = new Date(s.getTime()) : Array.isArray(s) ? t[n] = s.concat() : t[n] = s
}
var Dt;
(function(i) {
  i[i.PENDING = 0] = "PENDING", i[i.REJECTED = 1] = "REJECTED", i[i.RESOLVED = 2] = "RESOLVED"
})(Dt || (Dt = {}));
class Ri {
  constructor(e = !0) {
      this._state = Dt.PENDING, this._promise = new Promise((t, n) => {
          this._resolve = t, this._reject = n
      }), e && this._promise.catch(t => {})
  }
  get state() {
      return this._state
  }
  get promise() {
      return this._promise
  }
  resolve(e) {
      if (this.state !== Dt.PENDING) throw new Error(`cannot resolve ${Dt[this.state].toLowerCase()}`);
      this._resolve(e), this._state = Dt.RESOLVED
  }
  reject(e) {
      if (this.state !== Dt.PENDING) throw new Error(`cannot reject ${Dt[this.state].toLowerCase()}`);
      this._reject(e), this._state = Dt.REJECTED
  }
  resolvePending(e) {
      this._state === Dt.PENDING && this.resolve(e)
  }
  rejectPending(e) {
      this._state === Dt.PENDING && this.reject(e)
  }
}
class cv {
  constructor() {
      this._lis = {
          nxt: [],
          msg: [],
          err: [],
          cmp: []
      }, this._closed = !1
  }
  onNext(e) {
      return this.addLis(e, this._lis.nxt)
  }
  onMessage(e) {
      return this.addLis(e, this._lis.msg)
  }
  onError(e) {
      return this.addLis(e, this._lis.err)
  }
  onComplete(e) {
      return this.addLis(e, this._lis.cmp)
  }
  addLis(e, t) {
      return t.push(e), () => {
          let n = t.indexOf(e);
          n >= 0 && t.splice(n, 1)
      }
  }
  clearLis() {
      for (let e of Object.values(this._lis)) e.splice(0, e.length)
  }
  get closed() {
      return this._closed !== !1
  }
  notifyNext(e, t, n) {
      Se((e ? 1 : 0) + (t ? 1 : 0) + (n ? 1 : 0) <= 1, "only one emission at a time"), e && this.notifyMessage(e), t && this.notifyError(t), n && this.notifyComplete()
  }
  notifyMessage(e) {
      Se(!this.closed, "stream is closed"), this.pushIt({
          value: e,
          done: !1
      }), this._lis.msg.forEach(t => t(e)), this._lis.nxt.forEach(t => t(e, void 0, !1))
  }
  notifyError(e) {
      Se(!this.closed, "stream is closed"), this._closed = e, this.pushIt(e), this._lis.err.forEach(t => t(e)), this._lis.nxt.forEach(t => t(void 0, e, !1)), this.clearLis()
  }
  notifyComplete() {
      Se(!this.closed, "stream is closed"), this._closed = !0, this.pushIt({
          value: null,
          done: !0
      }), this._lis.cmp.forEach(e => e()), this._lis.nxt.forEach(e => e(void 0, void 0, !0)), this.clearLis()
  } [Symbol.asyncIterator]() {
      return this._itState || (this._itState = {
          q: []
      }), this._closed === !0 ? this.pushIt({
          value: null,
          done: !0
      }) : this._closed !== !1 && this.pushIt(this._closed), {
          next: () => {
              let e = this._itState;
              Se(e, "bad state"), Se(!e.p, "iterator contract broken");
              let t = e.q.shift();
              return t ? "value" in t ? Promise.resolve(t) : Promise.reject(t) : (e.p = new Ri, e.p.promise)
          }
      }
  }
  pushIt(e) {
      let t = this._itState;
      if (!!t)
          if (t.p) {
              const n = t.p;
              Se(n.state == Dt.PENDING, "iterator contract broken"), "value" in e ? n.resolve(e) : n.reject(e), delete t.p
          } else t.q.push(e)
  }
}
var hv = globalThis && globalThis.__awaiter || function(i, e, t, n) {
  function s(r) {
      return r instanceof t ? r : new t(function(a) {
          a(r)
      })
  }
  return new(t || (t = Promise))(function(r, a) {
      function l(c) {
          try {
              u(n.next(c))
          } catch (h) {
              a(h)
          }
      }

      function o(c) {
          try {
              u(n.throw(c))
          } catch (h) {
              a(h)
          }
      }

      function u(c) {
          c.done ? r(c.value) : s(c.value).then(l, o)
      }
      u((n = n.apply(i, e || [])).next())
  })
};
class dv {
  constructor(e, t, n, s, r, a, l) {
      this.method = e, this.requestHeaders = t, this.request = n, this.headers = s, this.response = r, this.status = a, this.trailers = l
  }
  then(e, t) {
      return this.promiseFinished().then(n => e ? Promise.resolve(e(n)) : n, n => t ? Promise.resolve(t(n)) : Promise.reject(n))
  }
  promiseFinished() {
      return hv(this, void 0, void 0, function*() {
          let [e, t, n, s] = yield Promise.all([this.headers, this.response, this.status, this.trailers]);
          return {
              method: this.method,
              requestHeaders: this.requestHeaders,
              request: this.request,
              headers: e,
              response: t,
              status: n,
              trailers: s
          }
      })
  }
}
var fv = globalThis && globalThis.__awaiter || function(i, e, t, n) {
  function s(r) {
      return r instanceof t ? r : new t(function(a) {
          a(r)
      })
  }
  return new(t || (t = Promise))(function(r, a) {
      function l(c) {
          try {
              u(n.next(c))
          } catch (h) {
              a(h)
          }
      }

      function o(c) {
          try {
              u(n.throw(c))
          } catch (h) {
              a(h)
          }
      }

      function u(c) {
          c.done ? r(c.value) : s(c.value).then(l, o)
      }
      u((n = n.apply(i, e || [])).next())
  })
};
class pv {
  constructor(e, t, n, s, r, a, l) {
      this.method = e, this.requestHeaders = t, this.request = n, this.headers = s, this.responses = r, this.status = a, this.trailers = l
  }
  then(e, t) {
      return this.promiseFinished().then(n => e ? Promise.resolve(e(n)) : n, n => t ? Promise.resolve(t(n)) : Promise.reject(n))
  }
  promiseFinished() {
      return fv(this, void 0, void 0, function*() {
          let [e, t, n] = yield Promise.all([this.headers, this.status, this.trailers]);
          return {
              method: this.method,
              requestHeaders: this.requestHeaders,
              request: this.request,
              headers: e,
              status: t,
              trailers: n
          }
      })
  }
}

function qe(i, e, t, n, s) {
  var r, a, l, o;
  if (i == "unary") {
      let u = (c, h, d) => e.unary(c, h, d);
      for (const c of ((r = n.interceptors) !== null && r !== void 0 ? r : []).filter(h => h.interceptUnary).reverse()) {
          const h = u;
          u = (d, f, p) => c.interceptUnary(h, d, f, p)
      }
      return u(t, s, n)
  }
  if (i == "serverStreaming") {
      let u = (c, h, d) => e.serverStreaming(c, h, d);
      for (const c of ((a = n.interceptors) !== null && a !== void 0 ? a : []).filter(h => h.interceptServerStreaming).reverse()) {
          const h = u;
          u = (d, f, p) => c.interceptServerStreaming(h, d, f, p)
      }
      return u(t, s, n)
  }
  if (i == "clientStreaming") {
      let u = (c, h) => e.clientStreaming(c, h);
      for (const c of ((l = n.interceptors) !== null && l !== void 0 ? l : []).filter(h => h.interceptClientStreaming).reverse()) {
          const h = u;
          u = (d, f) => c.interceptClientStreaming(h, d, f)
      }
      return u(t, n)
  }
  if (i == "duplex") {
      let u = (c, h) => e.duplex(c, h);
      for (const c of ((o = n.interceptors) !== null && o !== void 0 ? o : []).filter(h => h.interceptDuplex).reverse()) {
          const h = u;
          u = (d, f) => c.interceptDuplex(h, d, f)
      }
      return u(t, n)
  }
  zy(i)
}
class mv extends Z {
  constructor() {
      super("google.protobuf.DoubleValue", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 1
      }])
  }
  internalJsonWrite(e, t) {
      return this.refJsonWriter.scalar(2, e.value, "value", !1, !0)
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, 1, void 0, "value"), n
  }
  create(e) {
      const t = {
          value: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value !== 0 && t.tag(1, v.Bit64).double(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const wn = new mv;
class gv extends Z {
  constructor() {
      super("google.protobuf.FloatValue", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 2
      }])
  }
  internalJsonWrite(e, t) {
      return this.refJsonWriter.scalar(1, e.value, "value", !1, !0)
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, 1, void 0, "value"), n
  }
  create(e) {
      const t = {
          value: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.float();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value !== 0 && t.tag(1, v.Bit32).float(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
new gv;
class yv extends Z {
  constructor() {
      super("google.protobuf.Int64Value", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  internalJsonWrite(e, t) {
      return this.refJsonWriter.scalar(W.INT64, e.value, "value", !1, !0)
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, W.INT64, Wt.NUMBER, "value"), n
  }
  create(e) {
      const t = {
          value: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value !== 0 && t.tag(1, v.Varint).int64(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const be = new yv;
class vv extends Z {
  constructor() {
      super("google.protobuf.UInt64Value", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 4,
          L: 2
      }])
  }
  internalJsonWrite(e, t) {
      return this.refJsonWriter.scalar(W.UINT64, e.value, "value", !1, !0)
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, W.UINT64, Wt.NUMBER, "value"), n
  }
  create(e) {
      const t = {
          value: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.uint64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value !== 0 && t.tag(1, v.Varint).uint64(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
new vv;
class bv extends Z {
  constructor() {
      super("google.protobuf.Int32Value", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 5
      }])
  }
  internalJsonWrite(e, t) {
      return this.refJsonWriter.scalar(5, e.value, "value", !1, !0)
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, 5, void 0, "value"), n
  }
  create(e) {
      const t = {
          value: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.int32();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value !== 0 && t.tag(1, v.Varint).int32(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
new bv;
class wv extends Z {
  constructor() {
      super("google.protobuf.UInt32Value", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 13
      }])
  }
  internalJsonWrite(e, t) {
      return this.refJsonWriter.scalar(13, e.value, "value", !1, !0)
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, 13, void 0, "value"), n
  }
  create(e) {
      const t = {
          value: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.uint32();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value !== 0 && t.tag(1, v.Varint).uint32(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
new wv;
class kv extends Z {
  constructor() {
      super("google.protobuf.BoolValue", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 8
      }])
  }
  internalJsonWrite(e, t) {
      return e.value
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, 8, void 0, "value"), n
  }
  create(e) {
      const t = {
          value: !1
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.bool();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value !== !1 && t.tag(1, v.Varint).bool(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
new kv;
class _v extends Z {
  constructor() {
      super("google.protobuf.StringValue", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 9
      }])
  }
  internalJsonWrite(e, t) {
      return e.value
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, 9, void 0, "value"), n
  }
  create(e) {
      const t = {
          value: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value !== "" && t.tag(1, v.LengthDelimited).string(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ot = new _v;
class xv extends Z {
  constructor() {
      super("google.protobuf.BytesValue", [{
          no: 1,
          name: "value",
          kind: "scalar",
          T: 12
      }])
  }
  internalJsonWrite(e, t) {
      return this.refJsonWriter.scalar(12, e.value, "value", !1, !0)
  }
  internalJsonRead(e, t, n) {
      return n || (n = this.create()), n.value = this.refJsonReader.scalar(e, 12, void 0, "value"), n
  }
  create(e) {
      const t = {
          value: new Uint8Array(0)
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.value = e.bytes();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.value.length && t.tag(1, v.LengthDelimited).bytes(e.value);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
new xv;
var Gt = (i => (i[i.Quadratic = 0] = "Quadratic", i[i.QuadraticV2 = 1] = "QuadraticV2", i[i.Linear = 2] = "Linear", i[i.Fixed = 3] = "Fixed", i))(Gt || {}),
  Hr = (i => (i[i.BUY = 0] = "BUY", i[i.SELL = 1] = "SELL", i))(Hr || {});
class Tv extends Z {
  constructor() {
      super("hypurr.HyperliquidToken", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "name",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "index",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "sz_decimals",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 5,
          name: "wei_decimals",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 6,
          name: "token_id",
          kind: "scalar",
          T: 9
      }, {
          no: 7,
          name: "circulating_supply",
          kind: "scalar",
          T: 1
      }, {
          no: 8,
          name: "deploy_info",
          kind: "message",
          T: () => Ha
      }, {
          no: 9,
          name: "geneses",
          kind: "message",
          repeat: 1,
          T: () => qa
      }, {
          no: 10,
          name: "hlq_balance",
          kind: "scalar",
          T: 1
      }, {
          no: 11,
          name: "full_name",
          kind: "scalar",
          T: 9
      }, {
          no: 12,
          name: "statistics",
          kind: "message",
          T: () => ja
      }])
  }
  create(e) {
      const t = {
          id: 0,
          name: "",
          index: 0,
          szDecimals: 0,
          weiDecimals: 0,
          tokenId: "",
          circulatingSupply: 0,
          geneses: [],
          hlqBalance: 0,
          fullName: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.name = e.string();
                  break;
              case 3:
                  r.index = e.int64().toNumber();
                  break;
              case 4:
                  r.szDecimals = e.int64().toNumber();
                  break;
              case 5:
                  r.weiDecimals = e.int64().toNumber();
                  break;
              case 6:
                  r.tokenId = e.string();
                  break;
              case 7:
                  r.circulatingSupply = e.double();
                  break;
              case 8:
                  r.deployInfo = Ha.internalBinaryRead(e, e.uint32(), n, r.deployInfo);
                  break;
              case 9:
                  r.geneses.push(qa.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 10:
                  r.hlqBalance = e.double();
                  break;
              case 11:
                  r.fullName = e.string();
                  break;
              case 12:
                  r.statistics = ja.internalBinaryRead(e, e.uint32(), n, r.statistics);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.name !== "" && t.tag(2, v.LengthDelimited).string(e.name), e.index !== 0 && t.tag(3, v.Varint).int64(e.index), e.szDecimals !== 0 && t.tag(4, v.Varint).int64(e.szDecimals), e.weiDecimals !== 0 && t.tag(5, v.Varint).int64(e.weiDecimals), e.tokenId !== "" && t.tag(6, v.LengthDelimited).string(e.tokenId), e.circulatingSupply !== 0 && t.tag(7, v.Bit64).double(e.circulatingSupply), e.deployInfo && Ha.internalBinaryWrite(e.deployInfo, t.tag(8, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.geneses.length; r++) qa.internalBinaryWrite(e.geneses[r], t.tag(9, v.LengthDelimited).fork(), n).join();
      e.hlqBalance !== 0 && t.tag(10, v.Bit64).double(e.hlqBalance), e.fullName !== "" && t.tag(11, v.LengthDelimited).string(e.fullName), e.statistics && ja.internalBinaryWrite(e.statistics, t.tag(12, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const at = new Tv;
class Sv extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenHolder", [{
          no: 1,
          name: "balance",
          kind: "scalar",
          T: 1
      }, {
          no: 2,
          name: "address",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "type",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          balance: 0,
          address: "",
          type: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.balance = e.double();
                  break;
              case 2:
                  r.address = e.string();
                  break;
              case 3:
                  r.type = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.balance !== 0 && t.tag(1, v.Bit64).double(e.balance), e.address !== "" && t.tag(2, v.LengthDelimited).string(e.address), e.type !== "" && t.tag(3, v.LengthDelimited).string(e.type);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ua = new Sv;
class Ev extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenHoldersRequest", [{
          no: 1,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          tokenId: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.tokenId = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.tokenId !== 0 && t.tag(1, v.Varint).int64(e.tokenId);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Cv = new Ev;
class $v extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenHoldersResponse", [{
          no: 1,
          name: "holders",
          kind: "message",
          repeat: 1,
          T: () => Ua
      }])
  }
  create(e) {
      const t = {
          holders: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.holders.push(Ua.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.holders.length; r++) Ua.internalBinaryWrite(e.holders[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Lv = new $v;
class Pv extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenStatistics", [{
          no: 1,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "holder_count",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "concentration_coefficient",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          tokenId: 0,
          holderCount: 0,
          concentrationCoefficient: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.tokenId = e.int64().toNumber();
                  break;
              case 2:
                  r.holderCount = e.int64().toNumber();
                  break;
              case 3:
                  r.concentrationCoefficient = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.tokenId !== 0 && t.tag(1, v.Varint).int64(e.tokenId), e.holderCount !== 0 && t.tag(2, v.Varint).int64(e.holderCount), e.concentrationCoefficient !== 0 && t.tag(3, v.Bit64).double(e.concentrationCoefficient);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ja = new Pv;
class Iv extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenDeployInfo", [{
          no: 1,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "height",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "deployer",
          kind: "scalar",
          T: 9
      }, {
          no: 4,
          name: "register_tx",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "register_spot_tx",
          kind: "scalar",
          T: 9
      }, {
          no: 6,
          name: "genesis_tx",
          kind: "scalar",
          T: 9
      }, {
          no: 7,
          name: "hyperliquidity_tx",
          kind: "scalar",
          T: 9
      }, {
          no: 8,
          name: "hip2_price",
          kind: "scalar",
          T: 1
      }, {
          no: 9,
          name: "hip2_order_count",
          kind: "scalar",
          T: 5
      }, {
          no: 10,
          name: "hip2_order_size",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          tokenId: 0,
          height: 0,
          deployer: "",
          registerTx: "",
          registerSpotTx: "",
          genesisTx: "",
          hyperliquidityTx: "",
          hip2Price: 0,
          hip2OrderCount: 0,
          hip2OrderSize: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.tokenId = e.int64().toNumber();
                  break;
              case 2:
                  r.height = e.int64().toNumber();
                  break;
              case 3:
                  r.deployer = e.string();
                  break;
              case 4:
                  r.registerTx = e.string();
                  break;
              case 5:
                  r.registerSpotTx = e.string();
                  break;
              case 6:
                  r.genesisTx = e.string();
                  break;
              case 7:
                  r.hyperliquidityTx = e.string();
                  break;
              case 8:
                  r.hip2Price = e.double();
                  break;
              case 9:
                  r.hip2OrderCount = e.int32();
                  break;
              case 10:
                  r.hip2OrderSize = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.tokenId !== 0 && t.tag(1, v.Varint).int64(e.tokenId), e.height !== 0 && t.tag(2, v.Varint).int64(e.height), e.deployer !== "" && t.tag(3, v.LengthDelimited).string(e.deployer), e.registerTx !== "" && t.tag(4, v.LengthDelimited).string(e.registerTx), e.registerSpotTx !== "" && t.tag(5, v.LengthDelimited).string(e.registerSpotTx), e.genesisTx !== "" && t.tag(6, v.LengthDelimited).string(e.genesisTx), e.hyperliquidityTx !== "" && t.tag(7, v.LengthDelimited).string(e.hyperliquidityTx), e.hip2Price !== 0 && t.tag(8, v.Bit64).double(e.hip2Price), e.hip2OrderCount !== 0 && t.tag(9, v.Varint).int32(e.hip2OrderCount), e.hip2OrderSize !== 0 && t.tag(10, v.Bit64).double(e.hip2OrderSize);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ha = new Iv;
class Nv extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenGenesis", [{
          no: 1,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "target",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "amount",
          kind: "scalar",
          T: 1
      }, {
          no: 4,
          name: "type",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "target_token_id",
          kind: "message",
          T: () => be
      }])
  }
  create(e) {
      const t = {
          tokenId: 0,
          target: "",
          amount: 0,
          type: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.tokenId = e.int64().toNumber();
                  break;
              case 2:
                  r.target = e.string();
                  break;
              case 3:
                  r.amount = e.double();
                  break;
              case 4:
                  r.type = e.string();
                  break;
              case 5:
                  r.targetTokenId = be.internalBinaryRead(e, e.uint32(), n, r.targetTokenId);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.tokenId !== 0 && t.tag(1, v.Varint).int64(e.tokenId), e.target !== "" && t.tag(2, v.LengthDelimited).string(e.target), e.amount !== 0 && t.tag(3, v.Bit64).double(e.amount), e.type !== "" && t.tag(4, v.LengthDelimited).string(e.type), e.targetTokenId && be.internalBinaryWrite(e.targetTokenId, t.tag(5, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const qa = new Nv;
class Mv extends Z {
  constructor() {
      super("hypurr.HyperliquidSpotPair", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "name",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "base_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "base",
          kind: "message",
          T: () => at
      }, {
          no: 5,
          name: "quote_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 6,
          name: "quote",
          kind: "message",
          T: () => at
      }, {
          no: 7,
          name: "index",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 8,
          name: "mid_price",
          kind: "scalar",
          T: 1
      }, {
          no: 9,
          name: "mark_price",
          kind: "scalar",
          T: 1
      }, {
          no: 10,
          name: "daily_ntl_volume",
          kind: "scalar",
          T: 1
      }, {
          no: 11,
          name: "previous_day_px",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          id: 0,
          name: "",
          baseId: 0,
          quoteId: 0,
          index: 0,
          midPrice: 0,
          markPrice: 0,
          dailyNtlVolume: 0,
          previousDayPx: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.name = e.string();
                  break;
              case 3:
                  r.baseId = e.int64().toNumber();
                  break;
              case 4:
                  r.base = at.internalBinaryRead(e, e.uint32(), n, r.base);
                  break;
              case 5:
                  r.quoteId = e.int64().toNumber();
                  break;
              case 6:
                  r.quote = at.internalBinaryRead(e, e.uint32(), n, r.quote);
                  break;
              case 7:
                  r.index = e.int64().toNumber();
                  break;
              case 8:
                  r.midPrice = e.double();
                  break;
              case 9:
                  r.markPrice = e.double();
                  break;
              case 10:
                  r.dailyNtlVolume = e.double();
                  break;
              case 11:
                  r.previousDayPx = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.name !== "" && t.tag(2, v.LengthDelimited).string(e.name), e.baseId !== 0 && t.tag(3, v.Varint).int64(e.baseId), e.base && at.internalBinaryWrite(e.base, t.tag(4, v.LengthDelimited).fork(), n).join(), e.quoteId !== 0 && t.tag(5, v.Varint).int64(e.quoteId), e.quote && at.internalBinaryWrite(e.quote, t.tag(6, v.LengthDelimited).fork(), n).join(), e.index !== 0 && t.tag(7, v.Varint).int64(e.index), e.midPrice !== 0 && t.tag(8, v.Bit64).double(e.midPrice), e.markPrice !== 0 && t.tag(9, v.Bit64).double(e.markPrice), e.dailyNtlVolume !== 0 && t.tag(10, v.Bit64).double(e.dailyNtlVolume), e.previousDayPx !== 0 && t.tag(11, v.Bit64).double(e.previousDayPx);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Mn = new Mv;
class Rv extends Z {
  constructor() {
      super("hypurr.HyperliquidPerpPair", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "name",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "index",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "mid_price",
          kind: "scalar",
          T: 1
      }, {
          no: 5,
          name: "mark_price",
          kind: "scalar",
          T: 1
      }, {
          no: 6,
          name: "daily_ntl_volume",
          kind: "scalar",
          T: 1
      }, {
          no: 7,
          name: "previous_day_px",
          kind: "scalar",
          T: 1
      }, {
          no: 8,
          name: "funding",
          kind: "scalar",
          T: 1
      }, {
          no: 9,
          name: "open_interest",
          kind: "scalar",
          T: 1
      }, {
          no: 10,
          name: "premium",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          id: 0,
          name: "",
          index: 0,
          midPrice: 0,
          markPrice: 0,
          dailyNtlVolume: 0,
          previousDayPx: 0,
          funding: 0,
          openInterest: 0,
          premium: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.name = e.string();
                  break;
              case 3:
                  r.index = e.int64().toNumber();
                  break;
              case 4:
                  r.midPrice = e.double();
                  break;
              case 5:
                  r.markPrice = e.double();
                  break;
              case 6:
                  r.dailyNtlVolume = e.double();
                  break;
              case 7:
                  r.previousDayPx = e.double();
                  break;
              case 8:
                  r.funding = e.double();
                  break;
              case 9:
                  r.openInterest = e.double();
                  break;
              case 10:
                  r.premium = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.name !== "" && t.tag(2, v.LengthDelimited).string(e.name), e.index !== 0 && t.tag(3, v.Varint).int64(e.index), e.midPrice !== 0 && t.tag(4, v.Bit64).double(e.midPrice), e.markPrice !== 0 && t.tag(5, v.Bit64).double(e.markPrice), e.dailyNtlVolume !== 0 && t.tag(6, v.Bit64).double(e.dailyNtlVolume), e.previousDayPx !== 0 && t.tag(7, v.Bit64).double(e.previousDayPx), e.funding !== 0 && t.tag(8, v.Bit64).double(e.funding), e.openInterest !== 0 && t.tag(9, v.Bit64).double(e.openInterest), e.premium !== 0 && t.tag(10, v.Bit64).double(e.premium);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ga = new Rv;
class Bv extends Z {
  constructor() {
      super("hypurr.HyperliquidWallet", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "name",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "telegram_id",
          kind: "message",
          T: () => be
      }, {
          no: 4,
          name: "ethereum_address",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "points",
          kind: "scalar",
          T: 5
      }, {
          no: 6,
          name: "movements",
          kind: "message",
          repeat: 1,
          T: () => Rn
      }, {
          no: 7,
          name: "spot_balances",
          kind: "message",
          repeat: 1,
          T: () => Bn
      }, {
          no: 8,
          name: "launch_balances",
          kind: "message",
          repeat: 1,
          T: () => Ka
      }, {
          no: 9,
          name: "is_agent",
          kind: "scalar",
          T: 8
      }, {
          no: 10,
          name: "is_read_only",
          kind: "scalar",
          T: 8
      }])
  }
  create(e) {
      const t = {
          id: 0,
          name: "",
          ethereumAddress: "",
          points: 0,
          movements: [],
          spotBalances: [],
          launchBalances: [],
          isAgent: !1,
          isReadOnly: !1
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.name = e.string();
                  break;
              case 3:
                  r.telegramId = be.internalBinaryRead(e, e.uint32(), n, r.telegramId);
                  break;
              case 4:
                  r.ethereumAddress = e.string();
                  break;
              case 5:
                  r.points = e.int32();
                  break;
              case 6:
                  r.movements.push(Rn.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 7:
                  r.spotBalances.push(Bn.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 8:
                  r.launchBalances.push(Ka.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 9:
                  r.isAgent = e.bool();
                  break;
              case 10:
                  r.isReadOnly = e.bool();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.name !== "" && t.tag(2, v.LengthDelimited).string(e.name), e.telegramId && be.internalBinaryWrite(e.telegramId, t.tag(3, v.LengthDelimited).fork(), n).join(), e.ethereumAddress !== "" && t.tag(4, v.LengthDelimited).string(e.ethereumAddress), e.points !== 0 && t.tag(5, v.Varint).int32(e.points);
      for (let r = 0; r < e.movements.length; r++) Rn.internalBinaryWrite(e.movements[r], t.tag(6, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.spotBalances.length; r++) Bn.internalBinaryWrite(e.spotBalances[r], t.tag(7, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.launchBalances.length; r++) Ka.internalBinaryWrite(e.launchBalances[r], t.tag(8, v.LengthDelimited).fork(), n).join();
      e.isAgent !== !1 && t.tag(9, v.Varint).bool(e.isAgent), e.isReadOnly !== !1 && t.tag(10, v.Varint).bool(e.isReadOnly);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ve = new Bv;
class Ov extends Z {
  constructor() {
      super("hypurr.HyperliquidPublicWallet", [{
          no: 1,
          name: "ethereum_address",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          ethereumAddress: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.ethereumAddress = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.ethereumAddress !== "" && t.tag(1, v.LengthDelimited).string(e.ethereumAddress);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const bi = new Ov;
class Dv extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletMovement", [{
          no: 1,
          name: "telegram_id",
          kind: "message",
          T: () => be
      }, {
          no: 2,
          name: "wallet",
          kind: "message",
          T: () => Ve
      }, {
          no: 3,
          name: "wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "hash",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "type",
          kind: "scalar",
          T: 9
      }, {
          no: 6,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 7,
          name: "token",
          kind: "message",
          T: () => at
      }, {
          no: 8,
          name: "amount",
          kind: "scalar",
          T: 1
      }, {
          no: 9,
          name: "usdc_value",
          kind: "scalar",
          T: 1
      }, {
          no: 10,
          name: "destination",
          kind: "scalar",
          T: 9
      }, {
          no: 11,
          name: "fee",
          kind: "scalar",
          T: 1
      }, {
          no: 12,
          name: "timestamp",
          kind: "message",
          T: () => be
      }])
  }
  create(e) {
      const t = {
          walletId: 0,
          hash: "",
          type: "",
          tokenId: 0,
          amount: 0,
          usdcValue: 0,
          destination: "",
          fee: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.telegramId = be.internalBinaryRead(e, e.uint32(), n, r.telegramId);
                  break;
              case 2:
                  r.wallet = Ve.internalBinaryRead(e, e.uint32(), n, r.wallet);
                  break;
              case 3:
                  r.walletId = e.int64().toNumber();
                  break;
              case 4:
                  r.hash = e.string();
                  break;
              case 5:
                  r.type = e.string();
                  break;
              case 6:
                  r.tokenId = e.int64().toNumber();
                  break;
              case 7:
                  r.token = at.internalBinaryRead(e, e.uint32(), n, r.token);
                  break;
              case 8:
                  r.amount = e.double();
                  break;
              case 9:
                  r.usdcValue = e.double();
                  break;
              case 10:
                  r.destination = e.string();
                  break;
              case 11:
                  r.fee = e.double();
                  break;
              case 12:
                  r.timestamp = be.internalBinaryRead(e, e.uint32(), n, r.timestamp);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.telegramId && be.internalBinaryWrite(e.telegramId, t.tag(1, v.LengthDelimited).fork(), n).join(), e.wallet && Ve.internalBinaryWrite(e.wallet, t.tag(2, v.LengthDelimited).fork(), n).join(), e.walletId !== 0 && t.tag(3, v.Varint).int64(e.walletId), e.hash !== "" && t.tag(4, v.LengthDelimited).string(e.hash), e.type !== "" && t.tag(5, v.LengthDelimited).string(e.type), e.tokenId !== 0 && t.tag(6, v.Varint).int64(e.tokenId), e.token && at.internalBinaryWrite(e.token, t.tag(7, v.LengthDelimited).fork(), n).join(), e.amount !== 0 && t.tag(8, v.Bit64).double(e.amount), e.usdcValue !== 0 && t.tag(9, v.Bit64).double(e.usdcValue), e.destination !== "" && t.tag(10, v.LengthDelimited).string(e.destination), e.fee !== 0 && t.tag(11, v.Bit64).double(e.fee), e.timestamp && be.internalBinaryWrite(e.timestamp, t.tag(12, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Rn = new Dv;
class Fv extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletBalance", [{
          no: 1,
          name: "telegram_id",
          kind: "message",
          T: () => be
      }, {
          no: 2,
          name: "wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "balance",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          walletId: 0,
          tokenId: 0,
          balance: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.telegramId = be.internalBinaryRead(e, e.uint32(), n, r.telegramId);
                  break;
              case 2:
                  r.walletId = e.int64().toNumber();
                  break;
              case 3:
                  r.tokenId = e.int64().toNumber();
                  break;
              case 4:
                  r.balance = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.telegramId && be.internalBinaryWrite(e.telegramId, t.tag(1, v.LengthDelimited).fork(), n).join(), e.walletId !== 0 && t.tag(2, v.Varint).int64(e.walletId), e.tokenId !== 0 && t.tag(3, v.Varint).int64(e.tokenId), e.balance !== 0 && t.tag(4, v.Bit64).double(e.balance);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Bn = new Fv;
class Av extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchBalance", [{
          no: 1,
          name: "telegram_id",
          kind: "message",
          T: () => be
      }, {
          no: 2,
          name: "wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "launch_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "balance",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          walletId: 0,
          launchId: 0,
          balance: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.telegramId = be.internalBinaryRead(e, e.uint32(), n, r.telegramId);
                  break;
              case 2:
                  r.walletId = e.int64().toNumber();
                  break;
              case 3:
                  r.launchId = e.int64().toNumber();
                  break;
              case 4:
                  r.balance = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.telegramId && be.internalBinaryWrite(e.telegramId, t.tag(1, v.LengthDelimited).fork(), n).join(), e.walletId !== 0 && t.tag(2, v.Varint).int64(e.walletId), e.launchId !== 0 && t.tag(3, v.Varint).int64(e.launchId), e.balance !== 0 && t.tag(4, v.Varint).int64(e.balance);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ka = new Av;
class Vv extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletDeploySession", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "telegram_id",
          kind: "message",
          T: () => be
      }, {
          no: 3,
          name: "step",
          kind: "scalar",
          T: 5
      }, {
          no: 4,
          name: "token_name",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "full_name",
          kind: "scalar",
          T: 9
      }, {
          no: 6,
          name: "token_decimals",
          kind: "scalar",
          T: 5
      }, {
          no: 7,
          name: "token_wei",
          kind: "scalar",
          T: 5
      }, {
          no: 8,
          name: "token_supply",
          kind: "scalar",
          T: 1
      }, {
          no: 9,
          name: "start_market_cap",
          kind: "scalar",
          T: 5
      }, {
          no: 10,
          name: "anchor1_token_id",
          kind: "message",
          T: () => be
      }, {
          no: 11,
          name: "anchor1_token",
          kind: "message",
          T: () => at
      }, {
          no: 12,
          name: "anchor2_token_id",
          kind: "message",
          T: () => be
      }, {
          no: 13,
          name: "anchor2_token",
          kind: "message",
          T: () => at
      }, {
          no: 14,
          name: "token_id",
          kind: "message",
          T: () => be
      }, {
          no: 15,
          name: "spot_pair_id",
          kind: "scalar",
          T: 5
      }, {
          no: 16,
          name: "deploy_threshold",
          kind: "scalar",
          T: 1
      }, {
          no: 17,
          name: "geneses",
          kind: "map",
          K: 9,
          V: {
              kind: "message",
              T: () => lr
          }
      }])
  }
  create(e) {
      const t = {
          id: 0,
          step: 0,
          tokenName: "",
          fullName: "",
          tokenDecimals: 0,
          tokenWei: 0,
          tokenSupply: 0,
          startMarketCap: 0,
          spotPairId: 0,
          deployThreshold: 0,
          geneses: {}
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.telegramId = be.internalBinaryRead(e, e.uint32(), n, r.telegramId);
                  break;
              case 3:
                  r.step = e.int32();
                  break;
              case 4:
                  r.tokenName = e.string();
                  break;
              case 5:
                  r.fullName = e.string();
                  break;
              case 6:
                  r.tokenDecimals = e.int32();
                  break;
              case 7:
                  r.tokenWei = e.int32();
                  break;
              case 8:
                  r.tokenSupply = e.double();
                  break;
              case 9:
                  r.startMarketCap = e.int32();
                  break;
              case 10:
                  r.anchor1TokenId = be.internalBinaryRead(e, e.uint32(), n, r.anchor1TokenId);
                  break;
              case 11:
                  r.anchor1Token = at.internalBinaryRead(e, e.uint32(), n, r.anchor1Token);
                  break;
              case 12:
                  r.anchor2TokenId = be.internalBinaryRead(e, e.uint32(), n, r.anchor2TokenId);
                  break;
              case 13:
                  r.anchor2Token = at.internalBinaryRead(e, e.uint32(), n, r.anchor2Token);
                  break;
              case 14:
                  r.tokenId = be.internalBinaryRead(e, e.uint32(), n, r.tokenId);
                  break;
              case 15:
                  r.spotPairId = e.int32();
                  break;
              case 16:
                  r.deployThreshold = e.double();
                  break;
              case 17:
                  this.binaryReadMap17(r.geneses, e, n);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  binaryReadMap17(e, t, n) {
      let s = t.uint32(),
          r = t.pos + s,
          a, l;
      for (; t.pos < r;) {
          let [o, u] = t.tag();
          switch (o) {
              case 1:
                  a = t.string();
                  break;
              case 2:
                  l = lr.internalBinaryRead(t, t.uint32(), n);
                  break;
              default:
                  throw new globalThis.Error("unknown map entry field for field hypurr.HyperliquidWalletDeploySession.geneses")
          }
      }
      e[a ?? ""] = l ?? lr.create()
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.telegramId && be.internalBinaryWrite(e.telegramId, t.tag(2, v.LengthDelimited).fork(), n).join(), e.step !== 0 && t.tag(3, v.Varint).int32(e.step), e.tokenName !== "" && t.tag(4, v.LengthDelimited).string(e.tokenName), e.fullName !== "" && t.tag(5, v.LengthDelimited).string(e.fullName), e.tokenDecimals !== 0 && t.tag(6, v.Varint).int32(e.tokenDecimals), e.tokenWei !== 0 && t.tag(7, v.Varint).int32(e.tokenWei), e.tokenSupply !== 0 && t.tag(8, v.Bit64).double(e.tokenSupply), e.startMarketCap !== 0 && t.tag(9, v.Varint).int32(e.startMarketCap), e.anchor1TokenId && be.internalBinaryWrite(e.anchor1TokenId, t.tag(10, v.LengthDelimited).fork(), n).join(), e.anchor1Token && at.internalBinaryWrite(e.anchor1Token, t.tag(11, v.LengthDelimited).fork(), n).join(), e.anchor2TokenId && be.internalBinaryWrite(e.anchor2TokenId, t.tag(12, v.LengthDelimited).fork(), n).join(), e.anchor2Token && at.internalBinaryWrite(e.anchor2Token, t.tag(13, v.LengthDelimited).fork(), n).join(), e.tokenId && be.internalBinaryWrite(e.tokenId, t.tag(14, v.LengthDelimited).fork(), n).join(), e.spotPairId !== 0 && t.tag(15, v.Varint).int32(e.spotPairId), e.deployThreshold !== 0 && t.tag(16, v.Bit64).double(e.deployThreshold);
      for (let r of Object.keys(e.geneses)) t.tag(17, v.LengthDelimited).fork().tag(1, v.LengthDelimited).string(r), t.tag(2, v.LengthDelimited).fork(), lr.internalBinaryWrite(e.geneses[r], t, n), t.join().join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ut = new Vv;
class zv extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletDeploySessionGenesis", [{
          no: 1,
          name: "target",
          kind: "scalar",
          T: 9
      }, {
          no: 2,
          name: "share",
          kind: "scalar",
          T: 5
      }])
  }
  create(e) {
      const t = {
          target: "",
          share: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.target = e.string();
                  break;
              case 2:
                  r.share = e.int32();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.target !== "" && t.tag(1, v.LengthDelimited).string(e.target), e.share !== 0 && t.tag(2, v.Varint).int32(e.share);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const lr = new zv;
class Wv extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunch", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "telegram_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "telegram_user",
          kind: "message",
          T: () => Ht
      }, {
          no: 4,
          name: "description",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "listed",
          kind: "scalar",
          T: 8
      }, {
          no: 6,
          name: "settled",
          kind: "scalar",
          T: 8
      }, {
          no: 7,
          name: "x0",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 8,
          name: "session_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 9,
          name: "session",
          kind: "message",
          T: () => Ut
      }, {
          no: 10,
          name: "media_file_id",
          kind: "scalar",
          T: 9
      }, {
          no: 11,
          name: "topic_id",
          kind: "message",
          T: () => be
      }, {
          no: 12,
          name: "x",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 13,
          name: "y",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 14,
          name: "k",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 15,
          name: "fills",
          kind: "message",
          repeat: 1,
          T: () => Ei
      }, {
          no: 16,
          name: "daily_ntl_volume",
          kind: "scalar",
          T: 1
      }, {
          no: 17,
          name: "previous_day_px",
          kind: "scalar",
          T: 1
      }, {
          no: 18,
          name: "last_event_timestamp",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 19,
          name: "pool_type",
          kind: "enum",
          T: () => ["hypurr.HyperliquidLaunchPoolType", Gt]
      }, {
          no: 20,
          name: "decimals",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 21,
          name: "session_wallet",
          kind: "message",
          T: () => bi
      }, {
          no: 22,
          name: "media_type",
          kind: "scalar",
          T: 9
      }, {
          no: 23,
          name: "listed_timestamp",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 24,
          name: "dev_wallet",
          kind: "message",
          T: () => bi
      }])
  }
  create(e) {
      const t = {
          id: 0,
          telegramId: 0,
          description: "",
          listed: !1,
          settled: !1,
          x0: 0,
          sessionId: 0,
          mediaFileId: "",
          x: 0,
          y: 0,
          k: 0,
          fills: [],
          dailyNtlVolume: 0,
          previousDayPx: 0,
          lastEventTimestamp: 0,
          poolType: 0,
          decimals: 0,
          mediaType: "",
          listedTimestamp: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.telegramId = e.int64().toNumber();
                  break;
              case 3:
                  r.telegramUser = Ht.internalBinaryRead(e, e.uint32(), n, r.telegramUser);
                  break;
              case 4:
                  r.description = e.string();
                  break;
              case 5:
                  r.listed = e.bool();
                  break;
              case 6:
                  r.settled = e.bool();
                  break;
              case 7:
                  r.x0 = e.int64().toNumber();
                  break;
              case 8:
                  r.sessionId = e.int64().toNumber();
                  break;
              case 9:
                  r.session = Ut.internalBinaryRead(e, e.uint32(), n, r.session);
                  break;
              case 10:
                  r.mediaFileId = e.string();
                  break;
              case 11:
                  r.topicId = be.internalBinaryRead(e, e.uint32(), n, r.topicId);
                  break;
              case 12:
                  r.x = e.int64().toNumber();
                  break;
              case 13:
                  r.y = e.int64().toNumber();
                  break;
              case 14:
                  r.k = e.int64().toNumber();
                  break;
              case 15:
                  r.fills.push(Ei.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 16:
                  r.dailyNtlVolume = e.double();
                  break;
              case 17:
                  r.previousDayPx = e.double();
                  break;
              case 18:
                  r.lastEventTimestamp = e.int64().toNumber();
                  break;
              case 19:
                  r.poolType = e.int32();
                  break;
              case 20:
                  r.decimals = e.int64().toNumber();
                  break;
              case 21:
                  r.sessionWallet = bi.internalBinaryRead(e, e.uint32(), n, r.sessionWallet);
                  break;
              case 22:
                  r.mediaType = e.string();
                  break;
              case 23:
                  r.listedTimestamp = e.int64().toNumber();
                  break;
              case 24:
                  r.devWallet = bi.internalBinaryRead(e, e.uint32(), n, r.devWallet);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.telegramId !== 0 && t.tag(2, v.Varint).int64(e.telegramId), e.telegramUser && Ht.internalBinaryWrite(e.telegramUser, t.tag(3, v.LengthDelimited).fork(), n).join(), e.description !== "" && t.tag(4, v.LengthDelimited).string(e.description), e.listed !== !1 && t.tag(5, v.Varint).bool(e.listed), e.settled !== !1 && t.tag(6, v.Varint).bool(e.settled), e.x0 !== 0 && t.tag(7, v.Varint).int64(e.x0), e.sessionId !== 0 && t.tag(8, v.Varint).int64(e.sessionId), e.session && Ut.internalBinaryWrite(e.session, t.tag(9, v.LengthDelimited).fork(), n).join(), e.mediaFileId !== "" && t.tag(10, v.LengthDelimited).string(e.mediaFileId), e.topicId && be.internalBinaryWrite(e.topicId, t.tag(11, v.LengthDelimited).fork(), n).join(), e.x !== 0 && t.tag(12, v.Varint).int64(e.x), e.y !== 0 && t.tag(13, v.Varint).int64(e.y), e.k !== 0 && t.tag(14, v.Varint).int64(e.k);
      for (let r = 0; r < e.fills.length; r++) Ei.internalBinaryWrite(e.fills[r], t.tag(15, v.LengthDelimited).fork(), n).join();
      e.dailyNtlVolume !== 0 && t.tag(16, v.Bit64).double(e.dailyNtlVolume), e.previousDayPx !== 0 && t.tag(17, v.Bit64).double(e.previousDayPx), e.lastEventTimestamp !== 0 && t.tag(18, v.Varint).int64(e.lastEventTimestamp), e.poolType !== 0 && t.tag(19, v.Varint).int32(e.poolType), e.decimals !== 0 && t.tag(20, v.Varint).int64(e.decimals), e.sessionWallet && bi.internalBinaryWrite(e.sessionWallet, t.tag(21, v.LengthDelimited).fork(), n).join(), e.mediaType !== "" && t.tag(22, v.LengthDelimited).string(e.mediaType), e.listedTimestamp !== 0 && t.tag(23, v.Varint).int64(e.listedTimestamp), e.devWallet && bi.internalBinaryWrite(e.devWallet, t.tag(24, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const jt = new Wv;
class Uv extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchFill", [{
          no: 1,
          name: "launch_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "telegram_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "telegram",
          kind: "message",
          T: () => Ht
      }, {
          no: 4,
          name: "wallet",
          kind: "message",
          T: () => bi
      }, {
          no: 5,
          name: "usdc_delta",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 6,
          name: "launch_delta",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 7,
          name: "timestamp",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 8,
          name: "movement_hash",
          kind: "message",
          T: () => ot
      }, {
          no: 9,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          launchId: 0,
          telegramId: 0,
          usdcDelta: 0,
          launchDelta: 0,
          timestamp: 0,
          id: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launchId = e.int64().toNumber();
                  break;
              case 2:
                  r.telegramId = e.int64().toNumber();
                  break;
              case 3:
                  r.telegram = Ht.internalBinaryRead(e, e.uint32(), n, r.telegram);
                  break;
              case 4:
                  r.wallet = bi.internalBinaryRead(e, e.uint32(), n, r.wallet);
                  break;
              case 5:
                  r.usdcDelta = e.int64().toNumber();
                  break;
              case 6:
                  r.launchDelta = e.int64().toNumber();
                  break;
              case 7:
                  r.timestamp = e.int64().toNumber();
                  break;
              case 8:
                  r.movementHash = ot.internalBinaryRead(e, e.uint32(), n, r.movementHash);
                  break;
              case 9:
                  r.id = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.launchId !== 0 && t.tag(1, v.Varint).int64(e.launchId), e.telegramId !== 0 && t.tag(2, v.Varint).int64(e.telegramId), e.telegram && Ht.internalBinaryWrite(e.telegram, t.tag(3, v.LengthDelimited).fork(), n).join(), e.wallet && bi.internalBinaryWrite(e.wallet, t.tag(4, v.LengthDelimited).fork(), n).join(), e.usdcDelta !== 0 && t.tag(5, v.Varint).int64(e.usdcDelta), e.launchDelta !== 0 && t.tag(6, v.Varint).int64(e.launchDelta), e.timestamp !== 0 && t.tag(7, v.Varint).int64(e.timestamp), e.movementHash && ot.internalBinaryWrite(e.movementHash, t.tag(8, v.LengthDelimited).fork(), n).join(), e.id !== 0 && t.tag(9, v.Varint).int64(e.id);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ei = new Uv;
class jv extends Z {
  constructor() {
      super("hypurr.TelegramUserPublic", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "username",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "picture_file_id",
          kind: "scalar",
          T: 9
      }, {
          no: 4,
          name: "reputation_score",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          id: 0,
          username: "",
          pictureFileId: "",
          reputationScore: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.username = e.string();
                  break;
              case 3:
                  r.pictureFileId = e.string();
                  break;
              case 4:
                  r.reputationScore = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.username !== "" && t.tag(2, v.LengthDelimited).string(e.username), e.pictureFileId !== "" && t.tag(3, v.LengthDelimited).string(e.pictureFileId), e.reputationScore !== 0 && t.tag(4, v.Varint).int64(e.reputationScore);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ht = new jv;
class Hv extends Z {
  constructor() {
      super("hypurr.HyperliquidDeployAuction", [{
          no: 1,
          name: "start_time",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "duration",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "start_gas",
          kind: "scalar",
          T: 1
      }, {
          no: 4,
          name: "current_gas",
          kind: "message",
          T: () => wn
      }, {
          no: 5,
          name: "end_gas",
          kind: "message",
          T: () => wn
      }])
  }
  create(e) {
      const t = {
          startTime: 0,
          duration: 0,
          startGas: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.startTime = e.int64().toNumber();
                  break;
              case 2:
                  r.duration = e.int64().toNumber();
                  break;
              case 3:
                  r.startGas = e.double();
                  break;
              case 4:
                  r.currentGas = wn.internalBinaryRead(e, e.uint32(), n, r.currentGas);
                  break;
              case 5:
                  r.endGas = wn.internalBinaryRead(e, e.uint32(), n, r.endGas);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.startTime !== 0 && t.tag(1, v.Varint).int64(e.startTime), e.duration !== 0 && t.tag(2, v.Varint).int64(e.duration), e.startGas !== 0 && t.tag(3, v.Bit64).double(e.startGas), e.currentGas && wn.internalBinaryWrite(e.currentGas, t.tag(4, v.LengthDelimited).fork(), n).join(), e.endGas && wn.internalBinaryWrite(e.endGas, t.tag(5, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Xa = new Hv;
class qv extends Z {
  constructor() {
      super("hypurr.HyperliquidDeployAuctionRequest", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Gv = new qv;
class Kv extends Z {
  constructor() {
      super("hypurr.HyperliquidDeployAuctionResponse", [{
          no: 1,
          name: "auction",
          kind: "message",
          T: () => Xa
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.auction = Xa.internalBinaryRead(e, e.uint32(), n, r.auction);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.auction && Xa.internalBinaryWrite(e.auction, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Xv = new Kv;
class Jv extends Z {
  constructor() {
      super("hypurr.HyperliquidTokensRequest", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Yv = new Jv;
class Qv extends Z {
  constructor() {
      super("hypurr.HyperliquidTokensResponse", [{
          no: 1,
          name: "tokens",
          kind: "message",
          repeat: 1,
          T: () => at
      }])
  }
  create(e) {
      const t = {
          tokens: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.tokens.push(at.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.tokens.length; r++) at.internalBinaryWrite(e.tokens[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Zv = new Qv;
class eb extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenMessage", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "timestamp",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "telegram_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 5,
          name: "author",
          kind: "message",
          T: () => Ht
      }, {
          no: 6,
          name: "chat_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 7,
          name: "topic_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 8,
          name: "message",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          id: 0,
          timestamp: 0,
          tokenId: 0,
          telegramId: 0,
          chatId: 0,
          topicId: 0,
          message: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.timestamp = e.int64().toNumber();
                  break;
              case 3:
                  r.tokenId = e.int64().toNumber();
                  break;
              case 4:
                  r.telegramId = e.int64().toNumber();
                  break;
              case 5:
                  r.author = Ht.internalBinaryRead(e, e.uint32(), n, r.author);
                  break;
              case 6:
                  r.chatId = e.int64().toNumber();
                  break;
              case 7:
                  r.topicId = e.int64().toNumber();
                  break;
              case 8:
                  r.message = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.timestamp !== 0 && t.tag(2, v.Varint).int64(e.timestamp), e.tokenId !== 0 && t.tag(3, v.Varint).int64(e.tokenId), e.telegramId !== 0 && t.tag(4, v.Varint).int64(e.telegramId), e.author && Ht.internalBinaryWrite(e.author, t.tag(5, v.LengthDelimited).fork(), n).join(), e.chatId !== 0 && t.tag(6, v.Varint).int64(e.chatId), e.topicId !== 0 && t.tag(7, v.Varint).int64(e.topicId), e.message !== "" && t.tag(8, v.LengthDelimited).string(e.message);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ja = new eb;
class tb extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenMessagesRequest", [{
          no: 1,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          tokenId: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.tokenId = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.tokenId !== 0 && t.tag(1, v.Varint).int64(e.tokenId);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ib = new tb;
class nb extends Z {
  constructor() {
      super("hypurr.HyperliquidTokenMessagesResponse", [{
          no: 1,
          name: "messages",
          kind: "message",
          repeat: 1,
          T: () => Ja
      }])
  }
  create(e) {
      const t = {
          messages: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.messages.push(Ja.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.messages.length; r++) Ja.internalBinaryWrite(e.messages[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const sb = new nb;
class rb extends Z {
  constructor() {
      super("hypurr.HyperliquidSpotPairRequest", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          id: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ab = new rb;
class lb extends Z {
  constructor() {
      super("hypurr.HyperliquidSpotPairResponse", [{
          no: 1,
          name: "pair",
          kind: "message",
          T: () => Mn
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.pair = Mn.internalBinaryRead(e, e.uint32(), n, r.pair);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.pair && Mn.internalBinaryWrite(e.pair, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ob = new lb;
class ub extends Z {
  constructor() {
      super("hypurr.HyperliquidSpotPairsRequest", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const cb = new ub;
class hb extends Z {
  constructor() {
      super("hypurr.HyperliquidSpotPairsResponse", [{
          no: 1,
          name: "pairs",
          kind: "message",
          repeat: 1,
          T: () => Mn
      }])
  }
  create(e) {
      const t = {
          pairs: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.pairs.push(Mn.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.pairs.length; r++) Mn.internalBinaryWrite(e.pairs[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const db = new hb;
class fb extends Z {
  constructor() {
      super("hypurr.HyperliquidPerpPairsRequest", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const pb = new fb;
class mb extends Z {
  constructor() {
      super("hypurr.HyperliquidPerpPairsResponse", [{
          no: 1,
          name: "pairs",
          kind: "message",
          repeat: 1,
          T: () => Ga
      }])
  }
  create(e) {
      const t = {
          pairs: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.pairs.push(Ga.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.pairs.length; r++) Ga.internalBinaryWrite(e.pairs[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const gb = new mb;
class yb extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletRequest", [{
          no: 1,
          name: "ethereum_address",
          kind: "message",
          T: () => ot
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.ethereumAddress = ot.internalBinaryRead(e, e.uint32(), n, r.ethereumAddress);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.ethereumAddress && ot.internalBinaryWrite(e.ethereumAddress, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const vb = new yb;
class bb extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletResponse", [{
          no: 1,
          name: "wallet",
          kind: "message",
          T: () => Ve
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.wallet = Ve.internalBinaryRead(e, e.uint32(), n, r.wallet);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.wallet && Ve.internalBinaryWrite(e.wallet, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const wb = new bb;
class kb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchesRequest", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const _b = new kb;
class xb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchesResponse", [{
          no: 1,
          name: "launches",
          kind: "message",
          repeat: 1,
          T: () => jt
      }])
  }
  create(e) {
      const t = {
          launches: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launches.push(jt.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.launches.length; r++) jt.internalBinaryWrite(e.launches[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Tb = new xb;
class Sb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchStreamRequest", [{
          no: 1,
          name: "launch_id",
          kind: "message",
          T: () => be
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launchId = be.internalBinaryRead(e, e.uint32(), n, r.launchId);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.launchId && be.internalBinaryWrite(e.launchId, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Eb = new Sb;
class Cb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchStreamResponse", [{
          no: 1,
          name: "launches",
          kind: "message",
          repeat: 1,
          T: () => jt
      }])
  }
  create(e) {
      const t = {
          launches: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launches.push(jt.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.launches.length; r++) jt.internalBinaryWrite(e.launches[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const $b = new Cb;
class Lb extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletDeploySessionsRequest", [{
          no: 1,
          name: "telegram_id",
          kind: "message",
          T: () => be
      }, {
          no: 2,
          name: "wallet_id",
          kind: "message",
          T: () => be
      }, {
          no: 3,
          name: "session_id",
          kind: "message",
          T: () => be
      }, {
          no: 4,
          name: "ethereum_address",
          kind: "message",
          T: () => ot
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.telegramId = be.internalBinaryRead(e, e.uint32(), n, r.telegramId);
                  break;
              case 2:
                  r.walletId = be.internalBinaryRead(e, e.uint32(), n, r.walletId);
                  break;
              case 3:
                  r.sessionId = be.internalBinaryRead(e, e.uint32(), n, r.sessionId);
                  break;
              case 4:
                  r.ethereumAddress = ot.internalBinaryRead(e, e.uint32(), n, r.ethereumAddress);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.telegramId && be.internalBinaryWrite(e.telegramId, t.tag(1, v.LengthDelimited).fork(), n).join(), e.walletId && be.internalBinaryWrite(e.walletId, t.tag(2, v.LengthDelimited).fork(), n).join(), e.sessionId && be.internalBinaryWrite(e.sessionId, t.tag(3, v.LengthDelimited).fork(), n).join(), e.ethereumAddress && ot.internalBinaryWrite(e.ethereumAddress, t.tag(4, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Pb = new Lb;
class Ib extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletDeploySessionsResponse", [{
          no: 1,
          name: "sessions",
          kind: "message",
          repeat: 1,
          T: () => Ut
      }])
  }
  create(e) {
      const t = {
          sessions: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.sessions.push(Ut.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.sessions.length; r++) Ut.internalBinaryWrite(e.sessions[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Nb = new Ib;
class Mb extends Z {
  constructor() {
      super("hypurr.SetHyperliquidWalletDeploySessionTargetRequest", [{
          no: 1,
          name: "ethereum_address",
          kind: "message",
          T: () => ot
      }, {
          no: 2,
          name: "session_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "name",
          kind: "scalar",
          T: 9
      }, {
          no: 4,
          name: "target",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "share",
          kind: "scalar",
          T: 5
      }])
  }
  create(e) {
      const t = {
          sessionId: 0,
          name: "",
          target: "",
          share: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.ethereumAddress = ot.internalBinaryRead(e, e.uint32(), n, r.ethereumAddress);
                  break;
              case 2:
                  r.sessionId = e.int64().toNumber();
                  break;
              case 3:
                  r.name = e.string();
                  break;
              case 4:
                  r.target = e.string();
                  break;
              case 5:
                  r.share = e.int32();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.ethereumAddress && ot.internalBinaryWrite(e.ethereumAddress, t.tag(1, v.LengthDelimited).fork(), n).join(), e.sessionId !== 0 && t.tag(2, v.Varint).int64(e.sessionId), e.name !== "" && t.tag(3, v.LengthDelimited).string(e.name), e.target !== "" && t.tag(4, v.LengthDelimited).string(e.target), e.share !== 0 && t.tag(5, v.Varint).int32(e.share);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Rb = new Mb;
class Bb extends Z {
  constructor() {
      super("hypurr.SetHyperliquidWalletDeploySessionTargetResponse", [{
          no: 1,
          name: "session",
          kind: "message",
          T: () => Ut
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.session = Ut.internalBinaryRead(e, e.uint32(), n, r.session);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.session && Ut.internalBinaryWrite(e.session, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ob = new Bb;
class Db extends Z {
  constructor() {
      super("hypurr.DeleteHyperliquidWalletDeploySessionTargetRequest", [{
          no: 1,
          name: "ethereum_address",
          kind: "message",
          T: () => ot
      }, {
          no: 2,
          name: "session_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "name",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          sessionId: 0,
          name: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.ethereumAddress = ot.internalBinaryRead(e, e.uint32(), n, r.ethereumAddress);
                  break;
              case 2:
                  r.sessionId = e.int64().toNumber();
                  break;
              case 3:
                  r.name = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.ethereumAddress && ot.internalBinaryWrite(e.ethereumAddress, t.tag(1, v.LengthDelimited).fork(), n).join(), e.sessionId !== 0 && t.tag(2, v.Varint).int64(e.sessionId), e.name !== "" && t.tag(3, v.LengthDelimited).string(e.name);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Fb = new Db;
class Ab extends Z {
  constructor() {
      super("hypurr.DeleteHyperliquidWalletDeploySessionTargetResponse", [{
          no: 1,
          name: "session",
          kind: "message",
          T: () => Ut
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.session = Ut.internalBinaryRead(e, e.uint32(), n, r.session);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.session && Ut.internalBinaryWrite(e.session, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Vb = new Ab;
class zb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchFillsRequest", [{
          no: 1,
          name: "launch_id",
          kind: "message",
          T: () => be
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launchId = be.internalBinaryRead(e, e.uint32(), n, r.launchId);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.launchId && be.internalBinaryWrite(e.launchId, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Wb = new zb;
class Ub extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchFillsResponse", [{
          no: 1,
          name: "fills",
          kind: "message",
          repeat: 1,
          T: () => Ei
      }, {
          no: 2,
          name: "positions",
          kind: "message",
          repeat: 1,
          T: () => Ya
      }])
  }
  create(e) {
      const t = {
          fills: [],
          positions: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.fills.push(Ei.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 2:
                  r.positions.push(Ya.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.fills.length; r++) Ei.internalBinaryWrite(e.fills[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.positions.length; r++) Ya.internalBinaryWrite(e.positions[r], t.tag(2, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Nc = new Ub;
class jb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchPosition", [{
          no: 1,
          name: "address",
          kind: "scalar",
          T: 9
      }, {
          no: 2,
          name: "balance",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "cost",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          address: "",
          balance: 0,
          cost: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.address = e.string();
                  break;
              case 2:
                  r.balance = e.int64().toNumber();
                  break;
              case 3:
                  r.cost = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.address !== "" && t.tag(1, v.LengthDelimited).string(e.address), e.balance !== 0 && t.tag(2, v.Varint).int64(e.balance), e.cost !== 0 && t.tag(3, v.Varint).int64(e.cost);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ya = new jb;
class Hb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchCandlesRequest", [{
          no: 1,
          name: "launch_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "interval",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          launchId: 0,
          interval: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launchId = e.int64().toNumber();
                  break;
              case 2:
                  r.interval = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.launchId !== 0 && t.tag(1, v.Varint).int64(e.launchId), e.interval !== "" && t.tag(2, v.LengthDelimited).string(e.interval);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Mc = new Hb;
class qb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchCandle", [{
          no: 1,
          name: "time",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "open",
          kind: "scalar",
          T: 2
      }, {
          no: 3,
          name: "high",
          kind: "scalar",
          T: 2
      }, {
          no: 4,
          name: "low",
          kind: "scalar",
          T: 2
      }, {
          no: 5,
          name: "close",
          kind: "scalar",
          T: 2
      }, {
          no: 6,
          name: "volume",
          kind: "scalar",
          T: 2
      }])
  }
  create(e) {
      const t = {
          time: 0,
          open: 0,
          high: 0,
          low: 0,
          close: 0,
          volume: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.time = e.int64().toNumber();
                  break;
              case 2:
                  r.open = e.float();
                  break;
              case 3:
                  r.high = e.float();
                  break;
              case 4:
                  r.low = e.float();
                  break;
              case 5:
                  r.close = e.float();
                  break;
              case 6:
                  r.volume = e.float();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.time !== 0 && t.tag(1, v.Varint).int64(e.time), e.open !== 0 && t.tag(2, v.Bit32).float(e.open), e.high !== 0 && t.tag(3, v.Bit32).float(e.high), e.low !== 0 && t.tag(4, v.Bit32).float(e.low), e.close !== 0 && t.tag(5, v.Bit32).float(e.close), e.volume !== 0 && t.tag(6, v.Bit32).float(e.volume);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Qa = new qb;
class Gb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchCandlesResponse", [{
          no: 1,
          name: "candles",
          kind: "message",
          repeat: 1,
          T: () => Qa
      }])
  }
  create(e) {
      const t = {
          candles: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.candles.push(Qa.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.candles.length; r++) Qa.internalBinaryWrite(e.candles[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Rc = new Gb;
class Kb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchRequest", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          id: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Xb = new Kb;
class Jb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchResponse", [{
          no: 1,
          name: "launch",
          kind: "message",
          T: () => jt
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launch = jt.internalBinaryRead(e, e.uint32(), n, r.launch);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.launch && jt.internalBinaryWrite(e.launch, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Yb = new Jb;
class Qb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchMessage", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "timestamp",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "launch_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "telegram_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 5,
          name: "author",
          kind: "message",
          T: () => Ht
      }, {
          no: 6,
          name: "chat_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 7,
          name: "topic_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 8,
          name: "message",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          id: 0,
          timestamp: 0,
          launchId: 0,
          telegramId: 0,
          chatId: 0,
          topicId: 0,
          message: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.timestamp = e.int64().toNumber();
                  break;
              case 3:
                  r.launchId = e.int64().toNumber();
                  break;
              case 4:
                  r.telegramId = e.int64().toNumber();
                  break;
              case 5:
                  r.author = Ht.internalBinaryRead(e, e.uint32(), n, r.author);
                  break;
              case 6:
                  r.chatId = e.int64().toNumber();
                  break;
              case 7:
                  r.topicId = e.int64().toNumber();
                  break;
              case 8:
                  r.message = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.timestamp !== 0 && t.tag(2, v.Varint).int64(e.timestamp), e.launchId !== 0 && t.tag(3, v.Varint).int64(e.launchId), e.telegramId !== 0 && t.tag(4, v.Varint).int64(e.telegramId), e.author && Ht.internalBinaryWrite(e.author, t.tag(5, v.LengthDelimited).fork(), n).join(), e.chatId !== 0 && t.tag(6, v.Varint).int64(e.chatId), e.topicId !== 0 && t.tag(7, v.Varint).int64(e.topicId), e.message !== "" && t.tag(8, v.LengthDelimited).string(e.message);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Za = new Qb;
class Zb extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchMessagesRequest", [{
          no: 1,
          name: "launch_id",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          launchId: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launchId = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.launchId !== 0 && t.tag(1, v.Varint).int64(e.launchId);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ew = new Zb;
class tw extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchMessagesResponse", [{
          no: 1,
          name: "messages",
          kind: "message",
          repeat: 1,
          T: () => Za
      }])
  }
  create(e) {
      const t = {
          messages: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.messages.push(Za.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.messages.length; r++) Za.internalBinaryWrite(e.messages[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const iw = new tw;
class nw extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchHolder", [{
          no: 1,
          name: "balance",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "address",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "type",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          balance: 0,
          address: "",
          type: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.balance = e.int64().toNumber();
                  break;
              case 2:
                  r.address = e.string();
                  break;
              case 3:
                  r.type = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.balance !== 0 && t.tag(1, v.Varint).int64(e.balance), e.address !== "" && t.tag(2, v.LengthDelimited).string(e.address), e.type !== "" && t.tag(3, v.LengthDelimited).string(e.type);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const el = new nw;
class sw extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchHoldersRequest", [{
          no: 1,
          name: "launch_id",
          kind: "scalar",
          T: 3,
          L: 2
      }])
  }
  create(e) {
      const t = {
          launchId: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.launchId = e.int64().toNumber();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.launchId !== 0 && t.tag(1, v.Varint).int64(e.launchId);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const rw = new sw;
class aw extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchHoldersResponse", [{
          no: 1,
          name: "holders",
          kind: "message",
          repeat: 1,
          T: () => el
      }])
  }
  create(e) {
      const t = {
          holders: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.holders.push(el.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.holders.length; r++) el.internalBinaryWrite(e.holders[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const lw = new aw;
class ow extends Z {
  constructor() {
      super("hypurr.LatestHyperliquidLaunchFillsRequest", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const uw = new ow;
class cw extends Z {
  constructor() {
      super("hypurr.TelegramUser", [{
          no: 1,
          name: "telegram_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "telegram_username",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "pending_fees",
          kind: "scalar",
          T: 1
      }, {
          no: 4,
          name: "referral_rewards",
          kind: "scalar",
          T: 1
      }, {
          no: 5,
          name: "referral_code",
          kind: "scalar",
          T: 9
      }, {
          no: 6,
          name: "referral_score",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 7,
          name: "referrer_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 8,
          name: "settings",
          kind: "message",
          T: () => il
      }, {
          no: 9,
          name: "wallet",
          kind: "message",
          T: () => Ve
      }, {
          no: 10,
          name: "wallets",
          kind: "message",
          repeat: 1,
          T: () => Ve
      }, {
          no: 11,
          name: "wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 12,
          name: "sniper_wallet",
          kind: "message",
          T: () => Ve
      }, {
          no: 13,
          name: "sniper_wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 14,
          name: "dumper_wallet",
          kind: "message",
          T: () => Ve
      }, {
          no: 15,
          name: "dumper_wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 16,
          name: "reputation_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 17,
          name: "reputation",
          kind: "message",
          T: () => nl
      }, {
          no: 18,
          name: "launches",
          kind: "message",
          repeat: 1,
          T: () => jt
      }, {
          no: 19,
          name: "balances",
          kind: "message",
          repeat: 1,
          T: () => Bn
      }, {
          no: 20,
          name: "movements",
          kind: "message",
          repeat: 1,
          T: () => Rn
      }, {
          no: 21,
          name: "launch_fills",
          kind: "message",
          repeat: 1,
          T: () => Ei
      }, {
          no: 22,
          name: "labels",
          kind: "message",
          repeat: 1,
          T: () => sl
      }])
  }
  create(e) {
      const t = {
          telegramId: 0,
          telegramUsername: "",
          pendingFees: 0,
          referralRewards: 0,
          referralCode: "",
          referralScore: 0,
          referrerId: 0,
          wallets: [],
          walletId: 0,
          sniperWalletId: 0,
          dumperWalletId: 0,
          reputationId: 0,
          launches: [],
          balances: [],
          movements: [],
          launchFills: [],
          labels: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.telegramId = e.int64().toNumber();
                  break;
              case 2:
                  r.telegramUsername = e.string();
                  break;
              case 3:
                  r.pendingFees = e.double();
                  break;
              case 4:
                  r.referralRewards = e.double();
                  break;
              case 5:
                  r.referralCode = e.string();
                  break;
              case 6:
                  r.referralScore = e.int64().toNumber();
                  break;
              case 7:
                  r.referrerId = e.int64().toNumber();
                  break;
              case 8:
                  r.settings = il.internalBinaryRead(e, e.uint32(), n, r.settings);
                  break;
              case 9:
                  r.wallet = Ve.internalBinaryRead(e, e.uint32(), n, r.wallet);
                  break;
              case 10:
                  r.wallets.push(Ve.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 11:
                  r.walletId = e.int64().toNumber();
                  break;
              case 12:
                  r.sniperWallet = Ve.internalBinaryRead(e, e.uint32(), n, r.sniperWallet);
                  break;
              case 13:
                  r.sniperWalletId = e.int64().toNumber();
                  break;
              case 14:
                  r.dumperWallet = Ve.internalBinaryRead(e, e.uint32(), n, r.dumperWallet);
                  break;
              case 15:
                  r.dumperWalletId = e.int64().toNumber();
                  break;
              case 16:
                  r.reputationId = e.int64().toNumber();
                  break;
              case 17:
                  r.reputation = nl.internalBinaryRead(e, e.uint32(), n, r.reputation);
                  break;
              case 18:
                  r.launches.push(jt.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 19:
                  r.balances.push(Bn.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 20:
                  r.movements.push(Rn.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 21:
                  r.launchFills.push(Ei.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 22:
                  r.labels.push(sl.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.telegramId !== 0 && t.tag(1, v.Varint).int64(e.telegramId), e.telegramUsername !== "" && t.tag(2, v.LengthDelimited).string(e.telegramUsername), e.pendingFees !== 0 && t.tag(3, v.Bit64).double(e.pendingFees), e.referralRewards !== 0 && t.tag(4, v.Bit64).double(e.referralRewards), e.referralCode !== "" && t.tag(5, v.LengthDelimited).string(e.referralCode), e.referralScore !== 0 && t.tag(6, v.Varint).int64(e.referralScore), e.referrerId !== 0 && t.tag(7, v.Varint).int64(e.referrerId), e.settings && il.internalBinaryWrite(e.settings, t.tag(8, v.LengthDelimited).fork(), n).join(), e.wallet && Ve.internalBinaryWrite(e.wallet, t.tag(9, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.wallets.length; r++) Ve.internalBinaryWrite(e.wallets[r], t.tag(10, v.LengthDelimited).fork(), n).join();
      e.walletId !== 0 && t.tag(11, v.Varint).int64(e.walletId), e.sniperWallet && Ve.internalBinaryWrite(e.sniperWallet, t.tag(12, v.LengthDelimited).fork(), n).join(), e.sniperWalletId !== 0 && t.tag(13, v.Varint).int64(e.sniperWalletId), e.dumperWallet && Ve.internalBinaryWrite(e.dumperWallet, t.tag(14, v.LengthDelimited).fork(), n).join(), e.dumperWalletId !== 0 && t.tag(15, v.Varint).int64(e.dumperWalletId), e.reputationId !== 0 && t.tag(16, v.Varint).int64(e.reputationId), e.reputation && nl.internalBinaryWrite(e.reputation, t.tag(17, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.launches.length; r++) jt.internalBinaryWrite(e.launches[r], t.tag(18, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.balances.length; r++) Bn.internalBinaryWrite(e.balances[r], t.tag(19, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.movements.length; r++) Rn.internalBinaryWrite(e.movements[r], t.tag(20, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.launchFills.length; r++) Ei.internalBinaryWrite(e.launchFills[r], t.tag(21, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.labels.length; r++) sl.internalBinaryWrite(e.labels[r], t.tag(22, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const tl = new cw;
class hw extends Z {
  constructor() {
      super("hypurr.TelegramUserSettings", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const il = new hw;
class dw extends Z {
  constructor() {
      super("hypurr.TelegramUserReputation", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const nl = new dw;
class fw extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletLabel", [{
          no: 1,
          name: "ethereum_address",
          kind: "scalar",
          T: 9
      }, {
          no: 2,
          name: "label",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          ethereumAddress: "",
          label: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.ethereumAddress = e.string();
                  break;
              case 2:
                  r.label = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.ethereumAddress !== "" && t.tag(1, v.LengthDelimited).string(e.ethereumAddress), e.label !== "" && t.tag(2, v.LengthDelimited).string(e.label);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const sl = new fw;
class pw extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletPerformanceRequest", [{
          no: 1,
          name: "ethereum_address",
          kind: "message",
          T: () => ot
      }, {
          no: 2,
          name: "account_type",
          kind: "scalar",
          T: 9
      }])
  }
  create(e) {
      const t = {
          accountType: ""
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.ethereumAddress = ot.internalBinaryRead(e, e.uint32(), n, r.ethereumAddress);
                  break;
              case 2:
                  r.accountType = e.string();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.ethereumAddress && ot.internalBinaryWrite(e.ethereumAddress, t.tag(1, v.LengthDelimited).fork(), n).join(), e.accountType !== "" && t.tag(2, v.LengthDelimited).string(e.accountType);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const mw = new pw;
class gw extends Z {
  constructor() {
      super("hypurr.PerformancePoint", [{
          no: 1,
          name: "time",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "notional",
          kind: "scalar",
          T: 2
      }, {
          no: 3,
          name: "pnl",
          kind: "scalar",
          T: 2
      }])
  }
  create(e) {
      const t = {
          time: 0,
          notional: 0,
          pnl: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.time = e.int64().toNumber();
                  break;
              case 2:
                  r.notional = e.float();
                  break;
              case 3:
                  r.pnl = e.float();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.time !== 0 && t.tag(1, v.Varint).int64(e.time), e.notional !== 0 && t.tag(2, v.Bit32).float(e.notional), e.pnl !== 0 && t.tag(3, v.Bit32).float(e.pnl);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const rl = new gw;
class yw extends Z {
  constructor() {
      super("hypurr.PerformanceReport", [{
          no: 1,
          name: "token_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "total_pnl",
          kind: "scalar",
          T: 2
      }, {
          no: 3,
          name: "running_pnl",
          kind: "scalar",
          T: 2
      }, {
          no: 4,
          name: "size",
          kind: "scalar",
          T: 2
      }, {
          no: 5,
          name: "price",
          kind: "scalar",
          T: 2
      }, {
          no: 6,
          name: "entry_price",
          kind: "scalar",
          T: 2
      }, {
          no: 7,
          name: "total_cost",
          kind: "scalar",
          T: 2
      }, {
          no: 8,
          name: "running_cost",
          kind: "scalar",
          T: 2
      }])
  }
  create(e) {
      const t = {
          tokenId: 0,
          totalPnl: 0,
          runningPnl: 0,
          size: 0,
          price: 0,
          entryPrice: 0,
          totalCost: 0,
          runningCost: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.tokenId = e.int64().toNumber();
                  break;
              case 2:
                  r.totalPnl = e.float();
                  break;
              case 3:
                  r.runningPnl = e.float();
                  break;
              case 4:
                  r.size = e.float();
                  break;
              case 5:
                  r.price = e.float();
                  break;
              case 6:
                  r.entryPrice = e.float();
                  break;
              case 7:
                  r.totalCost = e.float();
                  break;
              case 8:
                  r.runningCost = e.float();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.tokenId !== 0 && t.tag(1, v.Varint).int64(e.tokenId), e.totalPnl !== 0 && t.tag(2, v.Bit32).float(e.totalPnl), e.runningPnl !== 0 && t.tag(3, v.Bit32).float(e.runningPnl), e.size !== 0 && t.tag(4, v.Bit32).float(e.size), e.price !== 0 && t.tag(5, v.Bit32).float(e.price), e.entryPrice !== 0 && t.tag(6, v.Bit32).float(e.entryPrice), e.totalCost !== 0 && t.tag(7, v.Bit32).float(e.totalCost), e.runningCost !== 0 && t.tag(8, v.Bit32).float(e.runningCost);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const al = new yw;
class vw extends Z {
  constructor() {
      super("hypurr.Performance", [{
          no: 1,
          name: "net_cash",
          kind: "scalar",
          T: 2
      }, {
          no: 2,
          name: "notional",
          kind: "scalar",
          T: 2
      }, {
          no: 3,
          name: "reports",
          kind: "message",
          repeat: 1,
          T: () => al
      }, {
          no: 4,
          name: "points",
          kind: "message",
          repeat: 1,
          T: () => rl
      }])
  }
  create(e) {
      const t = {
          netCash: 0,
          notional: 0,
          reports: [],
          points: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.netCash = e.float();
                  break;
              case 2:
                  r.notional = e.float();
                  break;
              case 3:
                  r.reports.push(al.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 4:
                  r.points.push(rl.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.netCash !== 0 && t.tag(1, v.Bit32).float(e.netCash), e.notional !== 0 && t.tag(2, v.Bit32).float(e.notional);
      for (let r = 0; r < e.reports.length; r++) al.internalBinaryWrite(e.reports[r], t.tag(3, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.points.length; r++) rl.internalBinaryWrite(e.points[r], t.tag(4, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const gi = new vw;
class bw extends Z {
  constructor() {
      super("hypurr.HyperliquidWalletPerformanceResponse", [{
          no: 1,
          name: "spot",
          kind: "message",
          T: () => gi
      }, {
          no: 2,
          name: "perp",
          kind: "message",
          T: () => gi
      }, {
          no: 3,
          name: "launch",
          kind: "message",
          T: () => gi
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.spot = gi.internalBinaryRead(e, e.uint32(), n, r.spot);
                  break;
              case 2:
                  r.perp = gi.internalBinaryRead(e, e.uint32(), n, r.perp);
                  break;
              case 3:
                  r.launch = gi.internalBinaryRead(e, e.uint32(), n, r.launch);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.spot && gi.internalBinaryWrite(e.spot, t.tag(1, v.LengthDelimited).fork(), n).join(), e.perp && gi.internalBinaryWrite(e.perp, t.tag(2, v.LengthDelimited).fork(), n).join(), e.launch && gi.internalBinaryWrite(e.launch, t.tag(3, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ww = new bw;
class kw extends Z {
  constructor() {
      super("hypurr.HypurrFunCabal", [{
          no: 1,
          name: "telegram_chat_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "name",
          kind: "scalar",
          T: 9
      }, {
          no: 3,
          name: "picture_file_id",
          kind: "scalar",
          T: 9
      }, {
          no: 4,
          name: "users",
          kind: "message",
          repeat: 1,
          T: () => ol
      }, {
          no: 5,
          name: "tracked_wallets",
          kind: "message",
          repeat: 1,
          T: () => ul
      }, {
          no: 6,
          name: "user_seasons",
          kind: "message",
          repeat: 1,
          T: () => Dn
      }, {
          no: 7,
          name: "summary",
          kind: "message",
          T: () => ll
      }])
  }
  create(e) {
      const t = {
          telegramChatId: 0,
          name: "",
          pictureFileId: "",
          users: [],
          trackedWallets: [],
          userSeasons: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.telegramChatId = e.int64().toNumber();
                  break;
              case 2:
                  r.name = e.string();
                  break;
              case 3:
                  r.pictureFileId = e.string();
                  break;
              case 4:
                  r.users.push(ol.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 5:
                  r.trackedWallets.push(ul.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 6:
                  r.userSeasons.push(Dn.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 7:
                  r.summary = ll.internalBinaryRead(e, e.uint32(), n, r.summary);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.telegramChatId !== 0 && t.tag(1, v.Varint).int64(e.telegramChatId), e.name !== "" && t.tag(2, v.LengthDelimited).string(e.name), e.pictureFileId !== "" && t.tag(3, v.LengthDelimited).string(e.pictureFileId);
      for (let r = 0; r < e.users.length; r++) ol.internalBinaryWrite(e.users[r], t.tag(4, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.trackedWallets.length; r++) ul.internalBinaryWrite(e.trackedWallets[r], t.tag(5, v.LengthDelimited).fork(), n).join();
      for (let r = 0; r < e.userSeasons.length; r++) Dn.internalBinaryWrite(e.userSeasons[r], t.tag(6, v.LengthDelimited).fork(), n).join();
      e.summary && ll.internalBinaryWrite(e.summary, t.tag(7, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const On = new kw;
class _w extends Z {
  constructor() {
      super("hypurr.HypurrFunCabalSummary", [{
          no: 1,
          name: "user_count",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "season_spot_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 3,
          name: "season_perp_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 4,
          name: "season_launch_pnl",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          userCount: 0,
          seasonSpotPnl: 0,
          seasonPerpPnl: 0,
          seasonLaunchPnl: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.userCount = e.int64().toNumber();
                  break;
              case 2:
                  r.seasonSpotPnl = e.double();
                  break;
              case 3:
                  r.seasonPerpPnl = e.double();
                  break;
              case 4:
                  r.seasonLaunchPnl = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.userCount !== 0 && t.tag(1, v.Varint).int64(e.userCount), e.seasonSpotPnl !== 0 && t.tag(2, v.Bit64).double(e.seasonSpotPnl), e.seasonPerpPnl !== 0 && t.tag(3, v.Bit64).double(e.seasonPerpPnl), e.seasonLaunchPnl !== 0 && t.tag(4, v.Bit64).double(e.seasonLaunchPnl);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ll = new _w;
class xw extends Z {
  constructor() {
      super("hypurr.HypurrFunCabalUser", [{
          no: 1,
          name: "telegram_chat_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "telegram_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "wallet",
          kind: "message",
          T: () => Ve
      }, {
          no: 4,
          name: "wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 5,
          name: "name",
          kind: "scalar",
          T: 9
      }, {
          no: 6,
          name: "spot_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 7,
          name: "spot_equity",
          kind: "scalar",
          T: 1
      }, {
          no: 8,
          name: "launch_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 9,
          name: "launch_equity",
          kind: "scalar",
          T: 1
      }, {
          no: 10,
          name: "perp_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 11,
          name: "perp_equity",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          telegramChatId: 0,
          telegramId: 0,
          walletId: 0,
          name: "",
          spotPnl: 0,
          spotEquity: 0,
          launchPnl: 0,
          launchEquity: 0,
          perpPnl: 0,
          perpEquity: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.telegramChatId = e.int64().toNumber();
                  break;
              case 2:
                  r.telegramId = e.int64().toNumber();
                  break;
              case 3:
                  r.wallet = Ve.internalBinaryRead(e, e.uint32(), n, r.wallet);
                  break;
              case 4:
                  r.walletId = e.int64().toNumber();
                  break;
              case 5:
                  r.name = e.string();
                  break;
              case 6:
                  r.spotPnl = e.double();
                  break;
              case 7:
                  r.spotEquity = e.double();
                  break;
              case 8:
                  r.launchPnl = e.double();
                  break;
              case 9:
                  r.launchEquity = e.double();
                  break;
              case 10:
                  r.perpPnl = e.double();
                  break;
              case 11:
                  r.perpEquity = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.telegramChatId !== 0 && t.tag(1, v.Varint).int64(e.telegramChatId), e.telegramId !== 0 && t.tag(2, v.Varint).int64(e.telegramId), e.wallet && Ve.internalBinaryWrite(e.wallet, t.tag(3, v.LengthDelimited).fork(), n).join(), e.walletId !== 0 && t.tag(4, v.Varint).int64(e.walletId), e.name !== "" && t.tag(5, v.LengthDelimited).string(e.name), e.spotPnl !== 0 && t.tag(6, v.Bit64).double(e.spotPnl), e.spotEquity !== 0 && t.tag(7, v.Bit64).double(e.spotEquity), e.launchPnl !== 0 && t.tag(8, v.Bit64).double(e.launchPnl), e.launchEquity !== 0 && t.tag(9, v.Bit64).double(e.launchEquity), e.perpPnl !== 0 && t.tag(10, v.Bit64).double(e.perpPnl), e.perpEquity !== 0 && t.tag(11, v.Bit64).double(e.perpEquity);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ol = new xw;
class Tw extends Z {
  constructor() {
      super("hypurr.HypurrFunCabalTrackedWallet", [{
          no: 1,
          name: "telegram_chat_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "wallet",
          kind: "message",
          T: () => Ve
      }, {
          no: 4,
          name: "label",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "alert_spot",
          kind: "scalar",
          T: 8
      }, {
          no: 6,
          name: "alert_perp",
          kind: "scalar",
          T: 8
      }])
  }
  create(e) {
      const t = {
          telegramChatId: 0,
          walletId: 0,
          label: "",
          alertSpot: !1,
          alertPerp: !1
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.telegramChatId = e.int64().toNumber();
                  break;
              case 2:
                  r.walletId = e.int64().toNumber();
                  break;
              case 3:
                  r.wallet = Ve.internalBinaryRead(e, e.uint32(), n, r.wallet);
                  break;
              case 4:
                  r.label = e.string();
                  break;
              case 5:
                  r.alertSpot = e.bool();
                  break;
              case 6:
                  r.alertPerp = e.bool();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.telegramChatId !== 0 && t.tag(1, v.Varint).int64(e.telegramChatId), e.walletId !== 0 && t.tag(2, v.Varint).int64(e.walletId), e.wallet && Ve.internalBinaryWrite(e.wallet, t.tag(3, v.LengthDelimited).fork(), n).join(), e.label !== "" && t.tag(4, v.LengthDelimited).string(e.label), e.alertSpot !== !1 && t.tag(5, v.Varint).bool(e.alertSpot), e.alertPerp !== !1 && t.tag(6, v.Varint).bool(e.alertPerp);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const ul = new Tw;
class Sw extends Z {
  constructor() {
      super("hypurr.HypurrFunCabalSeason", [{
          no: 1,
          name: "id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "start_time",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "end_time",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "name",
          kind: "scalar",
          T: 9
      }, {
          no: 5,
          name: "user_seasons",
          kind: "message",
          repeat: 1,
          T: () => Dn
      }, {
          no: 6,
          name: "winner_id",
          kind: "message",
          T: () => be
      }, {
          no: 7,
          name: "winner",
          kind: "message",
          T: () => On
      }])
  }
  create(e) {
      const t = {
          id: 0,
          startTime: 0,
          endTime: 0,
          name: "",
          userSeasons: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.id = e.int64().toNumber();
                  break;
              case 2:
                  r.startTime = e.int64().toNumber();
                  break;
              case 3:
                  r.endTime = e.int64().toNumber();
                  break;
              case 4:
                  r.name = e.string();
                  break;
              case 5:
                  r.userSeasons.push(Dn.internalBinaryRead(e, e.uint32(), n));
                  break;
              case 6:
                  r.winnerId = be.internalBinaryRead(e, e.uint32(), n, r.winnerId);
                  break;
              case 7:
                  r.winner = On.internalBinaryRead(e, e.uint32(), n, r.winner);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.id !== 0 && t.tag(1, v.Varint).int64(e.id), e.startTime !== 0 && t.tag(2, v.Varint).int64(e.startTime), e.endTime !== 0 && t.tag(3, v.Varint).int64(e.endTime), e.name !== "" && t.tag(4, v.LengthDelimited).string(e.name);
      for (let r = 0; r < e.userSeasons.length; r++) Dn.internalBinaryWrite(e.userSeasons[r], t.tag(5, v.LengthDelimited).fork(), n).join();
      e.winnerId && be.internalBinaryWrite(e.winnerId, t.tag(6, v.LengthDelimited).fork(), n).join(), e.winner && On.internalBinaryWrite(e.winner, t.tag(7, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
new Sw;
class Ew extends Z {
  constructor() {
      super("hypurr.HypurrFunCabalUserSeason", [{
          no: 1,
          name: "cabal_season_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "telegram_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "telegram_chat_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 5,
          name: "spot_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 6,
          name: "launch_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 7,
          name: "perp_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 8,
          name: "last_spot_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 9,
          name: "last_launch_pnl",
          kind: "scalar",
          T: 1
      }, {
          no: 10,
          name: "last_perp_pnl",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          cabalSeasonId: 0,
          telegramId: 0,
          walletId: 0,
          telegramChatId: 0,
          spotPnl: 0,
          launchPnl: 0,
          perpPnl: 0,
          lastSpotPnl: 0,
          lastLaunchPnl: 0,
          lastPerpPnl: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.cabalSeasonId = e.int64().toNumber();
                  break;
              case 2:
                  r.telegramId = e.int64().toNumber();
                  break;
              case 3:
                  r.walletId = e.int64().toNumber();
                  break;
              case 4:
                  r.telegramChatId = e.int64().toNumber();
                  break;
              case 5:
                  r.spotPnl = e.double();
                  break;
              case 6:
                  r.launchPnl = e.double();
                  break;
              case 7:
                  r.perpPnl = e.double();
                  break;
              case 8:
                  r.lastSpotPnl = e.double();
                  break;
              case 9:
                  r.lastLaunchPnl = e.double();
                  break;
              case 10:
                  r.lastPerpPnl = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.cabalSeasonId !== 0 && t.tag(1, v.Varint).int64(e.cabalSeasonId), e.telegramId !== 0 && t.tag(2, v.Varint).int64(e.telegramId), e.walletId !== 0 && t.tag(3, v.Varint).int64(e.walletId), e.telegramChatId !== 0 && t.tag(4, v.Varint).int64(e.telegramChatId), e.spotPnl !== 0 && t.tag(5, v.Bit64).double(e.spotPnl), e.launchPnl !== 0 && t.tag(6, v.Bit64).double(e.launchPnl), e.perpPnl !== 0 && t.tag(7, v.Bit64).double(e.perpPnl), e.lastSpotPnl !== 0 && t.tag(8, v.Bit64).double(e.lastSpotPnl), e.lastLaunchPnl !== 0 && t.tag(9, v.Bit64).double(e.lastLaunchPnl), e.lastPerpPnl !== 0 && t.tag(10, v.Bit64).double(e.lastPerpPnl);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Dn = new Ew;
class Cw extends Z {
  constructor() {
      super("hypurr.HypurrFunCabalsRequest", [])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      return s ?? this.create()
  }
  internalBinaryWrite(e, t, n) {
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const $w = new Cw;
class Lw extends Z {
  constructor() {
      super("hypurr.HypurrFunCabalsResponse", [{
          no: 1,
          name: "cabals",
          kind: "message",
          repeat: 1,
          T: () => On
      }])
  }
  create(e) {
      const t = {
          cabals: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.cabals.push(On.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.cabals.length; r++) On.internalBinaryWrite(e.cabals[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Pw = new Lw;
class Iw extends Z {
  constructor() {
      super("hypurr.TelegramUserRequest", [{
          no: 1,
          name: "auth_data",
          kind: "map",
          K: 9,
          V: {
              kind: "scalar",
              T: 9
          }
      }])
  }
  create(e) {
      const t = {
          authData: {}
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  this.binaryReadMap1(r.authData, e, n);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  binaryReadMap1(e, t, n) {
      let s = t.uint32(),
          r = t.pos + s,
          a, l;
      for (; t.pos < r;) {
          let [o, u] = t.tag();
          switch (o) {
              case 1:
                  a = t.string();
                  break;
              case 2:
                  l = t.string();
                  break;
              default:
                  throw new globalThis.Error("unknown map entry field for field hypurr.TelegramUserRequest.auth_data")
          }
      }
      e[a ?? ""] = l ?? ""
  }
  internalBinaryWrite(e, t, n) {
      for (let r of Object.keys(e.authData)) t.tag(1, v.LengthDelimited).fork().tag(1, v.LengthDelimited).string(r).tag(2, v.LengthDelimited).string(e.authData[r]).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Nw = new Iw;
class Mw extends Z {
  constructor() {
      super("hypurr.TelegramUserResponse", [{
          no: 1,
          name: "user",
          kind: "message",
          T: () => tl
      }])
  }
  create(e) {
      const t = {};
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.user = tl.internalBinaryRead(e, e.uint32(), n, r.user);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.user && tl.internalBinaryWrite(e.user, t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Rw = new Mw;
class Bw extends Z {
  constructor() {
      super("hypurr.TelegramUserWalletsRequest", [{
          no: 1,
          name: "auth_data",
          kind: "map",
          K: 9,
          V: {
              kind: "scalar",
              T: 9
          }
      }])
  }
  create(e) {
      const t = {
          authData: {}
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  this.binaryReadMap1(r.authData, e, n);
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  binaryReadMap1(e, t, n) {
      let s = t.uint32(),
          r = t.pos + s,
          a, l;
      for (; t.pos < r;) {
          let [o, u] = t.tag();
          switch (o) {
              case 1:
                  a = t.string();
                  break;
              case 2:
                  l = t.string();
                  break;
              default:
                  throw new globalThis.Error("unknown map entry field for field hypurr.TelegramUserWalletsRequest.auth_data")
          }
      }
      e[a ?? ""] = l ?? ""
  }
  internalBinaryWrite(e, t, n) {
      for (let r of Object.keys(e.authData)) t.tag(1, v.LengthDelimited).fork().tag(1, v.LengthDelimited).string(r).tag(2, v.LengthDelimited).string(e.authData[r]).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ow = new Bw;
class Dw extends Z {
  constructor() {
      super("hypurr.TelegramUserWalletsResponse", [{
          no: 1,
          name: "wallets",
          kind: "message",
          repeat: 1,
          T: () => Ve
      }])
  }
  create(e) {
      const t = {
          wallets: []
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.wallets.push(Ve.internalBinaryRead(e, e.uint32(), n));
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      for (let r = 0; r < e.wallets.length; r++) Ve.internalBinaryWrite(e.wallets[r], t.tag(1, v.LengthDelimited).fork(), n).join();
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Fw = new Dw;
class Aw extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchTradeRequest", [{
          no: 1,
          name: "auth_data",
          kind: "map",
          K: 9,
          V: {
              kind: "scalar",
              T: 9
          }
      }, {
          no: 2,
          name: "launch_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 3,
          name: "wallet_id",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 4,
          name: "direction",
          kind: "enum",
          T: () => ["hypurr.HyperliquidLaunchTradeDirection", Hr]
      }, {
          no: 5,
          name: "amount",
          kind: "scalar",
          T: 1
      }])
  }
  create(e) {
      const t = {
          authData: {},
          launchId: 0,
          walletId: 0,
          direction: 0,
          amount: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  this.binaryReadMap1(r.authData, e, n);
                  break;
              case 2:
                  r.launchId = e.int64().toNumber();
                  break;
              case 3:
                  r.walletId = e.int64().toNumber();
                  break;
              case 4:
                  r.direction = e.int32();
                  break;
              case 5:
                  r.amount = e.double();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  binaryReadMap1(e, t, n) {
      let s = t.uint32(),
          r = t.pos + s,
          a, l;
      for (; t.pos < r;) {
          let [o, u] = t.tag();
          switch (o) {
              case 1:
                  a = t.string();
                  break;
              case 2:
                  l = t.string();
                  break;
              default:
                  throw new globalThis.Error("unknown map entry field for field hypurr.HyperliquidLaunchTradeRequest.auth_data")
          }
      }
      e[a ?? ""] = l ?? ""
  }
  internalBinaryWrite(e, t, n) {
      for (let r of Object.keys(e.authData)) t.tag(1, v.LengthDelimited).fork().tag(1, v.LengthDelimited).string(r).tag(2, v.LengthDelimited).string(e.authData[r]).join();
      e.launchId !== 0 && t.tag(2, v.Varint).int64(e.launchId), e.walletId !== 0 && t.tag(3, v.Varint).int64(e.walletId), e.direction !== 0 && t.tag(4, v.Varint).int32(e.direction), e.amount !== 0 && t.tag(5, v.Bit64).double(e.amount);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Vw = new Aw;
class zw extends Z {
  constructor() {
      super("hypurr.HyperliquidLaunchTradeResponse", [{
          no: 1,
          name: "base_amount",
          kind: "scalar",
          T: 1
      }, {
          no: 2,
          name: "quote_amount",
          kind: "scalar",
          T: 1
      }, {
          no: 3,
          name: "message",
          kind: "scalar",
          T: 9
      }, {
          no: 4,
          name: "success",
          kind: "scalar",
          T: 8
      }])
  }
  create(e) {
      const t = {
          baseAmount: 0,
          quoteAmount: 0,
          message: "",
          success: !1
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.baseAmount = e.double();
                  break;
              case 2:
                  r.quoteAmount = e.double();
                  break;
              case 3:
                  r.message = e.string();
                  break;
              case 4:
                  r.success = e.bool();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.baseAmount !== 0 && t.tag(1, v.Bit64).double(e.baseAmount), e.quoteAmount !== 0 && t.tag(2, v.Bit64).double(e.quoteAmount), e.message !== "" && t.tag(3, v.LengthDelimited).string(e.message), e.success !== !1 && t.tag(4, v.Varint).bool(e.success);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
const Ww = new zw,
  cl = new Zf("hypurr.Telegram", [{
      name: "TelegramUser",
      options: {},
      I: Nw,
      O: Rw
  }, {
      name: "TelegramUserWallets",
      options: {},
      I: Ow,
      O: Fw
  }, {
      name: "HyperliquidLaunchTrade",
      options: {},
      I: Vw,
      O: Ww
  }]),
  hl = new Zf("hypurr.Static", [{
      name: "HyperliquidDeployAuction",
      options: {},
      I: Gv,
      O: Xv
  }, {
      name: "HyperliquidTokens",
      options: {},
      I: Yv,
      O: Zv
  }, {
      name: "HyperliquidTokenHolders",
      options: {},
      I: Cv,
      O: Lv
  }, {
      name: "HyperliquidTokenMessages",
      serverStreaming: !0,
      options: {},
      I: ib,
      O: sb
  }, {
      name: "HyperliquidSpotPair",
      options: {},
      I: ab,
      O: ob
  }, {
      name: "HyperliquidSpotPairs",
      options: {},
      I: cb,
      O: db
  }, {
      name: "HyperliquidPerpPairs",
      options: {},
      I: pb,
      O: gb
  }, {
      name: "HyperliquidWallet",
      options: {},
      I: vb,
      O: wb
  }, {
      name: "HyperliquidWalletDeploySessions",
      options: {},
      I: Pb,
      O: Nb
  }, {
      name: "HyperliquidWalletPerformance",
      options: {},
      I: mw,
      O: ww
  }, {
      name: "HyperliquidLaunch",
      options: {},
      I: Xb,
      O: Yb
  }, {
      name: "HyperliquidLaunches",
      options: {},
      I: _b,
      O: Tb
  }, {
      name: "HyperliquidLaunchStream",
      serverStreaming: !0,
      options: {},
      I: Eb,
      O: $b
  }, {
      name: "HyperliquidLaunchFills",
      serverStreaming: !0,
      options: {},
      I: Wb,
      O: Nc
  }, {
      name: "HyperliquidLaunchCandles",
      options: {},
      I: Mc,
      O: Rc
  }, {
      name: "HyperliquidLaunchCandleStream",
      serverStreaming: !0,
      options: {},
      I: Mc,
      O: Rc
  }, {
      name: "HyperliquidLaunchMessages",
      serverStreaming: !0,
      options: {},
      I: ew,
      O: iw
  }, {
      name: "LatestHyperliquidLaunchFills",
      serverStreaming: !0,
      options: {},
      I: uw,
      O: Nc
  }, {
      name: "HyperliquidLaunchHolders",
      options: {},
      I: rw,
      O: lw
  }, {
      name: "HypurrFunCabals",
      options: {},
      I: $w,
      O: Pw
  }, {
      name: "SetHyperliquidWalletDeploySessionTarget",
      options: {},
      I: Rb,
      O: Ob
  }, {
      name: "DeleteHyperliquidWalletDeploySessionTarget",
      options: {},
      I: Fb,
      O: Vb
  }]);
class Uw {
  constructor(e) {
      this._transport = e
  }
  typeName = cl.typeName;
  methods = cl.methods;
  options = cl.options;
  telegramUser(e, t) {
      const n = this.methods[0],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  telegramUserWallets(e, t) {
      const n = this.methods[1],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidLaunchTrade(e, t) {
      const n = this.methods[2],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
}
class ep {
  constructor(e) {
      this._transport = e
  }
  typeName = hl.typeName;
  methods = hl.methods;
  options = hl.options;
  hyperliquidDeployAuction(e, t) {
      const n = this.methods[0],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidTokens(e, t) {
      const n = this.methods[1],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidTokenHolders(e, t) {
      const n = this.methods[2],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidTokenMessages(e, t) {
      const n = this.methods[3],
          s = this._transport.mergeOptions(t);
      return qe("serverStreaming", this._transport, n, s, e)
  }
  hyperliquidSpotPair(e, t) {
      const n = this.methods[4],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidSpotPairs(e, t) {
      const n = this.methods[5],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidPerpPairs(e, t) {
      const n = this.methods[6],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidWallet(e, t) {
      const n = this.methods[7],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidWalletDeploySessions(e, t) {
      const n = this.methods[8],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidWalletPerformance(e, t) {
      const n = this.methods[9],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidLaunch(e, t) {
      const n = this.methods[10],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidLaunches(e, t) {
      const n = this.methods[11],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidLaunchStream(e, t) {
      const n = this.methods[12],
          s = this._transport.mergeOptions(t);
      return qe("serverStreaming", this._transport, n, s, e)
  }
  hyperliquidLaunchFills(e, t) {
      const n = this.methods[13],
          s = this._transport.mergeOptions(t);
      return qe("serverStreaming", this._transport, n, s, e)
  }
  hyperliquidLaunchCandles(e, t) {
      const n = this.methods[14],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hyperliquidLaunchCandleStream(e, t) {
      const n = this.methods[15],
          s = this._transport.mergeOptions(t);
      return qe("serverStreaming", this._transport, n, s, e)
  }
  hyperliquidLaunchMessages(e, t) {
      const n = this.methods[16],
          s = this._transport.mergeOptions(t);
      return qe("serverStreaming", this._transport, n, s, e)
  }
  latestHyperliquidLaunchFills(e, t) {
      const n = this.methods[17],
          s = this._transport.mergeOptions(t);
      return qe("serverStreaming", this._transport, n, s, e)
  }
  hyperliquidLaunchHolders(e, t) {
      const n = this.methods[18],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  hypurrFunCabals(e, t) {
      const n = this.methods[19],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  setHyperliquidWalletDeploySessionTarget(e, t) {
      const n = this.methods[20],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
  deleteHyperliquidWalletDeploySessionTarget(e, t) {
      const n = this.methods[21],
          s = this._transport.mergeOptions(t);
      return qe("unary", this._transport, n, s, e)
  }
}
var oe;
(function(i) {
  i[i.OK = 0] = "OK", i[i.CANCELLED = 1] = "CANCELLED", i[i.UNKNOWN = 2] = "UNKNOWN", i[i.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", i[i.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", i[i.NOT_FOUND = 5] = "NOT_FOUND", i[i.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", i[i.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", i[i.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", i[i.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", i[i.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", i[i.ABORTED = 10] = "ABORTED", i[i.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", i[i.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", i[i.INTERNAL = 13] = "INTERNAL", i[i.UNAVAILABLE = 14] = "UNAVAILABLE", i[i.DATA_LOSS = 15] = "DATA_LOSS"
})(oe || (oe = {}));
var jw = globalThis && globalThis.__awaiter || function(i, e, t, n) {
  function s(r) {
      return r instanceof t ? r : new t(function(a) {
          a(r)
      })
  }
  return new(t || (t = Promise))(function(r, a) {
      function l(c) {
          try {
              u(n.next(c))
          } catch (h) {
              a(h)
          }
      }

      function o(c) {
          try {
              u(n.throw(c))
          } catch (h) {
              a(h)
          }
      }

      function u(c) {
          c.done ? r(c.value) : s(c.value).then(l, o)
      }
      u((n = n.apply(i, e || [])).next())
  })
};

function Bc(i, e, t, n, s) {
  if (n)
      for (let [r, a] of Object.entries(n))
          if (typeof a == "string") i.append(r, a);
          else
              for (let l of a) i.append(r, l);
  if (i.set("Content-Type", e === "text" ? "application/grpc-web-text" : "application/grpc-web+proto"), e == "text" && i.set("Accept", "application/grpc-web-text"), i.set("X-Grpc-Web", "1"), s && i.set("X-User-Agent", s), typeof t == "number") {
      if (t <= 0) throw new Fe(`timeout ${t} ms exceeded`, oe[oe.DEADLINE_EXCEEDED]);
      i.set("grpc-timeout", `${t}m`)
  } else if (t) {
      const r = t.getTime(),
          a = Date.now();
      if (r <= a) throw new Fe(`deadline ${t} exceeded`, oe[oe.DEADLINE_EXCEEDED]);
      i.set("grpc-timeout", `${r-a}m`)
  }
  return i
}

function Oc(i, e) {
  let t = new Uint8Array(5 + i.length);
  t[0] = Yt.DATA;
  for (let n = i.length, s = 4; s > 0; s--) t[s] = n % 256, n >>>= 8;
  return t.set(i, 5), e === "binary" ? t : Gf(t)
}

function oo(i, e, t) {
  if (arguments.length === 1) {
      let o = i,
          u;
      try {
          u = o.type
      } catch {}
      switch (u) {
          case "error":
          case "opaque":
          case "opaqueredirect":
              throw new Fe(`fetch response type ${o.type}`, oe[oe.UNKNOWN])
      }
      return oo(Kw(o.headers), o.status, o.statusText)
  }
  let n = i,
      s = e >= 200 && e < 300,
      r = ip(n),
      [a, l] = tp(n);
  return (a === void 0 || a === oe.OK) && !s && (a = Xw(e), l = t), [a, l, r]
}

function Dc(i) {
  let e = Gw(i),
      [t, n] = tp(e),
      s = ip(e);
  return [t ?? oe.OK, n, s]
}
var Yt;
(function(i) {
  i[i.DATA = 0] = "DATA", i[i.TRAILER = 128] = "TRAILER"
})(Yt || (Yt = {}));

function Fc(i, e, t) {
  return jw(this, void 0, void 0, function*() {
      let n, s = "",
          r = new Uint8Array(0),
          a = qw(e);
      if (Hw(i)) {
          let l = i.getReader();
          n = {
              next: () => l.read()
          }
      } else n = i[Symbol.asyncIterator]();
      for (;;) {
          let l = yield n.next();
          if (l.value !== void 0) {
              if (a === "text") {
                  for (let u = 0; u < l.value.length; u++) s += String.fromCharCode(l.value[u]);
                  let o = s.length - s.length % 4;
                  if (o === 0) continue;
                  r = Ac(r, qf(s.substring(0, o))), s = s.substring(o)
              } else r = Ac(r, l.value);
              for (; r.length >= 5 && r[0] === Yt.DATA;) {
                  let o = 0;
                  for (let u = 1; u < 5; u++) o = (o << 8) + r[u];
                  if (r.length - 5 >= o) t(Yt.DATA, r.subarray(5, 5 + o)), r = r.subarray(5 + o);
                  else break
              }
          }
          if (l.done) {
              if (r.length === 0) break;
              if (r[0] !== Yt.TRAILER || r.length < 5) throw new Fe("premature EOF", oe[oe.DATA_LOSS]);
              t(Yt.TRAILER, r.subarray(5));
              break
          }
      }
  })
}
const Hw = i => typeof i.getReader == "function";

function Ac(i, e) {
  let t = new Uint8Array(i.length + e.length);
  return t.set(i), t.set(e, i.length), t
}

function qw(i) {
  switch (i) {
      case "application/grpc-web-text":
      case "application/grpc-web-text+proto":
          return "text";
      case "application/grpc-web":
      case "application/grpc-web+proto":
          return "binary";
      case void 0:
      case null:
          throw new Fe("missing response content type", oe[oe.INTERNAL]);
      default:
          throw new Fe("unexpected response content type: " + i, oe[oe.INTERNAL])
  }
}

function tp(i) {
  let e, t, n = i["grpc-message"];
  if (n !== void 0) {
      if (Array.isArray(n)) return [oe.INTERNAL, "invalid grpc-web message"];
      t = n
  }
  let s = i["grpc-status"];
  if (s !== void 0) {
      if (Array.isArray(s)) return [oe.INTERNAL, "invalid grpc-web status"];
      if (e = parseInt(s, 10), oe[e] === void 0) return [oe.INTERNAL, "invalid grpc-web status"]
  }
  return [e, t]
}

function ip(i) {
  let e = {};
  for (let [t, n] of Object.entries(i)) switch (t) {
      case "grpc-message":
      case "grpc-status":
      case "content-type":
          break;
      default:
          e[t] = n
  }
  return e
}

function Gw(i) {
  let e = {};
  for (let t of String.fromCharCode.apply(String, i).trim().split(`\r
`)) {
      if (t == "") continue;
      let [n, ...s] = t.split(":");
      const r = s.join(":").trim();
      n = n.trim();
      let a = e[n];
      typeof a == "string" ? e[n] = [a, r] : Array.isArray(a) ? a.push(r) : e[n] = r
  }
  return e
}

function Kw(i) {
  let e = {};
  return i.forEach((t, n) => {
      let s = e[n];
      typeof s == "string" ? e[n] = [s, t] : Array.isArray(s) ? s.push(t) : e[n] = t
  }), e
}

function Xw(i) {
  switch (i) {
      case 200:
          return oe.OK;
      case 400:
          return oe.INVALID_ARGUMENT;
      case 401:
          return oe.UNAUTHENTICATED;
      case 403:
          return oe.PERMISSION_DENIED;
      case 404:
          return oe.NOT_FOUND;
      case 409:
          return oe.ABORTED;
      case 412:
          return oe.FAILED_PRECONDITION;
      case 429:
          return oe.RESOURCE_EXHAUSTED;
      case 499:
          return oe.CANCELLED;
      case 500:
          return oe.UNKNOWN;
      case 501:
          return oe.UNIMPLEMENTED;
      case 503:
          return oe.UNAVAILABLE;
      case 504:
          return oe.DEADLINE_EXCEEDED;
      default:
          return oe.UNKNOWN
  }
}
class cu {
  constructor(e) {
      this.defaultOptions = e
  }
  mergeOptions(e) {
      return uv(this.defaultOptions, e)
  }
  makeUrl(e, t) {
      let n = t.baseUrl;
      return n.endsWith("/") && (n = n.substring(0, n.length - 1)), `${n}/${e.service.typeName}/${e.name}`
  }
  clientStreaming(e) {
      const t = new Fe("Client streaming is not supported by grpc-web", oe[oe.UNIMPLEMENTED]);
      throw t.methodName = e.name, t.serviceName = e.service.typeName, t
  }
  duplex(e) {
      const t = new Fe("Duplex streaming is not supported by grpc-web", oe[oe.UNIMPLEMENTED]);
      throw t.methodName = e.name, t.serviceName = e.service.typeName, t
  }
  serverStreaming(e, t, n) {
      var s, r, a, l;
      let o = n,
          u = (s = o.format) !== null && s !== void 0 ? s : "text",
          c = (r = o.fetchInit) !== null && r !== void 0 ? r : {},
          h = this.makeUrl(e, o),
          d = e.I.toBinary(t, o.binaryOptions),
          f = new Ri,
          p = new cv,
          g = !0,
          w, y = new Ri,
          b, x = new Ri;
      return globalThis.fetch(h, Object.assign(Object.assign({}, c), {
          method: "POST",
          headers: Bc(new globalThis.Headers, u, o.timeout, o.meta),
          body: Oc(d, u),
          signal: (a = n.abort) !== null && a !== void 0 ? a : null
      })).then(k => {
          let [S, B, D] = oo(k);
          if (f.resolve(D), S != null && S !== oe.OK) throw new Fe(B ?? oe[S], oe[S], D);
          return S != null && (w = {
              code: oe[S],
              detail: B ?? oe[S]
          }), k
      }).then(k => {
          if (!k.body) throw new Fe("missing response body", oe[oe.INTERNAL]);
          return Fc(k.body, k.headers.get("content-type"), (S, B) => {
              switch (S) {
                  case Yt.DATA:
                      p.notifyMessage(e.O.fromBinary(B, o.binaryOptions)), g = !1;
                      break;
                  case Yt.TRAILER:
                      let D, P;
                      [D, P, b] = Dc(B), w = {
                          code: oe[D],
                          detail: P ?? oe[D]
                      };
                      break
              }
          })
      }).then(() => {
          if (!b && !g) throw new Fe("missing trailers", oe[oe.DATA_LOSS]);
          if (!w) throw new Fe("missing status", oe[oe.INTERNAL]);
          if (w.code !== "OK") throw new Fe(w.detail, w.code, b);
          p.notifyComplete(), y.resolve(w), x.resolve(b || {})
      }).catch(k => {
          let S;
          k instanceof Fe ? S = k : k instanceof Error && k.name === "AbortError" ? S = new Fe(k.message, oe[oe.CANCELLED]) : S = new Fe(k instanceof Error ? k.message : "" + k, oe[oe.INTERNAL]), S.methodName = e.name, S.serviceName = e.service.typeName, f.rejectPending(S), p.notifyError(S), y.rejectPending(S), x.rejectPending(S)
      }), new pv(e, (l = o.meta) !== null && l !== void 0 ? l : {}, t, f.promise, p, y.promise, x.promise)
  }
  unary(e, t, n) {
      var s, r, a, l;
      let o = n,
          u = (s = o.format) !== null && s !== void 0 ? s : "text",
          c = (r = o.fetchInit) !== null && r !== void 0 ? r : {},
          h = this.makeUrl(e, o),
          d = e.I.toBinary(t, o.binaryOptions),
          f = new Ri,
          p, g = new Ri,
          w, y = new Ri,
          b, x = new Ri;
      return globalThis.fetch(h, Object.assign(Object.assign({}, c), {
          method: "POST",
          headers: Bc(new globalThis.Headers, u, o.timeout, o.meta),
          body: Oc(d, u),
          signal: (a = n.abort) !== null && a !== void 0 ? a : null
      })).then(k => {
          let [S, B, D] = oo(k);
          if (f.resolve(D), S != null && S !== oe.OK) throw new Fe(B ?? oe[S], oe[S], D);
          return S != null && (w = {
              code: oe[S],
              detail: B ?? oe[S]
          }), k
      }).then(k => {
          if (!k.body) throw new Fe("missing response body", oe[oe.INTERNAL]);
          return Fc(k.body, k.headers.get("content-type"), (S, B) => {
              switch (S) {
                  case Yt.DATA:
                      if (p) throw new Fe("unary call received 2nd message", oe[oe.DATA_LOSS]);
                      p = e.O.fromBinary(B, o.binaryOptions);
                      break;
                  case Yt.TRAILER:
                      let D, P;
                      [D, P, b] = Dc(B), w = {
                          code: oe[D],
                          detail: P ?? oe[D]
                      };
                      break
              }
          })
      }).then(() => {
          if (!b && p) throw new Fe("missing trailers", oe[oe.DATA_LOSS]);
          if (!w) throw new Fe("missing status", oe[oe.INTERNAL]);
          if (!p && w.code === "OK") throw new Fe("expected error status", oe[oe.DATA_LOSS]);
          if (!p) throw new Fe(w.detail, w.code, b);
          if (g.resolve(p), w.code !== "OK") throw new Fe(w.detail, w.code, b);
          y.resolve(w), x.resolve(b || {})
      }).catch(k => {
          let S;
          k instanceof Fe ? S = k : k instanceof Error && k.name === "AbortError" ? S = new Fe(k.message, oe[oe.CANCELLED]) : S = new Fe(k instanceof Error ? k.message : "" + k, oe[oe.INTERNAL]), S.methodName = e.name, S.serviceName = e.service.typeName, f.rejectPending(S), g.rejectPending(S), y.rejectPending(S), x.rejectPending(S)
      }), new dv(e, (l = o.meta) !== null && l !== void 0 ? l : {}, t, f.promise, g.promise, y.promise, x.promise)
  }
}
let np, hu;
np = "https://grpc.hypurr.fun", hu = "https://telegram.hypurr.fun";
const dt = new ep(new cu({
      baseUrl: np
  })),
  dl = new Uw(new cu({
      baseUrl: hu
  })),
  Jw = new ep(new cu({
      baseUrl: hu
  }));
class xn {
  stream = null;
  abortController = null;
  input = null;
  retryCount = 0;
  retryTimeout = null;
  config;
  constructor(e) {
      this.config = {
          maxRetries: 10,
          retryDelay: 2e3,
          onError: function(t) {
              console.error("Stream error:", t)
          },
          ...e
      }
  }
  async start(e) {
      this.stop(), this.input = e, this.retryCount = 0, await this.connect()
  }
  async connect() {
      try {
          this.abortController = new AbortController, this.stream = this.config.startStream(this.input, this.abortController), this.listen()
      } catch (e) {
          this.config.onError(e), await this.handleError()
      }
  }
  async listen() {
      if (!!this.stream) try {
          for await (const e of this.stream.responses) this.retryCount = 0, this.config.onMessage(e)
      } catch (e) {
          this.config.onError(e), await this.handleError(e)
      }
  }
  async handleError(e) {
      e.name === "RpcError" && e.message.includes("BodyStreamBuffer was aborted") || (this.retryTimeout && clearTimeout(this.retryTimeout), this.retryCount++, this.input && (this.retryCount < this.config.maxRetries ? (console.log(`Attempting to reconnect (attempt ${this.retryCount})...`), this.retryTimeout = setTimeout(async () => {
          this.input && await this.connect()
      }, this.config.retryDelay)) : (console.error("Max reconnection attempts reached"), this.stop())))
  }
  stop() {
      this.stream = null, this.input = null, this.retryCount = 0, this.abortController && (this.abortController.abort(), this.abortController = null), this.retryTimeout && (clearTimeout(this.retryTimeout), this.retryTimeout = null)
  }
}
const St = Xi("launch", () => {
      const i = M(new Map),
          e = M([]),
          t = M(new Map),
          n = M([]),
          s = M([]),
          r = M([]),
          a = M([]),
          l = M([]),
          o = M(),
          u = M(Date.now() / 1e3);
      setInterval(() => {
          u.value = Date.now() / 1e3
      }, 1e3);
      const c = q(() => {
              if (!o.value) return 0;
              if (o.value.endGas) return o.value.endGas.value * 2;
              let G = o.value.startTime,
                  te = o.value.startTime + o.value.duration,
                  le = u.value;
              return le > te ? 0 : le < G ? 1e4 : (o.value.startGas - 1e4) * (te - le) / (te - G)
          }),
          h = new xn({
              startStream: (G, te) => (i.value = new Map, e.value = [], dt.hyperliquidLaunchStream(G, {
                  abort: te.signal
              })),
              onMessage: G => {
                  let te = !1;
                  G.launches.forEach(le => {
                      const ae = e.value.findIndex($e => $e.id === le.id);
                      if (ae >= 0) {
                          let $e = e.value[ae];
                          Object.assign($e, le), i.value.set(le.id, $e)
                      } else e.value.push(le), i.value.set(le.id, le), te = !0
                  }), te && (e.value = [...e.value].sort((le, ae) => ae.lastEventTimestamp - le.lastEventTimestamp))
              },
              onError: G => {
                  console.log(G)
              }
          }),
          d = new xn({
              startStream: (G, te) => (n.value = [], dt.hyperliquidLaunchMessages(G, {
                  abort: te.signal
              })),
              onMessage: G => {
                  n.value.push(...G.messages)
              },
              onError: G => {
                  console.error("Error in message stream:", G), n.value = []
              }
          }),
          f = new xn({
              startStream: (G, te) => (s.value = [], dt.hyperliquidLaunchCandleStream(G, {
                  abort: te.signal
              })),
              onMessage: G => {
                  s.value.push(...G.candles)
              },
              onError: G => {
                  console.error("Error in candle stream:", G), s.value = []
              }
          }),
          p = new xn({
              startStream: (G, te) => (r.value = [], a.value = [], dt.hyperliquidLaunchFills(G, {
                  abort: te.signal
              })),
              onMessage: G => {
                  r.value.push(...G.fills), G.positions.forEach(te => {
                      const le = a.value.findIndex(ae => ae.address === te.address);
                      le >= 0 ? a.value[le] = te : a.value.push(te)
                  })
              },
              onError: G => {
                  console.error("Error in candle stream:", G), r.value = [], a.value = []
              }
          }),
          g = new xn({
              startStream: (G, te) => (l.value = [], dt.latestHyperliquidLaunchFills(G, {
                  abort: te.signal
              })),
              onMessage: G => {
                  l.value.push(...G.fills)
              },
              onError: G => {
                  console.error("Error in candle stream:", G), l.value = []
              }
          });
      return {
          fills: r,
          positions: a,
          candles: s,
          messages: n,
          launches: e,
          launchMap: i,
          launchFills: t,
          auction: o,
          auctionPrice: c,
          fetchLaunches: async () => null,
          fetchLaunchCandles: async (G, te) => {
              try {
                  return (await dt.hyperliquidLaunchCandles({
                      launchId: G,
                      interval: te
                  }, {})).response.candles.map($e => ({
                      ...$e,
                      time: $e.time / 1e3
                  }))
              } catch (le) {
                  return console.error(le), []
              }
          },
          fetchLaunchHolders: async G => {
              try {
                  return (await dt.hyperliquidLaunchHolders({
                      launchId: G
                  }, {})).response.holders
              } catch (te) {
                  return console.log(te), null
              }
          },
          fetchLaunch: async G => {
              if (G && i.value.has(G)) return i.value.get(G);
              try {
                  console.log("fetching launch", G);
                  let le = (await dt.hyperliquidLaunch({
                      id: G
                  }, {})).response.launch;
                  return i.value.set(le.id, le), console.log("fetched launch", le.id), i.value.get(le.id)
              } catch (te) {
                  return console.log(te), null
              }
          },
          fetchAuction: async () => {
              try {
                  const G = await dt.hyperliquidDeployAuction({}, {});
                  o.value = G.response.auction
              } catch (G) {
                  console.error(G)
              }
          },
          startCandleStream: async (G, te) => {
              await f.start({
                  launchId: G,
                  interval: te
              })
          },
          stopCandleStream: () => {
              f.stop(), s.value = []
          },
          startMessageStream: async G => {
              await d.start({
                  launchId: G
              })
          },
          stopMessageStream: () => {
              d.stop(), n.value = []
          },
          startFillStream: async G => {
              await p.start({
                  launchId: {
                      value: G
                  }
              })
          },
          stopFillStream: () => {
              p.stop(), r.value = []
          },
          startLatestFillStream: async () => {
              await g.start({})
          },
          stopLatestFillStream: () => {
              g.stop(), l.value = []
          },
          startLaunchStream: async () => {
              await h.start({})
          },
          stopLaunchStream: () => {
              h.stop(), i.value = new Map, e.value = []
          }
      }
  }),
  Is = "/assets/purrbot.246840f0.png";
class Yw {
  auth;
  user;
  constructor(e, t) {
      this.auth = e, this.user = t
  }
  getAddress() {
      return this.user.wallet.ethereumAddress
  }
  getProfilePicture() {
      return this.auth.photo_url
  }
  getDisplayName() {
      return this.auth.first_name
  }
}
const Ji = Xi("user", () => {
  const i = M(null),
      e = new Map,
      t = M(null);
  M([]);
  const n = M(null),
      s = M(!1),
      r = M(!0),
      a = localStorage.getItem("animationsEnabled");
  a !== null && (r.value = a !== "false");

  function l() {
      r.value = !r.value, localStorage.setItem("animationsEnabled", r.value.toString())
  }
  const o = q(() => {
      let p = {};
      if (!i.value || !i.value?.auth) return p;
      for (const [g, w] of Object.entries(i.value?.auth)) p[g] = w;
      return p
  });
  e.set("0xFFfFfFffFFfffFFfFFfFFFFFffFFFffffFfFFFfF", "Hyperliquidity");
  async function u(p) {
      let g = {};
      for (const [w, y] of Object.entries(p)) g[w] = y;
      try {
          s.value = !0;
          const w = await dl.telegramUser({
              authData: g
          });
          i.value = new Yw(p, w.response.user), console.log("user", i.value), s.value = !1, localStorage.setItem("telegramAuth", JSON.stringify(p));
          for (let y of w.response.user.labels) e.set(y.ethereumAddress, y.label)
      } catch (w) {
          throw console.error("Error authenticating with Telegram:", w), localStorage.removeItem("telegramAuth"), i.value = null, s.value = !1, w
      }
  }
  async function c(p, g, w, y, b) {
      if (!i.value || !i.value.auth) throw "Error";
      const x = i.value.user.wallets.find(D => D.id === w);
      if (!x) throw "Error";
      const k = await dl.hyperliquidLaunchTrade({
          authData: o.value,
          launchId: p,
          walletId: w,
          direction: y,
          amount: b
      });
      console.log("res", k.response);
      let S = x.launchBalances.find(D => D.launchId === p);
      S ? S.balance = k.response.baseAmount * Math.pow(10, g) : (S = {
          walletId: w,
          launchId: p,
          balance: 0
      }, x.launchBalances.push(S));
      let B = x.spotBalances.find(D => D.tokenId === 1e4);
      return B ? B.balance = k.response.quoteAmount : (B = {
          walletId: w,
          tokenId: 1e4,
          balance: 0
      }, x.spotBalances.push(B)), k.response
  }
  async function h(p) {
      const g = {};
      for (const [y, b] of Object.entries(p)) g[y] = b;
      return (await dl.telegramUserWallets({
          authData: g
      })).response.wallets
  }

  function d() {
      const p = localStorage.getItem("telegramAuth");
      if (p) {
          console.log("loading stored auth");
          try {
              const g = JSON.parse(p);
              u(g).catch(w => {
                  console.error("Failed to authenticate stored credentials:", w)
              })
          } catch (g) {
              console.error("Error parsing stored auth data:", g), localStorage.removeItem("telegramAuth")
          }
      }
  }

  function f() {
      i.value = null, localStorage.removeItem("telegramAuth")
  }
  return d(), {
      user: i,
      userWallet: t,
      walletLabels: e,
      onTelegramLogin: u,
      onLaunchTrade: c,
      fetchUserWallets: h,
      pendingDeploySession: n,
      logout: f,
      userLoading: s,
      animationsEnabled: r,
      toggleAnimations: l
  }
});
/*!
* vue-router v4.5.0
* (c) 2024 Eduardo San Martin Morote
* @license MIT
*/
const Tn = typeof document < "u";

function sp(i) {
  return typeof i == "object" || "displayName" in i || "props" in i || "__vccOpts" in i
}

function Qw(i) {
  return i.__esModule || i[Symbol.toStringTag] === "Module" || i.default && sp(i.default)
}
const Me = Object.assign;

function fl(i, e) {
  const t = {};
  for (const n in e) {
      const s = e[n];
      t[n] = ii(s) ? s.map(i) : i(s)
  }
  return t
}
const gs = () => {},
  ii = Array.isArray,
  rp = /#/g,
  Zw = /&/g,
  e1 = /\//g,
  t1 = /=/g,
  i1 = /\?/g,
  ap = /\+/g,
  n1 = /%5B/g,
  s1 = /%5D/g,
  lp = /%5E/g,
  r1 = /%60/g,
  op = /%7B/g,
  a1 = /%7C/g,
  up = /%7D/g,
  l1 = /%20/g;

function du(i) {
  return encodeURI("" + i).replace(a1, "|").replace(n1, "[").replace(s1, "]")
}

function o1(i) {
  return du(i).replace(op, "{").replace(up, "}").replace(lp, "^")
}

function uo(i) {
  return du(i).replace(ap, "%2B").replace(l1, "+").replace(rp, "%23").replace(Zw, "%26").replace(r1, "`").replace(op, "{").replace(up, "}").replace(lp, "^")
}

function u1(i) {
  return uo(i).replace(t1, "%3D")
}

function c1(i) {
  return du(i).replace(rp, "%23").replace(i1, "%3F")
}

function h1(i) {
  return i == null ? "" : c1(i).replace(e1, "%2F")
}

function Ns(i) {
  try {
      return decodeURIComponent("" + i)
  } catch {}
  return "" + i
}
const d1 = /\/$/,
  f1 = i => i.replace(d1, "");

function pl(i, e, t = "/") {
  let n, s = {},
      r = "",
      a = "";
  const l = e.indexOf("#");
  let o = e.indexOf("?");
  return l < o && l >= 0 && (o = -1), o > -1 && (n = e.slice(0, o), r = e.slice(o + 1, l > -1 ? l : e.length), s = i(r)), l > -1 && (n = n || e.slice(0, l), a = e.slice(l, e.length)), n = y1(n ?? e, t), {
      fullPath: n + (r && "?") + r + a,
      path: n,
      query: s,
      hash: Ns(a)
  }
}

function p1(i, e) {
  const t = e.query ? i(e.query) : "";
  return e.path + (t && "?") + t + (e.hash || "")
}

function Vc(i, e) {
  return !e || !i.toLowerCase().startsWith(e.toLowerCase()) ? i : i.slice(e.length) || "/"
}

function m1(i, e, t) {
  const n = e.matched.length - 1,
      s = t.matched.length - 1;
  return n > -1 && n === s && Un(e.matched[n], t.matched[s]) && cp(e.params, t.params) && i(e.query) === i(t.query) && e.hash === t.hash
}

function Un(i, e) {
  return (i.aliasOf || i) === (e.aliasOf || e)
}

function cp(i, e) {
  if (Object.keys(i).length !== Object.keys(e).length) return !1;
  for (const t in i)
      if (!g1(i[t], e[t])) return !1;
  return !0
}

function g1(i, e) {
  return ii(i) ? zc(i, e) : ii(e) ? zc(e, i) : i === e
}

function zc(i, e) {
  return ii(e) ? i.length === e.length && i.every((t, n) => t === e[n]) : i.length === 1 && i[0] === e
}

function y1(i, e) {
  if (i.startsWith("/")) return i;
  if (!i) return e;
  const t = e.split("/"),
      n = i.split("/"),
      s = n[n.length - 1];
  (s === ".." || s === ".") && n.push("");
  let r = t.length - 1,
      a, l;
  for (a = 0; a < n.length; a++)
      if (l = n[a], l !== ".")
          if (l === "..") r > 1 && r--;
          else break;
  return t.slice(0, r).join("/") + "/" + n.slice(a).join("/")
}
const Pi = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
};
var Ms;
(function(i) {
  i.pop = "pop", i.push = "push"
})(Ms || (Ms = {}));
var ys;
(function(i) {
  i.back = "back", i.forward = "forward", i.unknown = ""
})(ys || (ys = {}));

function v1(i) {
  if (!i)
      if (Tn) {
          const e = document.querySelector("base");
          i = e && e.getAttribute("href") || "/", i = i.replace(/^\w+:\/\/[^\/]+/, "")
      } else i = "/";
  return i[0] !== "/" && i[0] !== "#" && (i = "/" + i), f1(i)
}
const b1 = /^[^#]+#/;

function w1(i, e) {
  return i.replace(b1, "#") + e
}

function k1(i, e) {
  const t = document.documentElement.getBoundingClientRect(),
      n = i.getBoundingClientRect();
  return {
      behavior: e.behavior,
      left: n.left - t.left - (e.left || 0),
      top: n.top - t.top - (e.top || 0)
  }
}
const ba = () => ({
  left: window.scrollX,
  top: window.scrollY
});

function _1(i) {
  let e;
  if ("el" in i) {
      const t = i.el,
          n = typeof t == "string" && t.startsWith("#"),
          s = typeof t == "string" ? n ? document.getElementById(t.slice(1)) : document.querySelector(t) : t;
      if (!s) return;
      e = k1(s, i)
  } else e = i;
  "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY)
}

function Wc(i, e) {
  return (history.state ? history.state.position - e : -1) + i
}
const co = new Map;

function x1(i, e) {
  co.set(i, e)
}

function T1(i) {
  const e = co.get(i);
  return co.delete(i), e
}
let S1 = () => location.protocol + "//" + location.host;

function hp(i, e) {
  const {
      pathname: t,
      search: n,
      hash: s
  } = e, r = i.indexOf("#");
  if (r > -1) {
      let l = s.includes(i.slice(r)) ? i.slice(r).length : 1,
          o = s.slice(l);
      return o[0] !== "/" && (o = "/" + o), Vc(o, "")
  }
  return Vc(t, i) + n + s
}

function E1(i, e, t, n) {
  let s = [],
      r = [],
      a = null;
  const l = ({
      state: d
  }) => {
      const f = hp(i, location),
          p = t.value,
          g = e.value;
      let w = 0;
      if (d) {
          if (t.value = f, e.value = d, a && a === p) {
              a = null;
              return
          }
          w = g ? d.position - g.position : 0
      } else n(f);
      s.forEach(y => {
          y(t.value, p, {
              delta: w,
              type: Ms.pop,
              direction: w ? w > 0 ? ys.forward : ys.back : ys.unknown
          })
      })
  };

  function o() {
      a = t.value
  }

  function u(d) {
      s.push(d);
      const f = () => {
          const p = s.indexOf(d);
          p > -1 && s.splice(p, 1)
      };
      return r.push(f), f
  }

  function c() {
      const {
          history: d
      } = window;
      !d.state || d.replaceState(Me({}, d.state, {
          scroll: ba()
      }), "")
  }

  function h() {
      for (const d of r) d();
      r = [], window.removeEventListener("popstate", l), window.removeEventListener("beforeunload", c)
  }
  return window.addEventListener("popstate", l), window.addEventListener("beforeunload", c, {
      passive: !0
  }), {
      pauseListeners: o,
      listen: u,
      destroy: h
  }
}

function Uc(i, e, t, n = !1, s = !1) {
  return {
      back: i,
      current: e,
      forward: t,
      replaced: n,
      position: window.history.length,
      scroll: s ? ba() : null
  }
}

function C1(i) {
  const {
      history: e,
      location: t
  } = window, n = {
      value: hp(i, t)
  }, s = {
      value: e.state
  };
  s.value || r(n.value, {
      back: null,
      current: n.value,
      forward: null,
      position: e.length - 1,
      replaced: !0,
      scroll: null
  }, !0);

  function r(o, u, c) {
      const h = i.indexOf("#"),
          d = h > -1 ? (t.host && document.querySelector("base") ? i : i.slice(h)) + o : S1() + i + o;
      try {
          e[c ? "replaceState" : "pushState"](u, "", d), s.value = u
      } catch (f) {
          console.error(f), t[c ? "replace" : "assign"](d)
      }
  }

  function a(o, u) {
      const c = Me({}, e.state, Uc(s.value.back, o, s.value.forward, !0), u, {
          position: s.value.position
      });
      r(o, c, !0), n.value = o
  }

  function l(o, u) {
      const c = Me({}, s.value, e.state, {
          forward: o,
          scroll: ba()
      });
      r(c.current, c, !0);
      const h = Me({}, Uc(n.value, o, null), {
          position: c.position + 1
      }, u);
      r(o, h, !1), n.value = o
  }
  return {
      location: n,
      state: s,
      push: l,
      replace: a
  }
}

function $1(i) {
  i = v1(i);
  const e = C1(i),
      t = E1(i, e.state, e.location, e.replace);

  function n(r, a = !0) {
      a || t.pauseListeners(), history.go(r)
  }
  const s = Me({
      location: "",
      base: i,
      go: n,
      createHref: w1.bind(null, i)
  }, e, t);
  return Object.defineProperty(s, "location", {
      enumerable: !0,
      get: () => e.location.value
  }), Object.defineProperty(s, "state", {
      enumerable: !0,
      get: () => e.state.value
  }), s
}

function L1(i) {
  return typeof i == "string" || i && typeof i == "object"
}

function dp(i) {
  return typeof i == "string" || typeof i == "symbol"
}
const fp = Symbol("");
var jc;
(function(i) {
  i[i.aborted = 4] = "aborted", i[i.cancelled = 8] = "cancelled", i[i.duplicated = 16] = "duplicated"
})(jc || (jc = {}));

function jn(i, e) {
  return Me(new Error, {
      type: i,
      [fp]: !0
  }, e)
}

function yi(i, e) {
  return i instanceof Error && fp in i && (e == null || !!(i.type & e))
}
const Hc = "[^/]+?",
  P1 = {
      sensitive: !1,
      strict: !1,
      start: !0,
      end: !0
  },
  I1 = /[.+*?^${}()[\]/\\]/g;

function N1(i, e) {
  const t = Me({}, P1, e),
      n = [];
  let s = t.start ? "^" : "";
  const r = [];
  for (const u of i) {
      const c = u.length ? [] : [90];
      t.strict && !u.length && (s += "/");
      for (let h = 0; h < u.length; h++) {
          const d = u[h];
          let f = 40 + (t.sensitive ? .25 : 0);
          if (d.type === 0) h || (s += "/"), s += d.value.replace(I1, "\\$&"), f += 40;
          else if (d.type === 1) {
              const {
                  value: p,
                  repeatable: g,
                  optional: w,
                  regexp: y
              } = d;
              r.push({
                  name: p,
                  repeatable: g,
                  optional: w
              });
              const b = y || Hc;
              if (b !== Hc) {
                  f += 10;
                  try {
                      new RegExp(`(${b})`)
                  } catch (k) {
                      throw new Error(`Invalid custom RegExp for param "${p}" (${b}): ` + k.message)
                  }
              }
              let x = g ? `((?:${b})(?:/(?:${b}))*)` : `(${b})`;
              h || (x = w && u.length < 2 ? `(?:/${x})` : "/" + x), w && (x += "?"), s += x, f += 20, w && (f += -8), g && (f += -20), b === ".*" && (f += -50)
          }
          c.push(f)
      }
      n.push(c)
  }
  if (t.strict && t.end) {
      const u = n.length - 1;
      n[u][n[u].length - 1] += .7000000000000001
  }
  t.strict || (s += "/?"), t.end ? s += "$" : t.strict && !s.endsWith("/") && (s += "(?:/|$)");
  const a = new RegExp(s, t.sensitive ? "" : "i");

  function l(u) {
      const c = u.match(a),
          h = {};
      if (!c) return null;
      for (let d = 1; d < c.length; d++) {
          const f = c[d] || "",
              p = r[d - 1];
          h[p.name] = f && p.repeatable ? f.split("/") : f
      }
      return h
  }

  function o(u) {
      let c = "",
          h = !1;
      for (const d of i) {
          (!h || !c.endsWith("/")) && (c += "/"), h = !1;
          for (const f of d)
              if (f.type === 0) c += f.value;
              else if (f.type === 1) {
              const {
                  value: p,
                  repeatable: g,
                  optional: w
              } = f, y = p in u ? u[p] : "";
              if (ii(y) && !g) throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`);
              const b = ii(y) ? y.join("/") : y;
              if (!b)
                  if (w) d.length < 2 && (c.endsWith("/") ? c = c.slice(0, -1) : h = !0);
                  else throw new Error(`Missing required param "${p}"`);
              c += b
          }
      }
      return c || "/"
  }
  return {
      re: a,
      score: n,
      keys: r,
      parse: l,
      stringify: o
  }
}

function M1(i, e) {
  let t = 0;
  for (; t < i.length && t < e.length;) {
      const n = e[t] - i[t];
      if (n) return n;
      t++
  }
  return i.length < e.length ? i.length === 1 && i[0] === 40 + 40 ? -1 : 1 : i.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0
}

function pp(i, e) {
  let t = 0;
  const n = i.score,
      s = e.score;
  for (; t < n.length && t < s.length;) {
      const r = M1(n[t], s[t]);
      if (r) return r;
      t++
  }
  if (Math.abs(s.length - n.length) === 1) {
      if (qc(n)) return 1;
      if (qc(s)) return -1
  }
  return s.length - n.length
}

function qc(i) {
  const e = i[i.length - 1];
  return i.length > 0 && e[e.length - 1] < 0
}
const R1 = {
      type: 0,
      value: ""
  },
  B1 = /[a-zA-Z0-9_]/;

function O1(i) {
  if (!i) return [
      []
  ];
  if (i === "/") return [
      [R1]
  ];
  if (!i.startsWith("/")) throw new Error(`Invalid path "${i}"`);

  function e(f) {
      throw new Error(`ERR (${t})/"${u}": ${f}`)
  }
  let t = 0,
      n = t;
  const s = [];
  let r;

  function a() {
      r && s.push(r), r = []
  }
  let l = 0,
      o, u = "",
      c = "";

  function h() {
      !u || (t === 0 ? r.push({
          type: 0,
          value: u
      }) : t === 1 || t === 2 || t === 3 ? (r.length > 1 && (o === "*" || o === "+") && e(`A repeatable param (${u}) must be alone in its segment. eg: '/:ids+.`), r.push({
          type: 1,
          value: u,
          regexp: c,
          repeatable: o === "*" || o === "+",
          optional: o === "*" || o === "?"
      })) : e("Invalid state to consume buffer"), u = "")
  }

  function d() {
      u += o
  }
  for (; l < i.length;) {
      if (o = i[l++], o === "\\" && t !== 2) {
          n = t, t = 4;
          continue
      }
      switch (t) {
          case 0:
              o === "/" ? (u && h(), a()) : o === ":" ? (h(), t = 1) : d();
              break;
          case 4:
              d(), t = n;
              break;
          case 1:
              o === "(" ? t = 2 : B1.test(o) ? d() : (h(), t = 0, o !== "*" && o !== "?" && o !== "+" && l--);
              break;
          case 2:
              o === ")" ? c[c.length - 1] == "\\" ? c = c.slice(0, -1) + o : t = 3 : c += o;
              break;
          case 3:
              h(), t = 0, o !== "*" && o !== "?" && o !== "+" && l--, c = "";
              break;
          default:
              e("Unknown state");
              break
      }
  }
  return t === 2 && e(`Unfinished custom RegExp for param "${u}"`), h(), a(), s
}

function D1(i, e, t) {
  const n = N1(O1(i.path), t),
      s = Me(n, {
          record: i,
          parent: e,
          children: [],
          alias: []
      });
  return e && !s.record.aliasOf == !e.record.aliasOf && e.children.push(s), s
}

function F1(i, e) {
  const t = [],
      n = new Map;
  e = Jc({
      strict: !1,
      end: !0,
      sensitive: !1
  }, e);

  function s(h) {
      return n.get(h)
  }

  function r(h, d, f) {
      const p = !f,
          g = Kc(h);
      g.aliasOf = f && f.record;
      const w = Jc(e, h),
          y = [g];
      if ("alias" in h) {
          const k = typeof h.alias == "string" ? [h.alias] : h.alias;
          for (const S of k) y.push(Kc(Me({}, g, {
              components: f ? f.record.components : g.components,
              path: S,
              aliasOf: f ? f.record : g
          })))
      }
      let b, x;
      for (const k of y) {
          const {
              path: S
          } = k;
          if (d && S[0] !== "/") {
              const B = d.record.path,
                  D = B[B.length - 1] === "/" ? "" : "/";
              k.path = d.record.path + (S && D + S)
          }
          if (b = D1(k, d, w), f ? f.alias.push(b) : (x = x || b, x !== b && x.alias.push(b), p && h.name && !Xc(b) && a(h.name)), mp(b) && o(b), g.children) {
              const B = g.children;
              for (let D = 0; D < B.length; D++) r(B[D], b, f && f.children[D])
          }
          f = f || b
      }
      return x ? () => {
          a(x)
      } : gs
  }

  function a(h) {
      if (dp(h)) {
          const d = n.get(h);
          d && (n.delete(h), t.splice(t.indexOf(d), 1), d.children.forEach(a), d.alias.forEach(a))
      } else {
          const d = t.indexOf(h);
          d > -1 && (t.splice(d, 1), h.record.name && n.delete(h.record.name), h.children.forEach(a), h.alias.forEach(a))
      }
  }

  function l() {
      return t
  }

  function o(h) {
      const d = z1(h, t);
      t.splice(d, 0, h), h.record.name && !Xc(h) && n.set(h.record.name, h)
  }

  function u(h, d) {
      let f, p = {},
          g, w;
      if ("name" in h && h.name) {
          if (f = n.get(h.name), !f) throw jn(1, {
              location: h
          });
          w = f.record.name, p = Me(Gc(d.params, f.keys.filter(x => !x.optional).concat(f.parent ? f.parent.keys.filter(x => x.optional) : []).map(x => x.name)), h.params && Gc(h.params, f.keys.map(x => x.name))), g = f.stringify(p)
      } else if (h.path != null) g = h.path, f = t.find(x => x.re.test(g)), f && (p = f.parse(g), w = f.record.name);
      else {
          if (f = d.name ? n.get(d.name) : t.find(x => x.re.test(d.path)), !f) throw jn(1, {
              location: h,
              currentLocation: d
          });
          w = f.record.name, p = Me({}, d.params, h.params), g = f.stringify(p)
      }
      const y = [];
      let b = f;
      for (; b;) y.unshift(b.record), b = b.parent;
      return {
          name: w,
          path: g,
          params: p,
          matched: y,
          meta: V1(y)
      }
  }
  i.forEach(h => r(h));

  function c() {
      t.length = 0, n.clear()
  }
  return {
      addRoute: r,
      resolve: u,
      removeRoute: a,
      clearRoutes: c,
      getRoutes: l,
      getRecordMatcher: s
  }
}

function Gc(i, e) {
  const t = {};
  for (const n of e) n in i && (t[n] = i[n]);
  return t
}

function Kc(i) {
  const e = {
      path: i.path,
      redirect: i.redirect,
      name: i.name,
      meta: i.meta || {},
      aliasOf: i.aliasOf,
      beforeEnter: i.beforeEnter,
      props: A1(i),
      children: i.children || [],
      instances: {},
      leaveGuards: new Set,
      updateGuards: new Set,
      enterCallbacks: {},
      components: "components" in i ? i.components || null : i.component && {
          default: i.component
      }
  };
  return Object.defineProperty(e, "mods", {
      value: {}
  }), e
}

function A1(i) {
  const e = {},
      t = i.props || !1;
  if ("component" in i) e.default = t;
  else
      for (const n in i.components) e[n] = typeof t == "object" ? t[n] : t;
  return e
}

function Xc(i) {
  for (; i;) {
      if (i.record.aliasOf) return !0;
      i = i.parent
  }
  return !1
}

function V1(i) {
  return i.reduce((e, t) => Me(e, t.meta), {})
}

function Jc(i, e) {
  const t = {};
  for (const n in i) t[n] = n in e ? e[n] : i[n];
  return t
}

function z1(i, e) {
  let t = 0,
      n = e.length;
  for (; t !== n;) {
      const r = t + n >> 1;
      pp(i, e[r]) < 0 ? n = r : t = r + 1
  }
  const s = W1(i);
  return s && (n = e.lastIndexOf(s, n - 1)), n
}

function W1(i) {
  let e = i;
  for (; e = e.parent;)
      if (mp(e) && pp(i, e) === 0) return e
}

function mp({
  record: i
}) {
  return !!(i.name || i.components && Object.keys(i.components).length || i.redirect)
}

function U1(i) {
  const e = {};
  if (i === "" || i === "?") return e;
  const n = (i[0] === "?" ? i.slice(1) : i).split("&");
  for (let s = 0; s < n.length; ++s) {
      const r = n[s].replace(ap, " "),
          a = r.indexOf("="),
          l = Ns(a < 0 ? r : r.slice(0, a)),
          o = a < 0 ? null : Ns(r.slice(a + 1));
      if (l in e) {
          let u = e[l];
          ii(u) || (u = e[l] = [u]), u.push(o)
      } else e[l] = o
  }
  return e
}

function Yc(i) {
  let e = "";
  for (let t in i) {
      const n = i[t];
      if (t = u1(t), n == null) {
          n !== void 0 && (e += (e.length ? "&" : "") + t);
          continue
      }(ii(n) ? n.map(r => r && uo(r)) : [n && uo(n)]).forEach(r => {
          r !== void 0 && (e += (e.length ? "&" : "") + t, r != null && (e += "=" + r))
      })
  }
  return e
}

function j1(i) {
  const e = {};
  for (const t in i) {
      const n = i[t];
      n !== void 0 && (e[t] = ii(n) ? n.map(s => s == null ? null : "" + s) : n == null ? n : "" + n)
  }
  return e
}
const H1 = Symbol(""),
  Qc = Symbol(""),
  wa = Symbol(""),
  fu = Symbol(""),
  ho = Symbol("");

function rs() {
  let i = [];

  function e(n) {
      return i.push(n), () => {
          const s = i.indexOf(n);
          s > -1 && i.splice(s, 1)
      }
  }

  function t() {
      i = []
  }
  return {
      add: e,
      list: () => i.slice(),
      reset: t
  }
}

function Fi(i, e, t, n, s, r = a => a()) {
  const a = n && (n.enterCallbacks[s] = n.enterCallbacks[s] || []);
  return () => new Promise((l, o) => {
      const u = d => {
              d === !1 ? o(jn(4, {
                  from: t,
                  to: e
              })) : d instanceof Error ? o(d) : L1(d) ? o(jn(2, {
                  from: e,
                  to: d
              })) : (a && n.enterCallbacks[s] === a && typeof d == "function" && a.push(d), l())
          },
          c = r(() => i.call(n && n.instances[s], e, t, u));
      let h = Promise.resolve(c);
      i.length < 3 && (h = h.then(u)), h.catch(d => o(d))
  })
}

function ml(i, e, t, n, s = r => r()) {
  const r = [];
  for (const a of i)
      for (const l in a.components) {
          let o = a.components[l];
          if (!(e !== "beforeRouteEnter" && !a.instances[l]))
              if (sp(o)) {
                  const c = (o.__vccOpts || o)[e];
                  c && r.push(Fi(c, t, n, a, l, s))
              } else {
                  let u = o();
                  r.push(() => u.then(c => {
                      if (!c) throw new Error(`Couldn't resolve component "${l}" at "${a.path}"`);
                      const h = Qw(c) ? c.default : c;
                      a.mods[l] = c, a.components[l] = h;
                      const f = (h.__vccOpts || h)[e];
                      return f && Fi(f, t, n, a, l, s)()
                  }))
              }
      }
  return r
}

function Zc(i) {
  const e = zt(wa),
      t = zt(fu),
      n = q(() => {
          const o = pe(i.to);
          return e.resolve(o)
      }),
      s = q(() => {
          const {
              matched: o
          } = n.value, {
              length: u
          } = o, c = o[u - 1], h = t.matched;
          if (!c || !h.length) return -1;
          const d = h.findIndex(Un.bind(null, c));
          if (d > -1) return d;
          const f = eh(o[u - 2]);
          return u > 1 && eh(c) === f && h[h.length - 1].path !== f ? h.findIndex(Un.bind(null, o[u - 2])) : d
      }),
      r = q(() => s.value > -1 && J1(t.params, n.value.params)),
      a = q(() => s.value > -1 && s.value === t.matched.length - 1 && cp(t.params, n.value.params));

  function l(o = {}) {
      if (X1(o)) {
          const u = e[pe(i.replace) ? "replace" : "push"](pe(i.to)).catch(gs);
          return i.viewTransition && typeof document < "u" && "startViewTransition" in document && document.startViewTransition(() => u), u
      }
      return Promise.resolve()
  }
  return {
      route: n,
      href: q(() => n.value.href),
      isActive: r,
      isExactActive: a,
      navigate: l
  }
}

function q1(i) {
  return i.length === 1 ? i[0] : i
}
const G1 = U({
      name: "RouterLink",
      compatConfig: {
          MODE: 3
      },
      props: {
          to: {
              type: [String, Object],
              required: !0
          },
          replace: Boolean,
          activeClass: String,
          exactActiveClass: String,
          custom: Boolean,
          ariaCurrentValue: {
              type: String,
              default: "page"
          }
      },
      useLink: Zc,
      setup(i, {
          slots: e
      }) {
          const t = Wi(Zc(i)),
              {
                  options: n
              } = zt(wa),
              s = q(() => ({
                  [th(i.activeClass, n.linkActiveClass, "router-link-active")]: t.isActive,
                  [th(i.exactActiveClass, n.linkExactActiveClass, "router-link-exact-active")]: t.isExactActive
              }));
          return () => {
              const r = e.default && q1(e.default(t));
              return i.custom ? r : wt("a", {
                  "aria-current": t.isExactActive ? i.ariaCurrentValue : null,
                  href: t.href,
                  onClick: t.navigate,
                  class: s.value
              }, r)
          }
      }
  }),
  K1 = G1;

function X1(i) {
  if (!(i.metaKey || i.altKey || i.ctrlKey || i.shiftKey) && !i.defaultPrevented && !(i.button !== void 0 && i.button !== 0)) {
      if (i.currentTarget && i.currentTarget.getAttribute) {
          const e = i.currentTarget.getAttribute("target");
          if (/\b_blank\b/i.test(e)) return
      }
      return i.preventDefault && i.preventDefault(), !0
  }
}

function J1(i, e) {
  for (const t in e) {
      const n = e[t],
          s = i[t];
      if (typeof n == "string") {
          if (n !== s) return !1
      } else if (!ii(s) || s.length !== n.length || n.some((r, a) => r !== s[a])) return !1
  }
  return !0
}

function eh(i) {
  return i ? i.aliasOf ? i.aliasOf.path : i.path : ""
}
const th = (i, e, t) => i ?? e ?? t,
  Y1 = U({
      name: "RouterView",
      inheritAttrs: !1,
      props: {
          name: {
              type: String,
              default: "default"
          },
          route: Object
      },
      compatConfig: {
          MODE: 3
      },
      setup(i, {
          attrs: e,
          slots: t
      }) {
          const n = zt(ho),
              s = q(() => i.route || n.value),
              r = zt(Qc, 0),
              a = q(() => {
                  let u = pe(r);
                  const {
                      matched: c
                  } = s.value;
                  let h;
                  for (;
                      (h = c[u]) && !h.components;) u++;
                  return u
              }),
              l = q(() => s.value.matched[a.value]);
          Nn(Qc, q(() => a.value + 1)), Nn(H1, l), Nn(ho, s);
          const o = M();
          return Ie(() => [o.value, l.value, i.name], ([u, c, h], [d, f, p]) => {
              c && (c.instances[h] = u, f && f !== c && u && u === d && (c.leaveGuards.size || (c.leaveGuards = f.leaveGuards), c.updateGuards.size || (c.updateGuards = f.updateGuards))), u && c && (!f || !Un(c, f) || !d) && (c.enterCallbacks[h] || []).forEach(g => g(u))
          }, {
              flush: "post"
          }), () => {
              const u = s.value,
                  c = i.name,
                  h = l.value,
                  d = h && h.components[c];
              if (!d) return ih(t.default, {
                  Component: d,
                  route: u
              });
              const f = h.props[c],
                  p = f ? f === !0 ? u.params : typeof f == "function" ? f(u) : f : null,
                  w = wt(d, Me({}, p, e, {
                      onVnodeUnmounted: y => {
                          y.component.isUnmounted && (h.instances[c] = null)
                      },
                      ref: o
                  }));
              return ih(t.default, {
                  Component: w,
                  route: u
              }) || w
          }
      }
  });

function ih(i, e) {
  if (!i) return null;
  const t = i(e);
  return t.length === 1 ? t[0] : t
}
const Q1 = Y1;

function Z1(i) {
  const e = F1(i.routes, i),
      t = i.parseQuery || U1,
      n = i.stringifyQuery || Yc,
      s = i.history,
      r = rs(),
      a = rs(),
      l = rs(),
      o = Eg(Pi);
  let u = Pi;
  Tn && i.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
  const c = fl.bind(null, H => "" + H),
      h = fl.bind(null, h1),
      d = fl.bind(null, Ns);

  function f(H, fe) {
      let he, me;
      return dp(H) ? (he = e.getRecordMatcher(H), me = fe) : me = H, e.addRoute(me, he)
  }

  function p(H) {
      const fe = e.getRecordMatcher(H);
      fe && e.removeRoute(fe)
  }

  function g() {
      return e.getRoutes().map(H => H.record)
  }

  function w(H) {
      return !!e.getRecordMatcher(H)
  }

  function y(H, fe) {
      if (fe = Me({}, fe || o.value), typeof H == "string") {
          const C = pl(t, H, fe.path),
              R = e.resolve({
                  path: C.path
              }, fe),
              K = s.createHref(C.fullPath);
          return Me(C, R, {
              params: d(R.params),
              hash: Ns(C.hash),
              redirectedFrom: void 0,
              href: K
          })
      }
      let he;
      if (H.path != null) he = Me({}, H, {
          path: pl(t, H.path, fe.path).path
      });
      else {
          const C = Me({}, H.params);
          for (const R in C) C[R] == null && delete C[R];
          he = Me({}, H, {
              params: h(C)
          }), fe.params = h(fe.params)
      }
      const me = e.resolve(he, fe),
          Ne = H.hash || "";
      me.params = c(d(me.params));
      const Ke = p1(n, Me({}, H, {
              hash: o1(Ne),
              path: me.path
          })),
          E = s.createHref(Ke);
      return Me({
          fullPath: Ke,
          hash: Ne,
          query: n === Yc ? j1(H.query) : H.query || {}
      }, me, {
          redirectedFrom: void 0,
          href: E
      })
  }

  function b(H) {
      return typeof H == "string" ? pl(t, H, o.value.path) : Me({}, H)
  }

  function x(H, fe) {
      if (u !== H) return jn(8, {
          from: fe,
          to: H
      })
  }

  function k(H) {
      return D(H)
  }

  function S(H) {
      return k(Me(b(H), {
          replace: !0
      }))
  }

  function B(H) {
      const fe = H.matched[H.matched.length - 1];
      if (fe && fe.redirect) {
          const {
              redirect: he
          } = fe;
          let me = typeof he == "function" ? he(H) : he;
          return typeof me == "string" && (me = me.includes("?") || me.includes("#") ? me = b(me) : {
              path: me
          }, me.params = {}), Me({
              query: H.query,
              hash: H.hash,
              params: me.path != null ? {} : H.params
          }, me)
      }
  }

  function D(H, fe) {
      const he = u = y(H),
          me = o.value,
          Ne = H.state,
          Ke = H.force,
          E = H.replace === !0,
          C = B(he);
      if (C) return D(Me(b(C), {
          state: typeof C == "object" ? Me({}, Ne, C.state) : Ne,
          force: Ke,
          replace: E
      }), fe || he);
      const R = he;
      R.redirectedFrom = fe;
      let K;
      return !Ke && m1(n, me, he) && (K = jn(16, {
          to: R,
          from: me
      }), Ye(me, me, !0, !1)), (K ? Promise.resolve(K) : $(R, me)).catch(j => yi(j) ? yi(j, 2) ? j : Oe(j) : ae(j, R, me)).then(j => {
          if (j) {
              if (yi(j, 2)) return D(Me({
                  replace: E
              }, b(j.to), {
                  state: typeof j.to == "object" ? Me({}, Ne, j.to.state) : Ne,
                  force: Ke
              }), fe || R)
          } else j = N(R, me, !0, E, Ne);
          return V(R, me, j), j
      })
  }

  function P(H, fe) {
      const he = x(H, fe);
      return he ? Promise.reject(he) : Promise.resolve()
  }

  function I(H) {
      const fe = yn.values().next().value;
      return fe && typeof fe.runWithContext == "function" ? fe.runWithContext(H) : H()
  }

  function $(H, fe) {
      let he;
      const [me, Ne, Ke] = ek(H, fe);
      he = ml(me.reverse(), "beforeRouteLeave", H, fe);
      for (const C of me) C.leaveGuards.forEach(R => {
          he.push(Fi(R, H, fe))
      });
      const E = P.bind(null, H, fe);
      return he.push(E), Bt(he).then(() => {
          he = [];
          for (const C of r.list()) he.push(Fi(C, H, fe));
          return he.push(E), Bt(he)
      }).then(() => {
          he = ml(Ne, "beforeRouteUpdate", H, fe);
          for (const C of Ne) C.updateGuards.forEach(R => {
              he.push(Fi(R, H, fe))
          });
          return he.push(E), Bt(he)
      }).then(() => {
          he = [];
          for (const C of Ke)
              if (C.beforeEnter)
                  if (ii(C.beforeEnter))
                      for (const R of C.beforeEnter) he.push(Fi(R, H, fe));
                  else he.push(Fi(C.beforeEnter, H, fe));
          return he.push(E), Bt(he)
      }).then(() => (H.matched.forEach(C => C.enterCallbacks = {}), he = ml(Ke, "beforeRouteEnter", H, fe, I), he.push(E), Bt(he))).then(() => {
          he = [];
          for (const C of a.list()) he.push(Fi(C, H, fe));
          return he.push(E), Bt(he)
      }).catch(C => yi(C, 8) ? C : Promise.reject(C))
  }

  function V(H, fe, he) {
      l.list().forEach(me => I(() => me(H, fe, he)))
  }

  function N(H, fe, he, me, Ne) {
      const Ke = x(H, fe);
      if (Ke) return Ke;
      const E = fe === Pi,
          C = Tn ? history.state : {};
      he && (me || E ? s.replace(H.fullPath, Me({
          scroll: E && C && C.scroll
      }, Ne)) : s.push(H.fullPath, Ne)), o.value = H, Ye(H, fe, he, E), Oe()
  }
  let O;

  function se() {
      O || (O = s.listen((H, fe, he) => {
          if (!Qs.listening) return;
          const me = y(H),
              Ne = B(me);
          if (Ne) {
              D(Me(Ne, {
                  replace: !0,
                  force: !0
              }), me).catch(gs);
              return
          }
          u = me;
          const Ke = o.value;
          Tn && x1(Wc(Ke.fullPath, he.delta), ba()), $(me, Ke).catch(E => yi(E, 12) ? E : yi(E, 2) ? (D(Me(b(E.to), {
              force: !0
          }), me).then(C => {
              yi(C, 20) && !he.delta && he.type === Ms.pop && s.go(-1, !1)
          }).catch(gs), Promise.reject()) : (he.delta && s.go(-he.delta, !1), ae(E, me, Ke))).then(E => {
              E = E || N(me, Ke, !1), E && (he.delta && !yi(E, 8) ? s.go(-he.delta, !1) : he.type === Ms.pop && yi(E, 20) && s.go(-1, !1)), V(me, Ke, E)
          }).catch(gs)
      }))
  }
  let G = rs(),
      te = rs(),
      le;

  function ae(H, fe, he) {
      Oe(H);
      const me = te.list();
      return me.length ? me.forEach(Ne => Ne(H, fe, he)) : console.error(H), Promise.reject(H)
  }

  function $e() {
      return le && o.value !== Pi ? Promise.resolve() : new Promise((H, fe) => {
          G.add([H, fe])
      })
  }

  function Oe(H) {
      return le || (le = !H, se(), G.list().forEach(([fe, he]) => H ? he(H) : fe()), G.reset()), H
  }

  function Ye(H, fe, he, me) {
      const {
          scrollBehavior: Ne
      } = i;
      if (!Tn || !Ne) return Promise.resolve();
      const Ke = !he && T1(Wc(H.fullPath, 0)) || (me || !he) && history.state && history.state.scroll || null;
      return pi().then(() => Ne(H, fe, Ke)).then(E => E && _1(E)).catch(E => ae(E, H, fe))
  }
  const it = H => s.go(H);
  let gn;
  const yn = new Set,
      Qs = {
          currentRoute: o,
          listening: !0,
          addRoute: f,
          removeRoute: p,
          clearRoutes: e.clearRoutes,
          hasRoute: w,
          getRoutes: g,
          resolve: y,
          options: i,
          push: k,
          replace: S,
          go: it,
          back: () => it(-1),
          forward: () => it(1),
          beforeEach: r.add,
          beforeResolve: a.add,
          afterEach: l.add,
          onError: te.add,
          isReady: $e,
          install(H) {
              const fe = this;
              H.component("RouterLink", K1), H.component("RouterView", Q1), H.config.globalProperties.$router = fe, Object.defineProperty(H.config.globalProperties, "$route", {
                  enumerable: !0,
                  get: () => pe(o)
              }), Tn && !gn && o.value === Pi && (gn = !0, k(s.location).catch(Ne => {}));
              const he = {};
              for (const Ne in Pi) Object.defineProperty(he, Ne, {
                  get: () => o.value[Ne],
                  enumerable: !0
              });
              H.provide(wa, fe), H.provide(fu, Qo(he)), H.provide(ho, o);
              const me = H.unmount;
              yn.add(H), H.unmount = function() {
                  yn.delete(H), yn.size < 1 && (u = Pi, O && O(), O = null, o.value = Pi, gn = !1, le = !1), me()
              }
          }
      };

  function Bt(H) {
      return H.reduce((fe, he) => fe.then(() => I(he)), Promise.resolve())
  }
  return Qs
}

function ek(i, e) {
  const t = [],
      n = [],
      s = [],
      r = Math.max(e.matched.length, i.matched.length);
  for (let a = 0; a < r; a++) {
      const l = e.matched[a];
      l && (i.matched.find(u => Un(u, l)) ? n.push(l) : t.push(l));
      const o = i.matched[a];
      o && (e.matched.find(u => Un(u, o)) || s.push(o))
  }
  return [t, n, s]
}

function gp() {
  return zt(wa)
}

function Zn(i) {
  return zt(fu)
}
async function tk(i, e, t, n) {
  const s = Date.now(),
      r = {
          req: {
              coin: `@${i}`,
              endTime: n || s,
              interval: e,
              startTime: t || s - 24 * 60 * 60 * 1e3
          },
          type: "candleSnapshot"
      },
      a = await fetch("https://api-ui.hyperliquid.xyz/info", {
          method: "POST",
          headers: {
              "Content-Type": "application/json"
          },
          body: JSON.stringify(r)
      });
  if (!a.ok) throw new Error(`HTTP error! status: ${a.status}`);
  return await a.json()
}
const si = Xi("pair", () => {
  const i = M([]),
      e = Wi(new Map),
      t = Wi(new Map),
      n = M([]),
      s = Wi(new Map),
      r = M([]),
      a = M([]),
      l = M("1h"),
      o = new xn({
          startStream: (y, b) => (r.value = [], dt.hyperliquidTokenMessages(y, {
              abort: b.signal
          })),
          onMessage: y => {
              r.value.push(...y.messages)
          },
          onError: y => {
              console.error("Error in message stream:", y), r.value = []
          }
      });
  return {
      tokens: i,
      spotPairs: e,
      spotPairByBaseId: t,
      perpPairs: n,
      perpPairById: s,
      messages: r,
      fetchTokens: async () => {
          const y = {};
          try {
              const b = await dt.hyperliquidTokens(y, {});
              return i.value = b.response.tokens, b
          } catch (b) {
              return console.log(b), b.code, null
          }
      },
      fetchTokenHolders: async y => {
          try {
              return (await dt.hyperliquidTokenHolders({
                  tokenId: y
              }, {})).response.holders
          } catch (b) {
              return console.log(b), b.code, null
          }
      },
      fetchSpotPair: async y => {
          if (y && e.has(y)) return e.get(y);
          try {
              const x = (await dt.hyperliquidSpotPair({
                  id: y
              }, {})).response.pair;
              return e.set(x.id, x), t.set(x.base.id, x), e.get(x.id)
          } catch (b) {
              return console.log(b), null
          }
      },
      fetchSpotPairs: async () => {
          const y = {};
          try {
              const b = await dt.hyperliquidSpotPairs(y, {});
              for (const x of b.response.pairs) e.set(x.id, x), t.set(x.base.id, x);
              return b
          } catch (b) {
              return console.log(b), b.code, null
          }
      },
      fetchPerpPairs: async () => {
          const y = {};
          try {
              const b = await dt.hyperliquidPerpPairs(y, {});
              n.value = b.response.pairs;
              for (const x of b.response.pairs) s.set(x.id, x);
              return b
          } catch (b) {
              return console.log(b), b.code, null
          }
      },
      startMessageStream: async y => {
          await o.start({
              tokenId: y
          })
      },
      stopMessageStream: () => {
          o.stop(), r.value = []
      },
      candles: a,
      currentInterval: l,
      fetchCandleData: async (y, b) => {
          try {
              b && (l.value = b);
              const x = await tk(y, l.value);
              a.value = x.map(k => ({
                  time: k.t / 1e3,
                  open: parseFloat(k.o),
                  high: parseFloat(k.h),
                  low: parseFloat(k.l),
                  close: parseFloat(k.c)
              }))
          } catch (x) {
              console.error("Error fetching candle data:", x), a.value = []
          }
      }
  }
});
const Hn = i => new Intl.NumberFormat("en-US", {
      minimumFractionDigits: 2
  }).format(i),
  Nt = i => new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
  }).format(i),
  ut = i => i >= 1e6 ? new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
  }).format(i / 1e6) + "M" : i >= 1e3 ? new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
  }).format(i / 1e3) + "K" : new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
  }).format(i),
  ik = {
      class: "bg-white dark:bg-slate-800 dark:text-white shadow-lg rounded-lg p-6 w-full max-w-sm border border-gray-300 dark:border-gray-700"
  },
  nk = {
      class: "flex justify-between items-center mb-6"
  },
  sk = {
      class: "text-xl font-bold text-black dark:text-white"
  },
  rk = {
      class: "grid grid-cols-2 gap-2"
  },
  ak = {
      class: "text-sm text-black dark:text-white mb-1 pl-1"
  },
  lk = {
      class: "font-semibold text-gray-700 dark:text-gray-400 pl-1"
  },
  ok = U({
      name: "Card"
  }),
  fo = U({
      ...ok,
      props: {
          pair: Object
      },
      setup(i) {
          const e = i,
              t = q(() => e.pair ? ((e.pair.markPrice - e.pair.previousDayPx) / e.pair.previousDayPx * 100).toFixed(2) : "0"),
              n = q(() => e.pair ? parseFloat(t.value) >= 0 ? "text-green-500" : "text-red-500" : ""),
              s = a => new Intl.NumberFormat("en-US", {
                  notation: "compact"
              }).format(a),
              r = q(() => [{
                  label: "Mark Price",
                  value: e.pair?.markPrice.toFixed(4)
              }, {
                  label: "24h Volume",
                  value: ut(e.pair?.dailyNtlVolume)
              }, {
                  label: "Circulating Supply",
                  value: s(e.pair?.base.circulatingSupply)
              }, {
                  label: "HLQ Balance",
                  value: s(e.pair?.base.hlqBalance)
              }]);
          return (a, l) => (_(), T("div", ik, [m("div", nk, [m("h2", sk, A(i.pair.base.name) + "/" + A(i.pair.quote.name), 1), m("span", {
              class: ie([n.value, "text-lg font-semibold"])
          }, A(t.value) + "%", 3)]), m("div", rk, [(_(!0), T(F, null, ue(r.value, (o, u) => (_(), T("div", {
              key: u
          }, [m("p", ak, A(o.label), 1), m("p", lk, A(o.value), 1)]))), 128))])]))
      }
  }),
  uk = U({
      name: "CardLoading"
  }),
  Ee = (i, e) => {
      const t = i.__vccOpts || i;
      for (const [n, s] of e) t[n] = s;
      return t
  },
  ck = {
      class: "bg-white dark:bg-slate-800 shadow-lg rounded-lg p-6 w-full max-w-sm border border-gray-700"
  },
  hk = {
      class: "animate-pulse space-y-4"
  },
  dk = {
      class: "grid grid-cols-2 gap-4"
  };

function fk(i, e, t, n, s, r) {
  return _(), T("div", ck, [m("div", hk, [e[1] || (e[1] = m("div", {
      class: "flex justify-between items-center mb-6"
  }, [m("div", {
      class: "h-7 bg-gray-300 dark:bg-slate-700 rounded w-1/4"
  }), m("div", {
      class: "h-7 bg-gray-300 dark:bg-slate-700 rounded w-1/4"
  })], -1)), m("div", dk, [(_(), T(F, null, ue(4, a => m("div", {
      key: a
  }, e[0] || (e[0] = [m("div", {
      class: "h-4 bg-gray-300 dark:bg-slate-700 rounded w-full mb-1 pl-1"
  }, null, -1), m("div", {
      class: "h-5 bg-gray-300 dark:bg-slate-700 rounded w-full mb-1 pl-1"
  }, null, -1)]))), 64))])])])
}
const po = Ee(uk, [
  ["render", fk]
]);

function nh(i) {
  return i !== null && typeof i == "object" && "constructor" in i && i.constructor === Object
}

function pu(i, e) {
  i === void 0 && (i = {}), e === void 0 && (e = {}), Object.keys(e).forEach(t => {
      typeof i[t] > "u" ? i[t] = e[t] : nh(e[t]) && nh(i[t]) && Object.keys(e[t]).length > 0 && pu(i[t], e[t])
  })
}
const yp = {
  body: {},
  addEventListener() {},
  removeEventListener() {},
  activeElement: {
      blur() {},
      nodeName: ""
  },
  querySelector() {
      return null
  },
  querySelectorAll() {
      return []
  },
  getElementById() {
      return null
  },
  createEvent() {
      return {
          initEvent() {}
      }
  },
  createElement() {
      return {
          children: [],
          childNodes: [],
          style: {},
          setAttribute() {},
          getElementsByTagName() {
              return []
          }
      }
  },
  createElementNS() {
      return {}
  },
  importNode() {
      return null
  },
  location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
  }
};

function Ci() {
  const i = typeof document < "u" ? document : {};
  return pu(i, yp), i
}
const pk = {
  document: yp,
  navigator: {
      userAgent: ""
  },
  location: {
      hash: "",
      host: "",
      hostname: "",
      href: "",
      origin: "",
      pathname: "",
      protocol: "",
      search: ""
  },
  history: {
      replaceState() {},
      pushState() {},
      go() {},
      back() {}
  },
  CustomEvent: function() {
      return this
  },
  addEventListener() {},
  removeEventListener() {},
  getComputedStyle() {
      return {
          getPropertyValue() {
              return ""
          }
      }
  },
  Image() {},
  Date() {},
  screen: {},
  setTimeout() {},
  clearTimeout() {},
  matchMedia() {
      return {}
  },
  requestAnimationFrame(i) {
      return typeof setTimeout > "u" ? (i(), null) : setTimeout(i, 0)
  },
  cancelAnimationFrame(i) {
      typeof setTimeout > "u" || clearTimeout(i)
  }
};

function Rt() {
  const i = typeof window < "u" ? window : {};
  return pu(i, pk), i
}

function mk(i) {
  return i === void 0 && (i = ""), i.trim().split(" ").filter(e => !!e.trim())
}

function gk(i) {
  const e = i;
  Object.keys(e).forEach(t => {
      try {
          e[t] = null
      } catch {}
      try {
          delete e[t]
      } catch {}
  })
}

function mo(i, e) {
  return e === void 0 && (e = 0), setTimeout(i, e)
}

function qr() {
  return Date.now()
}

function yk(i) {
  const e = Rt();
  let t;
  return e.getComputedStyle && (t = e.getComputedStyle(i, null)), !t && i.currentStyle && (t = i.currentStyle), t || (t = i.style), t
}

function vk(i, e) {
  e === void 0 && (e = "x");
  const t = Rt();
  let n, s, r;
  const a = yk(i);
  return t.WebKitCSSMatrix ? (s = a.transform || a.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map(l => l.replace(",", ".")).join(", ")), r = new t.WebKitCSSMatrix(s === "none" ? "" : s)) : (r = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), n = r.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? s = r.m41 : n.length === 16 ? s = parseFloat(n[12]) : s = parseFloat(n[4])), e === "y" && (t.WebKitCSSMatrix ? s = r.m42 : n.length === 16 ? s = parseFloat(n[13]) : s = parseFloat(n[5])), s || 0
}

function or(i) {
  return typeof i == "object" && i !== null && i.constructor && Object.prototype.toString.call(i).slice(8, -1) === "Object"
}

function bk(i) {
  return typeof window < "u" && typeof window.HTMLElement < "u" ? i instanceof HTMLElement : i && (i.nodeType === 1 || i.nodeType === 11)
}

function Pt() {
  const i = Object(arguments.length <= 0 ? void 0 : arguments[0]),
      e = ["__proto__", "constructor", "prototype"];
  for (let t = 1; t < arguments.length; t += 1) {
      const n = t < 0 || arguments.length <= t ? void 0 : arguments[t];
      if (n != null && !bk(n)) {
          const s = Object.keys(Object(n)).filter(r => e.indexOf(r) < 0);
          for (let r = 0, a = s.length; r < a; r += 1) {
              const l = s[r],
                  o = Object.getOwnPropertyDescriptor(n, l);
              o !== void 0 && o.enumerable && (or(i[l]) && or(n[l]) ? n[l].__swiper__ ? i[l] = n[l] : Pt(i[l], n[l]) : !or(i[l]) && or(n[l]) ? (i[l] = {}, n[l].__swiper__ ? i[l] = n[l] : Pt(i[l], n[l])) : i[l] = n[l])
          }
      }
  }
  return i
}

function ur(i, e, t) {
  i.style.setProperty(e, t)
}

function vp(i) {
  let {
      swiper: e,
      targetPosition: t,
      side: n
  } = i;
  const s = Rt(),
      r = -e.translate;
  let a = null,
      l;
  const o = e.params.speed;
  e.wrapperEl.style.scrollSnapType = "none", s.cancelAnimationFrame(e.cssModeFrameID);
  const u = t > r ? "next" : "prev",
      c = (d, f) => u === "next" && d >= f || u === "prev" && d <= f,
      h = () => {
          l = new Date().getTime(), a === null && (a = l);
          const d = Math.max(Math.min((l - a) / o, 1), 0),
              f = .5 - Math.cos(d * Math.PI) / 2;
          let p = r + f * (t - r);
          if (c(p, t) && (p = t), e.wrapperEl.scrollTo({
                  [n]: p
              }), c(p, t)) {
              e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
                  e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({
                      [n]: p
                  })
              }), s.cancelAnimationFrame(e.cssModeFrameID);
              return
          }
          e.cssModeFrameID = s.requestAnimationFrame(h)
      };
  h()
}

function di(i, e) {
  e === void 0 && (e = "");
  const t = [...i.children];
  return i instanceof HTMLSlotElement && t.push(...i.assignedElements()), e ? t.filter(n => n.matches(e)) : t
}

function wk(i, e) {
  const t = e.contains(i);
  return !t && e instanceof HTMLSlotElement ? [...e.assignedElements()].includes(i) : t
}

function Gr(i) {
  try {
      console.warn(i);
      return
  } catch {}
}

function Kr(i, e) {
  e === void 0 && (e = []);
  const t = document.createElement(i);
  return t.classList.add(...Array.isArray(e) ? e : mk(e)), t
}

function kk(i, e) {
  const t = [];
  for (; i.previousElementSibling;) {
      const n = i.previousElementSibling;
      e ? n.matches(e) && t.push(n) : t.push(n), i = n
  }
  return t
}

function _k(i, e) {
  const t = [];
  for (; i.nextElementSibling;) {
      const n = i.nextElementSibling;
      e ? n.matches(e) && t.push(n) : t.push(n), i = n
  }
  return t
}

function Vi(i, e) {
  return Rt().getComputedStyle(i, null).getPropertyValue(e)
}

function Xr(i) {
  let e = i,
      t;
  if (e) {
      for (t = 0;
          (e = e.previousSibling) !== null;) e.nodeType === 1 && (t += 1);
      return t
  }
}

function bp(i, e) {
  const t = [];
  let n = i.parentElement;
  for (; n;) e ? n.matches(e) && t.push(n) : t.push(n), n = n.parentElement;
  return t
}

function go(i, e, t) {
  const n = Rt();
  return t ? i[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(n.getComputedStyle(i, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(n.getComputedStyle(i, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : i.offsetWidth
}

function rt(i) {
  return (Array.isArray(i) ? i : [i]).filter(e => !!e)
}
let gl;

function xk() {
  const i = Rt(),
      e = Ci();
  return {
      smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style,
      touch: !!("ontouchstart" in i || i.DocumentTouch && e instanceof i.DocumentTouch)
  }
}

function wp() {
  return gl || (gl = xk()), gl
}
let yl;

function Tk(i) {
  let {
      userAgent: e
  } = i === void 0 ? {} : i;
  const t = wp(),
      n = Rt(),
      s = n.navigator.platform,
      r = e || n.navigator.userAgent,
      a = {
          ios: !1,
          android: !1
      },
      l = n.screen.width,
      o = n.screen.height,
      u = r.match(/(Android);?[\s\/]+([\d.]+)?/);
  let c = r.match(/(iPad).*OS\s([\d_]+)/);
  const h = r.match(/(iPod)(.*OS\s([\d_]+))?/),
      d = !c && r.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
      f = s === "Win32";
  let p = s === "MacIntel";
  const g = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  return !c && p && t.touch && g.indexOf(`${l}x${o}`) >= 0 && (c = r.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), p = !1), u && !f && (a.os = "android", a.android = !0), (c || d || h) && (a.os = "ios", a.ios = !0), a
}

function kp(i) {
  return i === void 0 && (i = {}), yl || (yl = Tk(i)), yl
}
let vl;

function Sk() {
  const i = Rt(),
      e = kp();
  let t = !1;

  function n() {
      const l = i.navigator.userAgent.toLowerCase();
      return l.indexOf("safari") >= 0 && l.indexOf("chrome") < 0 && l.indexOf("android") < 0
  }
  if (n()) {
      const l = String(i.navigator.userAgent);
      if (l.includes("Version/")) {
          const [o, u] = l.split("Version/")[1].split(" ")[0].split(".").map(c => Number(c));
          t = o < 16 || o === 16 && u < 2
      }
  }
  const s = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(i.navigator.userAgent),
      r = n(),
      a = r || s && e.ios;
  return {
      isSafari: t || r,
      needPerspectiveFix: t,
      need3dFix: a,
      isWebView: s
  }
}

function Ek() {
  return vl || (vl = Sk()), vl
}

function Ck(i) {
  let {
      swiper: e,
      on: t,
      emit: n
  } = i;
  const s = Rt();
  let r = null,
      a = null;
  const l = () => {
          !e || e.destroyed || !e.initialized || (n("beforeResize"), n("resize"))
      },
      o = () => {
          !e || e.destroyed || !e.initialized || (r = new ResizeObserver(h => {
              a = s.requestAnimationFrame(() => {
                  const {
                      width: d,
                      height: f
                  } = e;
                  let p = d,
                      g = f;
                  h.forEach(w => {
                      let {
                          contentBoxSize: y,
                          contentRect: b,
                          target: x
                      } = w;
                      x && x !== e.el || (p = b ? b.width : (y[0] || y).inlineSize, g = b ? b.height : (y[0] || y).blockSize)
                  }), (p !== d || g !== f) && l()
              })
          }), r.observe(e.el))
      },
      u = () => {
          a && s.cancelAnimationFrame(a), r && r.unobserve && e.el && (r.unobserve(e.el), r = null)
      },
      c = () => {
          !e || e.destroyed || !e.initialized || n("orientationchange")
      };
  t("init", () => {
      if (e.params.resizeObserver && typeof s.ResizeObserver < "u") {
          o();
          return
      }
      s.addEventListener("resize", l), s.addEventListener("orientationchange", c)
  }), t("destroy", () => {
      u(), s.removeEventListener("resize", l), s.removeEventListener("orientationchange", c)
  })
}

function $k(i) {
  let {
      swiper: e,
      extendParams: t,
      on: n,
      emit: s
  } = i;
  const r = [],
      a = Rt(),
      l = function(c, h) {
          h === void 0 && (h = {});
          const d = a.MutationObserver || a.WebkitMutationObserver,
              f = new d(p => {
                  if (e.__preventObserver__) return;
                  if (p.length === 1) {
                      s("observerUpdate", p[0]);
                      return
                  }
                  const g = function() {
                      s("observerUpdate", p[0])
                  };
                  a.requestAnimationFrame ? a.requestAnimationFrame(g) : a.setTimeout(g, 0)
              });
          f.observe(c, {
              attributes: typeof h.attributes > "u" ? !0 : h.attributes,
              childList: e.isElement || (typeof h.childList > "u" ? !0 : h).childList,
              characterData: typeof h.characterData > "u" ? !0 : h.characterData
          }), r.push(f)
      },
      o = () => {
          if (!!e.params.observer) {
              if (e.params.observeParents) {
                  const c = bp(e.hostEl);
                  for (let h = 0; h < c.length; h += 1) l(c[h])
              }
              l(e.hostEl, {
                  childList: e.params.observeSlideChildren
              }), l(e.wrapperEl, {
                  attributes: !1
              })
          }
      },
      u = () => {
          r.forEach(c => {
              c.disconnect()
          }), r.splice(0, r.length)
      };
  t({
      observer: !1,
      observeParents: !1,
      observeSlideChildren: !1
  }), n("init", o), n("destroy", u)
}
var Lk = {
  on(i, e, t) {
      const n = this;
      if (!n.eventsListeners || n.destroyed || typeof e != "function") return n;
      const s = t ? "unshift" : "push";
      return i.split(" ").forEach(r => {
          n.eventsListeners[r] || (n.eventsListeners[r] = []), n.eventsListeners[r][s](e)
      }), n
  },
  once(i, e, t) {
      const n = this;
      if (!n.eventsListeners || n.destroyed || typeof e != "function") return n;

      function s() {
          n.off(i, s), s.__emitterProxy && delete s.__emitterProxy;
          for (var r = arguments.length, a = new Array(r), l = 0; l < r; l++) a[l] = arguments[l];
          e.apply(n, a)
      }
      return s.__emitterProxy = e, n.on(i, s, t)
  },
  onAny(i, e) {
      const t = this;
      if (!t.eventsListeners || t.destroyed || typeof i != "function") return t;
      const n = e ? "unshift" : "push";
      return t.eventsAnyListeners.indexOf(i) < 0 && t.eventsAnyListeners[n](i), t
  },
  offAny(i) {
      const e = this;
      if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e;
      const t = e.eventsAnyListeners.indexOf(i);
      return t >= 0 && e.eventsAnyListeners.splice(t, 1), e
  },
  off(i, e) {
      const t = this;
      return !t.eventsListeners || t.destroyed || !t.eventsListeners || i.split(" ").forEach(n => {
          typeof e > "u" ? t.eventsListeners[n] = [] : t.eventsListeners[n] && t.eventsListeners[n].forEach((s, r) => {
              (s === e || s.__emitterProxy && s.__emitterProxy === e) && t.eventsListeners[n].splice(r, 1)
          })
      }), t
  },
  emit() {
      const i = this;
      if (!i.eventsListeners || i.destroyed || !i.eventsListeners) return i;
      let e, t, n;
      for (var s = arguments.length, r = new Array(s), a = 0; a < s; a++) r[a] = arguments[a];
      return typeof r[0] == "string" || Array.isArray(r[0]) ? (e = r[0], t = r.slice(1, r.length), n = i) : (e = r[0].events, t = r[0].data, n = r[0].context || i), t.unshift(n), (Array.isArray(e) ? e : e.split(" ")).forEach(o => {
          i.eventsAnyListeners && i.eventsAnyListeners.length && i.eventsAnyListeners.forEach(u => {
              u.apply(n, [o, ...t])
          }), i.eventsListeners && i.eventsListeners[o] && i.eventsListeners[o].forEach(u => {
              u.apply(n, t)
          })
      }), i
  }
};

function Pk() {
  const i = this;
  let e, t;
  const n = i.el;
  typeof i.params.width < "u" && i.params.width !== null ? e = i.params.width : e = n.clientWidth, typeof i.params.height < "u" && i.params.height !== null ? t = i.params.height : t = n.clientHeight, !(e === 0 && i.isHorizontal() || t === 0 && i.isVertical()) && (e = e - parseInt(Vi(n, "padding-left") || 0, 10) - parseInt(Vi(n, "padding-right") || 0, 10), t = t - parseInt(Vi(n, "padding-top") || 0, 10) - parseInt(Vi(n, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(i, {
      width: e,
      height: t,
      size: i.isHorizontal() ? e : t
  }))
}

function Ik() {
  const i = this;

  function e($, V) {
      return parseFloat($.getPropertyValue(i.getDirectionLabel(V)) || 0)
  }
  const t = i.params,
      {
          wrapperEl: n,
          slidesEl: s,
          size: r,
          rtlTranslate: a,
          wrongRTL: l
      } = i,
      o = i.virtual && t.virtual.enabled,
      u = o ? i.virtual.slides.length : i.slides.length,
      c = di(s, `.${i.params.slideClass}, swiper-slide`),
      h = o ? i.virtual.slides.length : c.length;
  let d = [];
  const f = [],
      p = [];
  let g = t.slidesOffsetBefore;
  typeof g == "function" && (g = t.slidesOffsetBefore.call(i));
  let w = t.slidesOffsetAfter;
  typeof w == "function" && (w = t.slidesOffsetAfter.call(i));
  const y = i.snapGrid.length,
      b = i.slidesGrid.length;
  let x = t.spaceBetween,
      k = -g,
      S = 0,
      B = 0;
  if (typeof r > "u") return;
  typeof x == "string" && x.indexOf("%") >= 0 ? x = parseFloat(x.replace("%", "")) / 100 * r : typeof x == "string" && (x = parseFloat(x)), i.virtualSize = -x, c.forEach($ => {
      a ? $.style.marginLeft = "" : $.style.marginRight = "", $.style.marginBottom = "", $.style.marginTop = ""
  }), t.centeredSlides && t.cssMode && (ur(n, "--swiper-centered-offset-before", ""), ur(n, "--swiper-centered-offset-after", ""));
  const D = t.grid && t.grid.rows > 1 && i.grid;
  D ? i.grid.initSlides(c) : i.grid && i.grid.unsetSlides();
  let P;
  const I = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter($ => typeof t.breakpoints[$].slidesPerView < "u").length > 0;
  for (let $ = 0; $ < h; $ += 1) {
      P = 0;
      let V;
      if (c[$] && (V = c[$]), D && i.grid.updateSlide($, V, c), !(c[$] && Vi(V, "display") === "none")) {
          if (t.slidesPerView === "auto") {
              I && (c[$].style[i.getDirectionLabel("width")] = "");
              const N = getComputedStyle(V),
                  O = V.style.transform,
                  se = V.style.webkitTransform;
              if (O && (V.style.transform = "none"), se && (V.style.webkitTransform = "none"), t.roundLengths) P = i.isHorizontal() ? go(V, "width", !0) : go(V, "height", !0);
              else {
                  const G = e(N, "width"),
                      te = e(N, "padding-left"),
                      le = e(N, "padding-right"),
                      ae = e(N, "margin-left"),
                      $e = e(N, "margin-right"),
                      Oe = N.getPropertyValue("box-sizing");
                  if (Oe && Oe === "border-box") P = G + ae + $e;
                  else {
                      const {
                          clientWidth: Ye,
                          offsetWidth: it
                      } = V;
                      P = G + te + le + ae + $e + (it - Ye)
                  }
              }
              O && (V.style.transform = O), se && (V.style.webkitTransform = se), t.roundLengths && (P = Math.floor(P))
          } else P = (r - (t.slidesPerView - 1) * x) / t.slidesPerView, t.roundLengths && (P = Math.floor(P)), c[$] && (c[$].style[i.getDirectionLabel("width")] = `${P}px`);
          c[$] && (c[$].swiperSlideSize = P), p.push(P), t.centeredSlides ? (k = k + P / 2 + S / 2 + x, S === 0 && $ !== 0 && (k = k - r / 2 - x), $ === 0 && (k = k - r / 2 - x), Math.abs(k) < 1 / 1e3 && (k = 0), t.roundLengths && (k = Math.floor(k)), B % t.slidesPerGroup === 0 && d.push(k), f.push(k)) : (t.roundLengths && (k = Math.floor(k)), (B - Math.min(i.params.slidesPerGroupSkip, B)) % i.params.slidesPerGroup === 0 && d.push(k), f.push(k), k = k + P + x), i.virtualSize += P + x, S = P, B += 1
      }
  }
  if (i.virtualSize = Math.max(i.virtualSize, r) + w, a && l && (t.effect === "slide" || t.effect === "coverflow") && (n.style.width = `${i.virtualSize+x}px`), t.setWrapperSize && (n.style[i.getDirectionLabel("width")] = `${i.virtualSize+x}px`), D && i.grid.updateWrapperSize(P, d), !t.centeredSlides) {
      const $ = [];
      for (let V = 0; V < d.length; V += 1) {
          let N = d[V];
          t.roundLengths && (N = Math.floor(N)), d[V] <= i.virtualSize - r && $.push(N)
      }
      d = $, Math.floor(i.virtualSize - r) - Math.floor(d[d.length - 1]) > 1 && d.push(i.virtualSize - r)
  }
  if (o && t.loop) {
      const $ = p[0] + x;
      if (t.slidesPerGroup > 1) {
          const V = Math.ceil((i.virtual.slidesBefore + i.virtual.slidesAfter) / t.slidesPerGroup),
              N = $ * t.slidesPerGroup;
          for (let O = 0; O < V; O += 1) d.push(d[d.length - 1] + N)
      }
      for (let V = 0; V < i.virtual.slidesBefore + i.virtual.slidesAfter; V += 1) t.slidesPerGroup === 1 && d.push(d[d.length - 1] + $), f.push(f[f.length - 1] + $), i.virtualSize += $
  }
  if (d.length === 0 && (d = [0]), x !== 0) {
      const $ = i.isHorizontal() && a ? "marginLeft" : i.getDirectionLabel("marginRight");
      c.filter((V, N) => !t.cssMode || t.loop ? !0 : N !== c.length - 1).forEach(V => {
          V.style[$] = `${x}px`
      })
  }
  if (t.centeredSlides && t.centeredSlidesBounds) {
      let $ = 0;
      p.forEach(N => {
          $ += N + (x || 0)
      }), $ -= x;
      const V = $ - r;
      d = d.map(N => N <= 0 ? -g : N > V ? V + w : N)
  }
  if (t.centerInsufficientSlides) {
      let $ = 0;
      p.forEach(N => {
          $ += N + (x || 0)
      }), $ -= x;
      const V = (t.slidesOffsetBefore || 0) + (t.slidesOffsetAfter || 0);
      if ($ + V < r) {
          const N = (r - $ - V) / 2;
          d.forEach((O, se) => {
              d[se] = O - N
          }), f.forEach((O, se) => {
              f[se] = O + N
          })
      }
  }
  if (Object.assign(i, {
          slides: c,
          snapGrid: d,
          slidesGrid: f,
          slidesSizesGrid: p
      }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) {
      ur(n, "--swiper-centered-offset-before", `${-d[0]}px`), ur(n, "--swiper-centered-offset-after", `${i.size/2-p[p.length-1]/2}px`);
      const $ = -i.snapGrid[0],
          V = -i.slidesGrid[0];
      i.snapGrid = i.snapGrid.map(N => N + $), i.slidesGrid = i.slidesGrid.map(N => N + V)
  }
  if (h !== u && i.emit("slidesLengthChange"), d.length !== y && (i.params.watchOverflow && i.checkOverflow(), i.emit("snapGridLengthChange")), f.length !== b && i.emit("slidesGridLengthChange"), t.watchSlidesProgress && i.updateSlidesOffset(), i.emit("slidesUpdated"), !o && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) {
      const $ = `${t.containerModifierClass}backface-hidden`,
          V = i.el.classList.contains($);
      h <= t.maxBackfaceHiddenSlides ? V || i.el.classList.add($) : V && i.el.classList.remove($)
  }
}

function Nk(i) {
  const e = this,
      t = [],
      n = e.virtual && e.params.virtual.enabled;
  let s = 0,
      r;
  typeof i == "number" ? e.setTransition(i) : i === !0 && e.setTransition(e.params.speed);
  const a = l => n ? e.slides[e.getSlideIndexByData(l)] : e.slides[l];
  if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1)
      if (e.params.centeredSlides)(e.visibleSlides || []).forEach(l => {
          t.push(l)
      });
      else
          for (r = 0; r < Math.ceil(e.params.slidesPerView); r += 1) {
              const l = e.activeIndex + r;
              if (l > e.slides.length && !n) break;
              t.push(a(l))
          } else t.push(a(e.activeIndex));
  for (r = 0; r < t.length; r += 1)
      if (typeof t[r] < "u") {
          const l = t[r].offsetHeight;
          s = l > s ? l : s
      }(s || s === 0) && (e.wrapperEl.style.height = `${s}px`)
}

function Mk() {
  const i = this,
      e = i.slides,
      t = i.isElement ? i.isHorizontal() ? i.wrapperEl.offsetLeft : i.wrapperEl.offsetTop : 0;
  for (let n = 0; n < e.length; n += 1) e[n].swiperSlideOffset = (i.isHorizontal() ? e[n].offsetLeft : e[n].offsetTop) - t - i.cssOverflowAdjustment()
}
const sh = (i, e, t) => {
  e && !i.classList.contains(t) ? i.classList.add(t) : !e && i.classList.contains(t) && i.classList.remove(t)
};

function Rk(i) {
  i === void 0 && (i = this && this.translate || 0);
  const e = this,
      t = e.params,
      {
          slides: n,
          rtlTranslate: s,
          snapGrid: r
      } = e;
  if (n.length === 0) return;
  typeof n[0].swiperSlideOffset > "u" && e.updateSlidesOffset();
  let a = -i;
  s && (a = i), e.visibleSlidesIndexes = [], e.visibleSlides = [];
  let l = t.spaceBetween;
  typeof l == "string" && l.indexOf("%") >= 0 ? l = parseFloat(l.replace("%", "")) / 100 * e.size : typeof l == "string" && (l = parseFloat(l));
  for (let o = 0; o < n.length; o += 1) {
      const u = n[o];
      let c = u.swiperSlideOffset;
      t.cssMode && t.centeredSlides && (c -= n[0].swiperSlideOffset);
      const h = (a + (t.centeredSlides ? e.minTranslate() : 0) - c) / (u.swiperSlideSize + l),
          d = (a - r[0] + (t.centeredSlides ? e.minTranslate() : 0) - c) / (u.swiperSlideSize + l),
          f = -(a - c),
          p = f + e.slidesSizesGrid[o],
          g = f >= 0 && f <= e.size - e.slidesSizesGrid[o],
          w = f >= 0 && f < e.size - 1 || p > 1 && p <= e.size || f <= 0 && p >= e.size;
      w && (e.visibleSlides.push(u), e.visibleSlidesIndexes.push(o)), sh(u, w, t.slideVisibleClass), sh(u, g, t.slideFullyVisibleClass), u.progress = s ? -h : h, u.originalProgress = s ? -d : d
  }
}

function Bk(i) {
  const e = this;
  if (typeof i > "u") {
      const c = e.rtlTranslate ? -1 : 1;
      i = e && e.translate && e.translate * c || 0
  }
  const t = e.params,
      n = e.maxTranslate() - e.minTranslate();
  let {
      progress: s,
      isBeginning: r,
      isEnd: a,
      progressLoop: l
  } = e;
  const o = r,
      u = a;
  if (n === 0) s = 0, r = !0, a = !0;
  else {
      s = (i - e.minTranslate()) / n;
      const c = Math.abs(i - e.minTranslate()) < 1,
          h = Math.abs(i - e.maxTranslate()) < 1;
      r = c || s <= 0, a = h || s >= 1, c && (s = 0), h && (s = 1)
  }
  if (t.loop) {
      const c = e.getSlideIndexByData(0),
          h = e.getSlideIndexByData(e.slides.length - 1),
          d = e.slidesGrid[c],
          f = e.slidesGrid[h],
          p = e.slidesGrid[e.slidesGrid.length - 1],
          g = Math.abs(i);
      g >= d ? l = (g - d) / p : l = (g + p - f) / p, l > 1 && (l -= 1)
  }
  Object.assign(e, {
      progress: s,
      progressLoop: l,
      isBeginning: r,
      isEnd: a
  }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(i), r && !o && e.emit("reachBeginning toEdge"), a && !u && e.emit("reachEnd toEdge"), (o && !r || u && !a) && e.emit("fromEdge"), e.emit("progress", s)
}
const bl = (i, e, t) => {
  e && !i.classList.contains(t) ? i.classList.add(t) : !e && i.classList.contains(t) && i.classList.remove(t)
};

function Ok() {
  const i = this,
      {
          slides: e,
          params: t,
          slidesEl: n,
          activeIndex: s
      } = i,
      r = i.virtual && t.virtual.enabled,
      a = i.grid && t.grid && t.grid.rows > 1,
      l = h => di(n, `.${t.slideClass}${h}, swiper-slide${h}`)[0];
  let o, u, c;
  if (r)
      if (t.loop) {
          let h = s - i.virtual.slidesBefore;
          h < 0 && (h = i.virtual.slides.length + h), h >= i.virtual.slides.length && (h -= i.virtual.slides.length), o = l(`[data-swiper-slide-index="${h}"]`)
      } else o = l(`[data-swiper-slide-index="${s}"]`);
  else a ? (o = e.filter(h => h.column === s)[0], c = e.filter(h => h.column === s + 1)[0], u = e.filter(h => h.column === s - 1)[0]) : o = e[s];
  o && (a || (c = _k(o, `.${t.slideClass}, swiper-slide`)[0], t.loop && !c && (c = e[0]), u = kk(o, `.${t.slideClass}, swiper-slide`)[0], t.loop && !u === 0 && (u = e[e.length - 1]))), e.forEach(h => {
      bl(h, h === o, t.slideActiveClass), bl(h, h === c, t.slideNextClass), bl(h, h === u, t.slidePrevClass)
  }), i.emitSlidesClasses()
}
const Cr = (i, e) => {
      if (!i || i.destroyed || !i.params) return;
      const t = () => i.isElement ? "swiper-slide" : `.${i.params.slideClass}`,
          n = e.closest(t());
      if (n) {
          let s = n.querySelector(`.${i.params.lazyPreloaderClass}`);
          !s && i.isElement && (n.shadowRoot ? s = n.shadowRoot.querySelector(`.${i.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
              n.shadowRoot && (s = n.shadowRoot.querySelector(`.${i.params.lazyPreloaderClass}`), s && s.remove())
          })), s && s.remove()
      }
  },
  wl = (i, e) => {
      if (!i.slides[e]) return;
      const t = i.slides[e].querySelector('[loading="lazy"]');
      t && t.removeAttribute("loading")
  },
  yo = i => {
      if (!i || i.destroyed || !i.params) return;
      let e = i.params.lazyPreloadPrevNext;
      const t = i.slides.length;
      if (!t || !e || e < 0) return;
      e = Math.min(e, t);
      const n = i.params.slidesPerView === "auto" ? i.slidesPerViewDynamic() : Math.ceil(i.params.slidesPerView),
          s = i.activeIndex;
      if (i.params.grid && i.params.grid.rows > 1) {
          const a = s,
              l = [a - e];
          l.push(...Array.from({
              length: e
          }).map((o, u) => a + n + u)), i.slides.forEach((o, u) => {
              l.includes(o.column) && wl(i, u)
          });
          return
      }
      const r = s + n - 1;
      if (i.params.rewind || i.params.loop)
          for (let a = s - e; a <= r + e; a += 1) {
              const l = (a % t + t) % t;
              (l < s || l > r) && wl(i, l)
          } else
              for (let a = Math.max(s - e, 0); a <= Math.min(r + e, t - 1); a += 1) a !== s && (a > r || a < s) && wl(i, a)
  };

function Dk(i) {
  const {
      slidesGrid: e,
      params: t
  } = i, n = i.rtlTranslate ? i.translate : -i.translate;
  let s;
  for (let r = 0; r < e.length; r += 1) typeof e[r + 1] < "u" ? n >= e[r] && n < e[r + 1] - (e[r + 1] - e[r]) / 2 ? s = r : n >= e[r] && n < e[r + 1] && (s = r + 1) : n >= e[r] && (s = r);
  return t.normalizeSlideIndex && (s < 0 || typeof s > "u") && (s = 0), s
}

function Fk(i) {
  const e = this,
      t = e.rtlTranslate ? e.translate : -e.translate,
      {
          snapGrid: n,
          params: s,
          activeIndex: r,
          realIndex: a,
          snapIndex: l
      } = e;
  let o = i,
      u;
  const c = f => {
      let p = f - e.virtual.slidesBefore;
      return p < 0 && (p = e.virtual.slides.length + p), p >= e.virtual.slides.length && (p -= e.virtual.slides.length), p
  };
  if (typeof o > "u" && (o = Dk(e)), n.indexOf(t) >= 0) u = n.indexOf(t);
  else {
      const f = Math.min(s.slidesPerGroupSkip, o);
      u = f + Math.floor((o - f) / s.slidesPerGroup)
  }
  if (u >= n.length && (u = n.length - 1), o === r && !e.params.loop) {
      u !== l && (e.snapIndex = u, e.emit("snapIndexChange"));
      return
  }
  if (o === r && e.params.loop && e.virtual && e.params.virtual.enabled) {
      e.realIndex = c(o);
      return
  }
  const h = e.grid && s.grid && s.grid.rows > 1;
  let d;
  if (e.virtual && s.virtual.enabled && s.loop) d = c(o);
  else if (h) {
      const f = e.slides.filter(g => g.column === o)[0];
      let p = parseInt(f.getAttribute("data-swiper-slide-index"), 10);
      Number.isNaN(p) && (p = Math.max(e.slides.indexOf(f), 0)), d = Math.floor(p / s.grid.rows)
  } else if (e.slides[o]) {
      const f = e.slides[o].getAttribute("data-swiper-slide-index");
      f ? d = parseInt(f, 10) : d = o
  } else d = o;
  Object.assign(e, {
      previousSnapIndex: l,
      snapIndex: u,
      previousRealIndex: a,
      realIndex: d,
      previousIndex: r,
      activeIndex: o
  }), e.initialized && yo(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (a !== d && e.emit("realIndexChange"), e.emit("slideChange"))
}

function Ak(i, e) {
  const t = this,
      n = t.params;
  let s = i.closest(`.${n.slideClass}, swiper-slide`);
  !s && t.isElement && e && e.length > 1 && e.includes(i) && [...e.slice(e.indexOf(i) + 1, e.length)].forEach(l => {
      !s && l.matches && l.matches(`.${n.slideClass}, swiper-slide`) && (s = l)
  });
  let r = !1,
      a;
  if (s) {
      for (let l = 0; l < t.slides.length; l += 1)
          if (t.slides[l] === s) {
              r = !0, a = l;
              break
          }
  }
  if (s && r) t.clickedSlide = s, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(s.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = a;
  else {
      t.clickedSlide = void 0, t.clickedIndex = void 0;
      return
  }
  n.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide()
}
var Vk = {
  updateSize: Pk,
  updateSlides: Ik,
  updateAutoHeight: Nk,
  updateSlidesOffset: Mk,
  updateSlidesProgress: Rk,
  updateProgress: Bk,
  updateSlidesClasses: Ok,
  updateActiveIndex: Fk,
  updateClickedSlide: Ak
};

function zk(i) {
  i === void 0 && (i = this.isHorizontal() ? "x" : "y");
  const e = this,
      {
          params: t,
          rtlTranslate: n,
          translate: s,
          wrapperEl: r
      } = e;
  if (t.virtualTranslate) return n ? -s : s;
  if (t.cssMode) return s;
  let a = vk(r, i);
  return a += e.cssOverflowAdjustment(), n && (a = -a), a || 0
}

function Wk(i, e) {
  const t = this,
      {
          rtlTranslate: n,
          params: s,
          wrapperEl: r,
          progress: a
      } = t;
  let l = 0,
      o = 0;
  const u = 0;
  t.isHorizontal() ? l = n ? -i : i : o = i, s.roundLengths && (l = Math.floor(l), o = Math.floor(o)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? l : o, s.cssMode ? r[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -l : -o : s.virtualTranslate || (t.isHorizontal() ? l -= t.cssOverflowAdjustment() : o -= t.cssOverflowAdjustment(), r.style.transform = `translate3d(${l}px, ${o}px, ${u}px)`);
  let c;
  const h = t.maxTranslate() - t.minTranslate();
  h === 0 ? c = 0 : c = (i - t.minTranslate()) / h, c !== a && t.updateProgress(i), t.emit("setTranslate", t.translate, e)
}

function Uk() {
  return -this.snapGrid[0]
}

function jk() {
  return -this.snapGrid[this.snapGrid.length - 1]
}

function Hk(i, e, t, n, s) {
  i === void 0 && (i = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), n === void 0 && (n = !0);
  const r = this,
      {
          params: a,
          wrapperEl: l
      } = r;
  if (r.animating && a.preventInteractionOnTransition) return !1;
  const o = r.minTranslate(),
      u = r.maxTranslate();
  let c;
  if (n && i > o ? c = o : n && i < u ? c = u : c = i, r.updateProgress(c), a.cssMode) {
      const h = r.isHorizontal();
      if (e === 0) l[h ? "scrollLeft" : "scrollTop"] = -c;
      else {
          if (!r.support.smoothScroll) return vp({
              swiper: r,
              targetPosition: -c,
              side: h ? "left" : "top"
          }), !0;
          l.scrollTo({
              [h ? "left" : "top"]: -c,
              behavior: "smooth"
          })
      }
      return !0
  }
  return e === 0 ? (r.setTransition(0), r.setTranslate(c), t && (r.emit("beforeTransitionStart", e, s), r.emit("transitionEnd"))) : (r.setTransition(e), r.setTranslate(c), t && (r.emit("beforeTransitionStart", e, s), r.emit("transitionStart")), r.animating || (r.animating = !0, r.onTranslateToWrapperTransitionEnd || (r.onTranslateToWrapperTransitionEnd = function(d) {
      !r || r.destroyed || d.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onTranslateToWrapperTransitionEnd), r.onTranslateToWrapperTransitionEnd = null, delete r.onTranslateToWrapperTransitionEnd, r.animating = !1, t && r.emit("transitionEnd"))
  }), r.wrapperEl.addEventListener("transitionend", r.onTranslateToWrapperTransitionEnd))), !0
}
var qk = {
  getTranslate: zk,
  setTranslate: Wk,
  minTranslate: Uk,
  maxTranslate: jk,
  translateTo: Hk
};

function Gk(i, e) {
  const t = this;
  t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${i}ms`, t.wrapperEl.style.transitionDelay = i === 0 ? "0ms" : ""), t.emit("setTransition", i, e)
}

function _p(i) {
  let {
      swiper: e,
      runCallbacks: t,
      direction: n,
      step: s
  } = i;
  const {
      activeIndex: r,
      previousIndex: a
  } = e;
  let l = n;
  if (l || (r > a ? l = "next" : r < a ? l = "prev" : l = "reset"), e.emit(`transition${s}`), t && r !== a) {
      if (l === "reset") {
          e.emit(`slideResetTransition${s}`);
          return
      }
      e.emit(`slideChangeTransition${s}`), l === "next" ? e.emit(`slideNextTransition${s}`) : e.emit(`slidePrevTransition${s}`)
  }
}

function Kk(i, e) {
  i === void 0 && (i = !0);
  const t = this,
      {
          params: n
      } = t;
  n.cssMode || (n.autoHeight && t.updateAutoHeight(), _p({
      swiper: t,
      runCallbacks: i,
      direction: e,
      step: "Start"
  }))
}

function Xk(i, e) {
  i === void 0 && (i = !0);
  const t = this,
      {
          params: n
      } = t;
  t.animating = !1, !n.cssMode && (t.setTransition(0), _p({
      swiper: t,
      runCallbacks: i,
      direction: e,
      step: "End"
  }))
}
var Jk = {
  setTransition: Gk,
  transitionStart: Kk,
  transitionEnd: Xk
};

function Yk(i, e, t, n, s) {
  i === void 0 && (i = 0), t === void 0 && (t = !0), typeof i == "string" && (i = parseInt(i, 10));
  const r = this;
  let a = i;
  a < 0 && (a = 0);
  const {
      params: l,
      snapGrid: o,
      slidesGrid: u,
      previousIndex: c,
      activeIndex: h,
      rtlTranslate: d,
      wrapperEl: f,
      enabled: p
  } = r;
  if (!p && !n && !s || r.destroyed || r.animating && l.preventInteractionOnTransition) return !1;
  typeof e > "u" && (e = r.params.speed);
  const g = Math.min(r.params.slidesPerGroupSkip, a);
  let w = g + Math.floor((a - g) / r.params.slidesPerGroup);
  w >= o.length && (w = o.length - 1);
  const y = -o[w];
  if (l.normalizeSlideIndex)
      for (let x = 0; x < u.length; x += 1) {
          const k = -Math.floor(y * 100),
              S = Math.floor(u[x] * 100),
              B = Math.floor(u[x + 1] * 100);
          typeof u[x + 1] < "u" ? k >= S && k < B - (B - S) / 2 ? a = x : k >= S && k < B && (a = x + 1) : k >= S && (a = x)
      }
  if (r.initialized && a !== h && (!r.allowSlideNext && (d ? y > r.translate && y > r.minTranslate() : y < r.translate && y < r.minTranslate()) || !r.allowSlidePrev && y > r.translate && y > r.maxTranslate() && (h || 0) !== a)) return !1;
  a !== (c || 0) && t && r.emit("beforeSlideChangeStart"), r.updateProgress(y);
  let b;
  if (a > h ? b = "next" : a < h ? b = "prev" : b = "reset", d && -y === r.translate || !d && y === r.translate) return r.updateActiveIndex(a), l.autoHeight && r.updateAutoHeight(), r.updateSlidesClasses(), l.effect !== "slide" && r.setTranslate(y), b !== "reset" && (r.transitionStart(t, b), r.transitionEnd(t, b)), !1;
  if (l.cssMode) {
      const x = r.isHorizontal(),
          k = d ? y : -y;
      if (e === 0) {
          const S = r.virtual && r.params.virtual.enabled;
          S && (r.wrapperEl.style.scrollSnapType = "none", r._immediateVirtual = !0), S && !r._cssModeVirtualInitialSet && r.params.initialSlide > 0 ? (r._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
              f[x ? "scrollLeft" : "scrollTop"] = k
          })) : f[x ? "scrollLeft" : "scrollTop"] = k, S && requestAnimationFrame(() => {
              r.wrapperEl.style.scrollSnapType = "", r._immediateVirtual = !1
          })
      } else {
          if (!r.support.smoothScroll) return vp({
              swiper: r,
              targetPosition: k,
              side: x ? "left" : "top"
          }), !0;
          f.scrollTo({
              [x ? "left" : "top"]: k,
              behavior: "smooth"
          })
      }
      return !0
  }
  return r.setTransition(e), r.setTranslate(y), r.updateActiveIndex(a), r.updateSlidesClasses(), r.emit("beforeTransitionStart", e, n), r.transitionStart(t, b), e === 0 ? r.transitionEnd(t, b) : r.animating || (r.animating = !0, r.onSlideToWrapperTransitionEnd || (r.onSlideToWrapperTransitionEnd = function(k) {
      !r || r.destroyed || k.target === this && (r.wrapperEl.removeEventListener("transitionend", r.onSlideToWrapperTransitionEnd), r.onSlideToWrapperTransitionEnd = null, delete r.onSlideToWrapperTransitionEnd, r.transitionEnd(t, b))
  }), r.wrapperEl.addEventListener("transitionend", r.onSlideToWrapperTransitionEnd)), !0
}

function Qk(i, e, t, n) {
  i === void 0 && (i = 0), t === void 0 && (t = !0), typeof i == "string" && (i = parseInt(i, 10));
  const s = this;
  if (s.destroyed) return;
  typeof e > "u" && (e = s.params.speed);
  const r = s.grid && s.params.grid && s.params.grid.rows > 1;
  let a = i;
  if (s.params.loop)
      if (s.virtual && s.params.virtual.enabled) a = a + s.virtual.slidesBefore;
      else {
          let l;
          if (r) {
              const d = a * s.params.grid.rows;
              l = s.slides.filter(f => f.getAttribute("data-swiper-slide-index") * 1 === d)[0].column
          } else l = s.getSlideIndexByData(a);
          const o = r ? Math.ceil(s.slides.length / s.params.grid.rows) : s.slides.length,
              {
                  centeredSlides: u
              } = s.params;
          let c = s.params.slidesPerView;
          c === "auto" ? c = s.slidesPerViewDynamic() : (c = Math.ceil(parseFloat(s.params.slidesPerView, 10)), u && c % 2 === 0 && (c = c + 1));
          let h = o - l < c;
          if (u && (h = h || l < Math.ceil(c / 2)), n && u && s.params.slidesPerView !== "auto" && !r && (h = !1), h) {
              const d = u ? l < s.activeIndex ? "prev" : "next" : l - s.activeIndex - 1 < s.params.slidesPerView ? "next" : "prev";
              s.loopFix({
                  direction: d,
                  slideTo: !0,
                  activeSlideIndex: d === "next" ? l + 1 : l - o + 1,
                  slideRealIndex: d === "next" ? s.realIndex : void 0
              })
          }
          if (r) {
              const d = a * s.params.grid.rows;
              a = s.slides.filter(f => f.getAttribute("data-swiper-slide-index") * 1 === d)[0].column
          } else a = s.getSlideIndexByData(a)
      } return requestAnimationFrame(() => {
      s.slideTo(a, e, t, n)
  }), s
}

function Zk(i, e, t) {
  e === void 0 && (e = !0);
  const n = this,
      {
          enabled: s,
          params: r,
          animating: a
      } = n;
  if (!s || n.destroyed) return n;
  typeof i > "u" && (i = n.params.speed);
  let l = r.slidesPerGroup;
  r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (l = Math.max(n.slidesPerViewDynamic("current", !0), 1));
  const o = n.activeIndex < r.slidesPerGroupSkip ? 1 : l,
      u = n.virtual && r.virtual.enabled;
  if (r.loop) {
      if (a && !u && r.loopPreventsSliding) return !1;
      if (n.loopFix({
              direction: "next"
          }), n._clientLeft = n.wrapperEl.clientLeft, n.activeIndex === n.slides.length - 1 && r.cssMode) return requestAnimationFrame(() => {
          n.slideTo(n.activeIndex + o, i, e, t)
      }), !0
  }
  return r.rewind && n.isEnd ? n.slideTo(0, i, e, t) : n.slideTo(n.activeIndex + o, i, e, t)
}

function e_(i, e, t) {
  e === void 0 && (e = !0);
  const n = this,
      {
          params: s,
          snapGrid: r,
          slidesGrid: a,
          rtlTranslate: l,
          enabled: o,
          animating: u
      } = n;
  if (!o || n.destroyed) return n;
  typeof i > "u" && (i = n.params.speed);
  const c = n.virtual && s.virtual.enabled;
  if (s.loop) {
      if (u && !c && s.loopPreventsSliding) return !1;
      n.loopFix({
          direction: "prev"
      }), n._clientLeft = n.wrapperEl.clientLeft
  }
  const h = l ? n.translate : -n.translate;

  function d(y) {
      return y < 0 ? -Math.floor(Math.abs(y)) : Math.floor(y)
  }
  const f = d(h),
      p = r.map(y => d(y));
  let g = r[p.indexOf(f) - 1];
  if (typeof g > "u" && s.cssMode) {
      let y;
      r.forEach((b, x) => {
          f >= b && (y = x)
      }), typeof y < "u" && (g = r[y > 0 ? y - 1 : y])
  }
  let w = 0;
  if (typeof g < "u" && (w = a.indexOf(g), w < 0 && (w = n.activeIndex - 1), s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (w = w - n.slidesPerViewDynamic("previous", !0) + 1, w = Math.max(w, 0))), s.rewind && n.isBeginning) {
      const y = n.params.virtual && n.params.virtual.enabled && n.virtual ? n.virtual.slides.length - 1 : n.slides.length - 1;
      return n.slideTo(y, i, e, t)
  } else if (s.loop && n.activeIndex === 0 && s.cssMode) return requestAnimationFrame(() => {
      n.slideTo(w, i, e, t)
  }), !0;
  return n.slideTo(w, i, e, t)
}

function t_(i, e, t) {
  e === void 0 && (e = !0);
  const n = this;
  if (!n.destroyed) return typeof i > "u" && (i = n.params.speed), n.slideTo(n.activeIndex, i, e, t)
}

function i_(i, e, t, n) {
  e === void 0 && (e = !0), n === void 0 && (n = .5);
  const s = this;
  if (s.destroyed) return;
  typeof i > "u" && (i = s.params.speed);
  let r = s.activeIndex;
  const a = Math.min(s.params.slidesPerGroupSkip, r),
      l = a + Math.floor((r - a) / s.params.slidesPerGroup),
      o = s.rtlTranslate ? s.translate : -s.translate;
  if (o >= s.snapGrid[l]) {
      const u = s.snapGrid[l],
          c = s.snapGrid[l + 1];
      o - u > (c - u) * n && (r += s.params.slidesPerGroup)
  } else {
      const u = s.snapGrid[l - 1],
          c = s.snapGrid[l];
      o - u <= (c - u) * n && (r -= s.params.slidesPerGroup)
  }
  return r = Math.max(r, 0), r = Math.min(r, s.slidesGrid.length - 1), s.slideTo(r, i, e, t)
}

function n_() {
  const i = this;
  if (i.destroyed) return;
  const {
      params: e,
      slidesEl: t
  } = i, n = e.slidesPerView === "auto" ? i.slidesPerViewDynamic() : e.slidesPerView;
  let s = i.clickedIndex,
      r;
  const a = i.isElement ? "swiper-slide" : `.${e.slideClass}`;
  if (e.loop) {
      if (i.animating) return;
      r = parseInt(i.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? s < i.loopedSlides - n / 2 || s > i.slides.length - i.loopedSlides + n / 2 ? (i.loopFix(), s = i.getSlideIndex(di(t, `${a}[data-swiper-slide-index="${r}"]`)[0]), mo(() => {
          i.slideTo(s)
      })) : i.slideTo(s) : s > i.slides.length - n ? (i.loopFix(), s = i.getSlideIndex(di(t, `${a}[data-swiper-slide-index="${r}"]`)[0]), mo(() => {
          i.slideTo(s)
      })) : i.slideTo(s)
  } else i.slideTo(s)
}
var s_ = {
  slideTo: Yk,
  slideToLoop: Qk,
  slideNext: Zk,
  slidePrev: e_,
  slideReset: t_,
  slideToClosest: i_,
  slideToClickedSlide: n_
};

function r_(i) {
  const e = this,
      {
          params: t,
          slidesEl: n
      } = e;
  if (!t.loop || e.virtual && e.params.virtual.enabled) return;
  const s = () => {
          di(n, `.${t.slideClass}, swiper-slide`).forEach((h, d) => {
              h.setAttribute("data-swiper-slide-index", d)
          })
      },
      r = e.grid && t.grid && t.grid.rows > 1,
      a = t.slidesPerGroup * (r ? t.grid.rows : 1),
      l = e.slides.length % a !== 0,
      o = r && e.slides.length % t.grid.rows !== 0,
      u = c => {
          for (let h = 0; h < c; h += 1) {
              const d = e.isElement ? Kr("swiper-slide", [t.slideBlankClass]) : Kr("div", [t.slideClass, t.slideBlankClass]);
              e.slidesEl.append(d)
          }
      };
  if (l) {
      if (t.loopAddBlankSlides) {
          const c = a - e.slides.length % a;
          u(c), e.recalcSlides(), e.updateSlides()
      } else Gr("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      s()
  } else if (o) {
      if (t.loopAddBlankSlides) {
          const c = t.grid.rows - e.slides.length % t.grid.rows;
          u(c), e.recalcSlides(), e.updateSlides()
      } else Gr("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
      s()
  } else s();
  e.loopFix({
      slideRealIndex: i,
      direction: t.centeredSlides ? void 0 : "next"
  })
}

function a_(i) {
  let {
      slideRealIndex: e,
      slideTo: t = !0,
      direction: n,
      setTranslate: s,
      activeSlideIndex: r,
      byController: a,
      byMousewheel: l
  } = i === void 0 ? {} : i;
  const o = this;
  if (!o.params.loop) return;
  o.emit("beforeLoopFix");
  const {
      slides: u,
      allowSlidePrev: c,
      allowSlideNext: h,
      slidesEl: d,
      params: f
  } = o, {
      centeredSlides: p
  } = f;
  if (o.allowSlidePrev = !0, o.allowSlideNext = !0, o.virtual && f.virtual.enabled) {
      t && (!f.centeredSlides && o.snapIndex === 0 ? o.slideTo(o.virtual.slides.length, 0, !1, !0) : f.centeredSlides && o.snapIndex < f.slidesPerView ? o.slideTo(o.virtual.slides.length + o.snapIndex, 0, !1, !0) : o.snapIndex === o.snapGrid.length - 1 && o.slideTo(o.virtual.slidesBefore, 0, !1, !0)), o.allowSlidePrev = c, o.allowSlideNext = h, o.emit("loopFix");
      return
  }
  let g = f.slidesPerView;
  g === "auto" ? g = o.slidesPerViewDynamic() : (g = Math.ceil(parseFloat(f.slidesPerView, 10)), p && g % 2 === 0 && (g = g + 1));
  const w = f.slidesPerGroupAuto ? g : f.slidesPerGroup;
  let y = w;
  y % w !== 0 && (y += w - y % w), y += f.loopAdditionalSlides, o.loopedSlides = y;
  const b = o.grid && f.grid && f.grid.rows > 1;
  u.length < g + y ? Gr("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : b && f.grid.fill === "row" && Gr("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
  const x = [],
      k = [];
  let S = o.activeIndex;
  typeof r > "u" ? r = o.getSlideIndex(u.filter(O => O.classList.contains(f.slideActiveClass))[0]) : S = r;
  const B = n === "next" || !n,
      D = n === "prev" || !n;
  let P = 0,
      I = 0;
  const $ = b ? Math.ceil(u.length / f.grid.rows) : u.length,
      N = (b ? u[r].column : r) + (p && typeof s > "u" ? -g / 2 + .5 : 0);
  if (N < y) {
      P = Math.max(y - N, w);
      for (let O = 0; O < y - N; O += 1) {
          const se = O - Math.floor(O / $) * $;
          if (b) {
              const G = $ - se - 1;
              for (let te = u.length - 1; te >= 0; te -= 1) u[te].column === G && x.push(te)
          } else x.push($ - se - 1)
      }
  } else if (N + g > $ - y) {
      I = Math.max(N - ($ - y * 2), w);
      for (let O = 0; O < I; O += 1) {
          const se = O - Math.floor(O / $) * $;
          b ? u.forEach((G, te) => {
              G.column === se && k.push(te)
          }) : k.push(se)
      }
  }
  if (o.__preventObserver__ = !0, requestAnimationFrame(() => {
          o.__preventObserver__ = !1
      }), D && x.forEach(O => {
          u[O].swiperLoopMoveDOM = !0, d.prepend(u[O]), u[O].swiperLoopMoveDOM = !1
      }), B && k.forEach(O => {
          u[O].swiperLoopMoveDOM = !0, d.append(u[O]), u[O].swiperLoopMoveDOM = !1
      }), o.recalcSlides(), f.slidesPerView === "auto" ? o.updateSlides() : b && (x.length > 0 && D || k.length > 0 && B) && o.slides.forEach((O, se) => {
          o.grid.updateSlide(se, O, o.slides)
      }), f.watchSlidesProgress && o.updateSlidesOffset(), t) {
      if (x.length > 0 && D) {
          if (typeof e > "u") {
              const O = o.slidesGrid[S],
                  G = o.slidesGrid[S + P] - O;
              l ? o.setTranslate(o.translate - G) : (o.slideTo(S + Math.ceil(P), 0, !1, !0), s && (o.touchEventsData.startTranslate = o.touchEventsData.startTranslate - G, o.touchEventsData.currentTranslate = o.touchEventsData.currentTranslate - G))
          } else if (s) {
              const O = b ? x.length / f.grid.rows : x.length;
              o.slideTo(o.activeIndex + O, 0, !1, !0), o.touchEventsData.currentTranslate = o.translate
          }
      } else if (k.length > 0 && B)
          if (typeof e > "u") {
              const O = o.slidesGrid[S],
                  G = o.slidesGrid[S - I] - O;
              l ? o.setTranslate(o.translate - G) : (o.slideTo(S - I, 0, !1, !0), s && (o.touchEventsData.startTranslate = o.touchEventsData.startTranslate - G, o.touchEventsData.currentTranslate = o.touchEventsData.currentTranslate - G))
          } else {
              const O = b ? k.length / f.grid.rows : k.length;
              o.slideTo(o.activeIndex - O, 0, !1, !0)
          }
  }
  if (o.allowSlidePrev = c, o.allowSlideNext = h, o.controller && o.controller.control && !a) {
      const O = {
          slideRealIndex: e,
          direction: n,
          setTranslate: s,
          activeSlideIndex: r,
          byController: !0
      };
      Array.isArray(o.controller.control) ? o.controller.control.forEach(se => {
          !se.destroyed && se.params.loop && se.loopFix({
              ...O,
              slideTo: se.params.slidesPerView === f.slidesPerView ? t : !1
          })
      }) : o.controller.control instanceof o.constructor && o.controller.control.params.loop && o.controller.control.loopFix({
          ...O,
          slideTo: o.controller.control.params.slidesPerView === f.slidesPerView ? t : !1
      })
  }
  o.emit("loopFix")
}

function l_() {
  const i = this,
      {
          params: e,
          slidesEl: t
      } = i;
  if (!e.loop || i.virtual && i.params.virtual.enabled) return;
  i.recalcSlides();
  const n = [];
  i.slides.forEach(s => {
      const r = typeof s.swiperSlideIndex > "u" ? s.getAttribute("data-swiper-slide-index") * 1 : s.swiperSlideIndex;
      n[r] = s
  }), i.slides.forEach(s => {
      s.removeAttribute("data-swiper-slide-index")
  }), n.forEach(s => {
      t.append(s)
  }), i.recalcSlides(), i.slideTo(i.realIndex, 0)
}
var o_ = {
  loopCreate: r_,
  loopFix: a_,
  loopDestroy: l_
};

function u_(i) {
  const e = this;
  if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return;
  const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl;
  e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = i ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => {
      e.__preventObserver__ = !1
  })
}

function c_() {
  const i = this;
  i.params.watchOverflow && i.isLocked || i.params.cssMode || (i.isElement && (i.__preventObserver__ = !0), i[i.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", i.isElement && requestAnimationFrame(() => {
      i.__preventObserver__ = !1
  }))
}
var h_ = {
  setGrabCursor: u_,
  unsetGrabCursor: c_
};

function d_(i, e) {
  e === void 0 && (e = this);

  function t(n) {
      if (!n || n === Ci() || n === Rt()) return null;
      n.assignedSlot && (n = n.assignedSlot);
      const s = n.closest(i);
      return !s && !n.getRootNode ? null : s || t(n.getRootNode().host)
  }
  return t(e)
}

function rh(i, e, t) {
  const n = Rt(),
      {
          params: s
      } = i,
      r = s.edgeSwipeDetection,
      a = s.edgeSwipeThreshold;
  return r && (t <= a || t >= n.innerWidth - a) ? r === "prevent" ? (e.preventDefault(), !0) : !1 : !0
}

function f_(i) {
  const e = this,
      t = Ci();
  let n = i;
  n.originalEvent && (n = n.originalEvent);
  const s = e.touchEventsData;
  if (n.type === "pointerdown") {
      if (s.pointerId !== null && s.pointerId !== n.pointerId) return;
      s.pointerId = n.pointerId
  } else n.type === "touchstart" && n.targetTouches.length === 1 && (s.touchId = n.targetTouches[0].identifier);
  if (n.type === "touchstart") {
      rh(e, n, n.targetTouches[0].pageX);
      return
  }
  const {
      params: r,
      touches: a,
      enabled: l
  } = e;
  if (!l || !r.simulateTouch && n.pointerType === "mouse" || e.animating && r.preventInteractionOnTransition) return;
  !e.animating && r.cssMode && r.loop && e.loopFix();
  let o = n.target;
  if (r.touchEventsTarget === "wrapper" && !wk(o, e.wrapperEl) || "which" in n && n.which === 3 || "button" in n && n.button > 0 || s.isTouched && s.isMoved) return;
  const u = !!r.noSwipingClass && r.noSwipingClass !== "",
      c = n.composedPath ? n.composedPath() : n.path;
  u && n.target && n.target.shadowRoot && c && (o = c[0]);
  const h = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`,
      d = !!(n.target && n.target.shadowRoot);
  if (r.noSwiping && (d ? d_(h, o) : o.closest(h))) {
      e.allowClick = !0;
      return
  }
  if (r.swipeHandler && !o.closest(r.swipeHandler)) return;
  a.currentX = n.pageX, a.currentY = n.pageY;
  const f = a.currentX,
      p = a.currentY;
  if (!rh(e, n, f)) return;
  Object.assign(s, {
      isTouched: !0,
      isMoved: !1,
      allowTouchCallbacks: !0,
      isScrolling: void 0,
      startMoving: void 0
  }), a.startX = f, a.startY = p, s.touchStartTime = qr(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, r.threshold > 0 && (s.allowThresholdMove = !1);
  let g = !0;
  o.matches(s.focusableElements) && (g = !1, o.nodeName === "SELECT" && (s.isTouched = !1)), t.activeElement && t.activeElement.matches(s.focusableElements) && t.activeElement !== o && t.activeElement.blur();
  const w = g && e.allowTouchMove && r.touchStartPreventDefault;
  (r.touchStartForcePreventDefault || w) && !o.isContentEditable && n.preventDefault(), r.freeMode && r.freeMode.enabled && e.freeMode && e.animating && !r.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", n)
}

function p_(i) {
  const e = Ci(),
      t = this,
      n = t.touchEventsData,
      {
          params: s,
          touches: r,
          rtlTranslate: a,
          enabled: l
      } = t;
  if (!l || !s.simulateTouch && i.pointerType === "mouse") return;
  let o = i;
  if (o.originalEvent && (o = o.originalEvent), o.type === "pointermove" && (n.touchId !== null || o.pointerId !== n.pointerId)) return;
  let u;
  if (o.type === "touchmove") {
      if (u = [...o.changedTouches].filter(B => B.identifier === n.touchId)[0], !u || u.identifier !== n.touchId) return
  } else u = o;
  if (!n.isTouched) {
      n.startMoving && n.isScrolling && t.emit("touchMoveOpposite", o);
      return
  }
  const c = u.pageX,
      h = u.pageY;
  if (o.preventedByNestedSwiper) {
      r.startX = c, r.startY = h;
      return
  }
  if (!t.allowTouchMove) {
      o.target.matches(n.focusableElements) || (t.allowClick = !1), n.isTouched && (Object.assign(r, {
          startX: c,
          startY: h,
          currentX: c,
          currentY: h
      }), n.touchStartTime = qr());
      return
  }
  if (s.touchReleaseOnEdges && !s.loop) {
      if (t.isVertical()) {
          if (h < r.startY && t.translate <= t.maxTranslate() || h > r.startY && t.translate >= t.minTranslate()) {
              n.isTouched = !1, n.isMoved = !1;
              return
          }
      } else if (c < r.startX && t.translate <= t.maxTranslate() || c > r.startX && t.translate >= t.minTranslate()) return
  }
  if (e.activeElement && o.target === e.activeElement && o.target.matches(n.focusableElements)) {
      n.isMoved = !0, t.allowClick = !1;
      return
  }
  n.allowTouchCallbacks && t.emit("touchMove", o), r.previousX = r.currentX, r.previousY = r.currentY, r.currentX = c, r.currentY = h;
  const d = r.currentX - r.startX,
      f = r.currentY - r.startY;
  if (t.params.threshold && Math.sqrt(d ** 2 + f ** 2) < t.params.threshold) return;
  if (typeof n.isScrolling > "u") {
      let B;
      t.isHorizontal() && r.currentY === r.startY || t.isVertical() && r.currentX === r.startX ? n.isScrolling = !1 : d * d + f * f >= 25 && (B = Math.atan2(Math.abs(f), Math.abs(d)) * 180 / Math.PI, n.isScrolling = t.isHorizontal() ? B > s.touchAngle : 90 - B > s.touchAngle)
  }
  if (n.isScrolling && t.emit("touchMoveOpposite", o), typeof n.startMoving > "u" && (r.currentX !== r.startX || r.currentY !== r.startY) && (n.startMoving = !0), n.isScrolling || o.type === "touchmove" && n.preventTouchMoveFromPointerMove) {
      n.isTouched = !1;
      return
  }
  if (!n.startMoving) return;
  t.allowClick = !1, !s.cssMode && o.cancelable && o.preventDefault(), s.touchMoveStopPropagation && !s.nested && o.stopPropagation();
  let p = t.isHorizontal() ? d : f,
      g = t.isHorizontal() ? r.currentX - r.previousX : r.currentY - r.previousY;
  s.oneWayMovement && (p = Math.abs(p) * (a ? 1 : -1), g = Math.abs(g) * (a ? 1 : -1)), r.diff = p, p *= s.touchRatio, a && (p = -p, g = -g);
  const w = t.touchesDirection;
  t.swipeDirection = p > 0 ? "prev" : "next", t.touchesDirection = g > 0 ? "prev" : "next";
  const y = t.params.loop && !s.cssMode,
      b = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev;
  if (!n.isMoved) {
      if (y && b && t.loopFix({
              direction: t.swipeDirection
          }), n.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) {
          const B = new window.CustomEvent("transitionend", {
              bubbles: !0,
              cancelable: !0,
              detail: {
                  bySwiperTouchMove: !0
              }
          });
          t.wrapperEl.dispatchEvent(B)
      }
      n.allowMomentumBounce = !1, s.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", o)
  }
  let x;
  if (new Date().getTime(), n.isMoved && n.allowThresholdMove && w !== t.touchesDirection && y && b && Math.abs(p) >= 1) {
      Object.assign(r, {
          startX: c,
          startY: h,
          currentX: c,
          currentY: h,
          startTranslate: n.currentTranslate
      }), n.loopSwapReset = !0, n.startTranslate = n.currentTranslate;
      return
  }
  t.emit("sliderMove", o), n.isMoved = !0, n.currentTranslate = p + n.startTranslate;
  let k = !0,
      S = s.resistanceRatio;
  if (s.touchReleaseOnEdges && (S = 0), p > 0 ? (y && b && !x && n.allowThresholdMove && n.currentTranslate > (s.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] - (s.slidesPerView !== "auto" && t.slides.length - s.slidesPerView >= 2 ? t.slidesSizesGrid[t.activeIndex + 1] + t.params.spaceBetween : 0) - t.params.spaceBetween : t.minTranslate()) && t.loopFix({
          direction: "prev",
          setTranslate: !0,
          activeSlideIndex: 0
      }), n.currentTranslate > t.minTranslate() && (k = !1, s.resistance && (n.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + n.startTranslate + p) ** S))) : p < 0 && (y && b && !x && n.allowThresholdMove && n.currentTranslate < (s.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] + t.params.spaceBetween + (s.slidesPerView !== "auto" && t.slides.length - s.slidesPerView >= 2 ? t.slidesSizesGrid[t.slidesSizesGrid.length - 1] + t.params.spaceBetween : 0) : t.maxTranslate()) && t.loopFix({
          direction: "next",
          setTranslate: !0,
          activeSlideIndex: t.slides.length - (s.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(s.slidesPerView, 10)))
      }), n.currentTranslate < t.maxTranslate() && (k = !1, s.resistance && (n.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - n.startTranslate - p) ** S))), k && (o.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && n.currentTranslate < n.startTranslate && (n.currentTranslate = n.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && n.currentTranslate > n.startTranslate && (n.currentTranslate = n.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (n.currentTranslate = n.startTranslate), s.threshold > 0)
      if (Math.abs(p) > s.threshold || n.allowThresholdMove) {
          if (!n.allowThresholdMove) {
              n.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, n.currentTranslate = n.startTranslate, r.diff = t.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY;
              return
          }
      } else {
          n.currentTranslate = n.startTranslate;
          return
      }! s.followFinger || s.cssMode || ((s.freeMode && s.freeMode.enabled && t.freeMode || s.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), s.freeMode && s.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(n.currentTranslate), t.setTranslate(n.currentTranslate))
}

function m_(i) {
  const e = this,
      t = e.touchEventsData;
  let n = i;
  n.originalEvent && (n = n.originalEvent);
  let s;
  if (n.type === "touchend" || n.type === "touchcancel") {
      if (s = [...n.changedTouches].filter(S => S.identifier === t.touchId)[0], !s || s.identifier !== t.touchId) return
  } else {
      if (t.touchId !== null || n.pointerId !== t.pointerId) return;
      s = n
  }
  if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(n.type) && !(["pointercancel", "contextmenu"].includes(n.type) && (e.browser.isSafari || e.browser.isWebView))) return;
  t.pointerId = null, t.touchId = null;
  const {
      params: a,
      touches: l,
      rtlTranslate: o,
      slidesGrid: u,
      enabled: c
  } = e;
  if (!c || !a.simulateTouch && n.pointerType === "mouse") return;
  if (t.allowTouchCallbacks && e.emit("touchEnd", n), t.allowTouchCallbacks = !1, !t.isTouched) {
      t.isMoved && a.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1;
      return
  }
  a.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1);
  const h = qr(),
      d = h - t.touchStartTime;
  if (e.allowClick) {
      const S = n.path || n.composedPath && n.composedPath();
      e.updateClickedSlide(S && S[0] || n.target, S), e.emit("tap click", n), d < 300 && h - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", n)
  }
  if (t.lastClickTime = qr(), mo(() => {
          e.destroyed || (e.allowClick = !0)
      }), !t.isTouched || !t.isMoved || !e.swipeDirection || l.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) {
      t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
      return
  }
  t.isTouched = !1, t.isMoved = !1, t.startMoving = !1;
  let f;
  if (a.followFinger ? f = o ? e.translate : -e.translate : f = -t.currentTranslate, a.cssMode) return;
  if (a.freeMode && a.freeMode.enabled) {
      e.freeMode.onTouchEnd({
          currentPos: f
      });
      return
  }
  const p = f >= -e.maxTranslate() && !e.params.loop;
  let g = 0,
      w = e.slidesSizesGrid[0];
  for (let S = 0; S < u.length; S += S < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
      const B = S < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
      typeof u[S + B] < "u" ? (p || f >= u[S] && f < u[S + B]) && (g = S, w = u[S + B] - u[S]) : (p || f >= u[S]) && (g = S, w = u[u.length - 1] - u[u.length - 2])
  }
  let y = null,
      b = null;
  a.rewind && (e.isBeginning ? b = a.virtual && a.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (y = 0));
  const x = (f - u[g]) / w,
      k = g < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
  if (d > a.longSwipesMs) {
      if (!a.longSwipes) {
          e.slideTo(e.activeIndex);
          return
      }
      e.swipeDirection === "next" && (x >= a.longSwipesRatio ? e.slideTo(a.rewind && e.isEnd ? y : g + k) : e.slideTo(g)), e.swipeDirection === "prev" && (x > 1 - a.longSwipesRatio ? e.slideTo(g + k) : b !== null && x < 0 && Math.abs(x) > a.longSwipesRatio ? e.slideTo(b) : e.slideTo(g))
  } else {
      if (!a.shortSwipes) {
          e.slideTo(e.activeIndex);
          return
      }
      e.navigation && (n.target === e.navigation.nextEl || n.target === e.navigation.prevEl) ? n.target === e.navigation.nextEl ? e.slideTo(g + k) : e.slideTo(g) : (e.swipeDirection === "next" && e.slideTo(y !== null ? y : g + k), e.swipeDirection === "prev" && e.slideTo(b !== null ? b : g))
  }
}

function ah() {
  const i = this,
      {
          params: e,
          el: t
      } = i;
  if (t && t.offsetWidth === 0) return;
  e.breakpoints && i.setBreakpoint();
  const {
      allowSlideNext: n,
      allowSlidePrev: s,
      snapGrid: r
  } = i, a = i.virtual && i.params.virtual.enabled;
  i.allowSlideNext = !0, i.allowSlidePrev = !0, i.updateSize(), i.updateSlides(), i.updateSlidesClasses();
  const l = a && e.loop;
  (e.slidesPerView === "auto" || e.slidesPerView > 1) && i.isEnd && !i.isBeginning && !i.params.centeredSlides && !l ? i.slideTo(i.slides.length - 1, 0, !1, !0) : i.params.loop && !a ? i.slideToLoop(i.realIndex, 0, !1, !0) : i.slideTo(i.activeIndex, 0, !1, !0), i.autoplay && i.autoplay.running && i.autoplay.paused && (clearTimeout(i.autoplay.resizeTimeout), i.autoplay.resizeTimeout = setTimeout(() => {
      i.autoplay && i.autoplay.running && i.autoplay.paused && i.autoplay.resume()
  }, 500)), i.allowSlidePrev = s, i.allowSlideNext = n, i.params.watchOverflow && r !== i.snapGrid && i.checkOverflow()
}

function g_(i) {
  const e = this;
  !e.enabled || e.allowClick || (e.params.preventClicks && i.preventDefault(), e.params.preventClicksPropagation && e.animating && (i.stopPropagation(), i.stopImmediatePropagation()))
}

function y_() {
  const i = this,
      {
          wrapperEl: e,
          rtlTranslate: t,
          enabled: n
      } = i;
  if (!n) return;
  i.previousTranslate = i.translate, i.isHorizontal() ? i.translate = -e.scrollLeft : i.translate = -e.scrollTop, i.translate === 0 && (i.translate = 0), i.updateActiveIndex(), i.updateSlidesClasses();
  let s;
  const r = i.maxTranslate() - i.minTranslate();
  r === 0 ? s = 0 : s = (i.translate - i.minTranslate()) / r, s !== i.progress && i.updateProgress(t ? -i.translate : i.translate), i.emit("setTranslate", i.translate, !1)
}

function v_(i) {
  const e = this;
  Cr(e, i.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update()
}

function b_() {
  const i = this;
  i.documentTouchHandlerProceeded || (i.documentTouchHandlerProceeded = !0, i.params.touchReleaseOnEdges && (i.el.style.touchAction = "auto"))
}
const xp = (i, e) => {
  const t = Ci(),
      {
          params: n,
          el: s,
          wrapperEl: r,
          device: a
      } = i,
      l = !!n.nested,
      o = e === "on" ? "addEventListener" : "removeEventListener",
      u = e;
  !s || typeof s == "string" || (t[o]("touchstart", i.onDocumentTouchStart, {
      passive: !1,
      capture: l
  }), s[o]("touchstart", i.onTouchStart, {
      passive: !1
  }), s[o]("pointerdown", i.onTouchStart, {
      passive: !1
  }), t[o]("touchmove", i.onTouchMove, {
      passive: !1,
      capture: l
  }), t[o]("pointermove", i.onTouchMove, {
      passive: !1,
      capture: l
  }), t[o]("touchend", i.onTouchEnd, {
      passive: !0
  }), t[o]("pointerup", i.onTouchEnd, {
      passive: !0
  }), t[o]("pointercancel", i.onTouchEnd, {
      passive: !0
  }), t[o]("touchcancel", i.onTouchEnd, {
      passive: !0
  }), t[o]("pointerout", i.onTouchEnd, {
      passive: !0
  }), t[o]("pointerleave", i.onTouchEnd, {
      passive: !0
  }), t[o]("contextmenu", i.onTouchEnd, {
      passive: !0
  }), (n.preventClicks || n.preventClicksPropagation) && s[o]("click", i.onClick, !0), n.cssMode && r[o]("scroll", i.onScroll), n.updateOnWindowResize ? i[u](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", ah, !0) : i[u]("observerUpdate", ah, !0), s[o]("load", i.onLoad, {
      capture: !0
  }))
};

function w_() {
  const i = this,
      {
          params: e
      } = i;
  i.onTouchStart = f_.bind(i), i.onTouchMove = p_.bind(i), i.onTouchEnd = m_.bind(i), i.onDocumentTouchStart = b_.bind(i), e.cssMode && (i.onScroll = y_.bind(i)), i.onClick = g_.bind(i), i.onLoad = v_.bind(i), xp(i, "on")
}

function k_() {
  xp(this, "off")
}
var __ = {
  attachEvents: w_,
  detachEvents: k_
};
const lh = (i, e) => i.grid && e.grid && e.grid.rows > 1;

function x_() {
  const i = this,
      {
          realIndex: e,
          initialized: t,
          params: n,
          el: s
      } = i,
      r = n.breakpoints;
  if (!r || r && Object.keys(r).length === 0) return;
  const a = i.getBreakpoint(r, i.params.breakpointsBase, i.el);
  if (!a || i.currentBreakpoint === a) return;
  const o = (a in r ? r[a] : void 0) || i.originalParams,
      u = lh(i, n),
      c = lh(i, o),
      h = i.params.grabCursor,
      d = o.grabCursor,
      f = n.enabled;
  u && !c ? (s.classList.remove(`${n.containerModifierClass}grid`, `${n.containerModifierClass}grid-column`), i.emitContainerClasses()) : !u && c && (s.classList.add(`${n.containerModifierClass}grid`), (o.grid.fill && o.grid.fill === "column" || !o.grid.fill && n.grid.fill === "column") && s.classList.add(`${n.containerModifierClass}grid-column`), i.emitContainerClasses()), h && !d ? i.unsetGrabCursor() : !h && d && i.setGrabCursor(), ["navigation", "pagination", "scrollbar"].forEach(x => {
      if (typeof o[x] > "u") return;
      const k = n[x] && n[x].enabled,
          S = o[x] && o[x].enabled;
      k && !S && i[x].disable(), !k && S && i[x].enable()
  });
  const p = o.direction && o.direction !== n.direction,
      g = n.loop && (o.slidesPerView !== n.slidesPerView || p),
      w = n.loop;
  p && t && i.changeDirection(), Pt(i.params, o);
  const y = i.params.enabled,
      b = i.params.loop;
  Object.assign(i, {
      allowTouchMove: i.params.allowTouchMove,
      allowSlideNext: i.params.allowSlideNext,
      allowSlidePrev: i.params.allowSlidePrev
  }), f && !y ? i.disable() : !f && y && i.enable(), i.currentBreakpoint = a, i.emit("_beforeBreakpoint", o), t && (g ? (i.loopDestroy(), i.loopCreate(e), i.updateSlides()) : !w && b ? (i.loopCreate(e), i.updateSlides()) : w && !b && i.loopDestroy()), i.emit("breakpoint", o)
}

function T_(i, e, t) {
  if (e === void 0 && (e = "window"), !i || e === "container" && !t) return;
  let n = !1;
  const s = Rt(),
      r = e === "window" ? s.innerHeight : t.clientHeight,
      a = Object.keys(i).map(l => {
          if (typeof l == "string" && l.indexOf("@") === 0) {
              const o = parseFloat(l.substr(1));
              return {
                  value: r * o,
                  point: l
              }
          }
          return {
              value: l,
              point: l
          }
      });
  a.sort((l, o) => parseInt(l.value, 10) - parseInt(o.value, 10));
  for (let l = 0; l < a.length; l += 1) {
      const {
          point: o,
          value: u
      } = a[l];
      e === "window" ? s.matchMedia(`(min-width: ${u}px)`).matches && (n = o) : u <= t.clientWidth && (n = o)
  }
  return n || "max"
}
var S_ = {
  setBreakpoint: x_,
  getBreakpoint: T_
};

function E_(i, e) {
  const t = [];
  return i.forEach(n => {
      typeof n == "object" ? Object.keys(n).forEach(s => {
          n[s] && t.push(e + s)
      }) : typeof n == "string" && t.push(e + n)
  }), t
}

function C_() {
  const i = this,
      {
          classNames: e,
          params: t,
          rtl: n,
          el: s,
          device: r
      } = i,
      a = E_(["initialized", t.direction, {
          "free-mode": i.params.freeMode && t.freeMode.enabled
      }, {
          autoheight: t.autoHeight
      }, {
          rtl: n
      }, {
          grid: t.grid && t.grid.rows > 1
      }, {
          "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column"
      }, {
          android: r.android
      }, {
          ios: r.ios
      }, {
          "css-mode": t.cssMode
      }, {
          centered: t.cssMode && t.centeredSlides
      }, {
          "watch-progress": t.watchSlidesProgress
      }], t.containerModifierClass);
  e.push(...a), s.classList.add(...e), i.emitContainerClasses()
}

function $_() {
  const i = this,
      {
          el: e,
          classNames: t
      } = i;
  !e || typeof e == "string" || (e.classList.remove(...t), i.emitContainerClasses())
}
var L_ = {
  addClasses: C_,
  removeClasses: $_
};

function P_() {
  const i = this,
      {
          isLocked: e,
          params: t
      } = i,
      {
          slidesOffsetBefore: n
      } = t;
  if (n) {
      const s = i.slides.length - 1,
          r = i.slidesGrid[s] + i.slidesSizesGrid[s] + n * 2;
      i.isLocked = i.size > r
  } else i.isLocked = i.snapGrid.length === 1;
  t.allowSlideNext === !0 && (i.allowSlideNext = !i.isLocked), t.allowSlidePrev === !0 && (i.allowSlidePrev = !i.isLocked), e && e !== i.isLocked && (i.isEnd = !1), e !== i.isLocked && i.emit(i.isLocked ? "lock" : "unlock")
}
var I_ = {
      checkOverflow: P_
  },
  vo = {
      init: !0,
      direction: "horizontal",
      oneWayMovement: !1,
      swiperElementNodeName: "SWIPER-CONTAINER",
      touchEventsTarget: "wrapper",
      initialSlide: 0,
      speed: 300,
      cssMode: !1,
      updateOnWindowResize: !0,
      resizeObserver: !0,
      nested: !1,
      createElements: !1,
      eventsPrefix: "swiper",
      enabled: !0,
      focusableElements: "input, select, option, textarea, button, video, label",
      width: null,
      height: null,
      preventInteractionOnTransition: !1,
      userAgent: null,
      url: null,
      edgeSwipeDetection: !1,
      edgeSwipeThreshold: 20,
      autoHeight: !1,
      setWrapperSize: !1,
      virtualTranslate: !1,
      effect: "slide",
      breakpoints: void 0,
      breakpointsBase: "window",
      spaceBetween: 0,
      slidesPerView: 1,
      slidesPerGroup: 1,
      slidesPerGroupSkip: 0,
      slidesPerGroupAuto: !1,
      centeredSlides: !1,
      centeredSlidesBounds: !1,
      slidesOffsetBefore: 0,
      slidesOffsetAfter: 0,
      normalizeSlideIndex: !0,
      centerInsufficientSlides: !1,
      watchOverflow: !0,
      roundLengths: !1,
      touchRatio: 1,
      touchAngle: 45,
      simulateTouch: !0,
      shortSwipes: !0,
      longSwipes: !0,
      longSwipesRatio: .5,
      longSwipesMs: 300,
      followFinger: !0,
      allowTouchMove: !0,
      threshold: 5,
      touchMoveStopPropagation: !1,
      touchStartPreventDefault: !0,
      touchStartForcePreventDefault: !1,
      touchReleaseOnEdges: !1,
      uniqueNavElements: !0,
      resistance: !0,
      resistanceRatio: .85,
      watchSlidesProgress: !1,
      grabCursor: !1,
      preventClicks: !0,
      preventClicksPropagation: !0,
      slideToClickedSlide: !1,
      loop: !1,
      loopAddBlankSlides: !0,
      loopAdditionalSlides: 0,
      loopPreventsSliding: !0,
      rewind: !1,
      allowSlidePrev: !0,
      allowSlideNext: !0,
      swipeHandler: null,
      noSwiping: !0,
      noSwipingClass: "swiper-no-swiping",
      noSwipingSelector: null,
      passiveListeners: !0,
      maxBackfaceHiddenSlides: 10,
      containerModifierClass: "swiper-",
      slideClass: "swiper-slide",
      slideBlankClass: "swiper-slide-blank",
      slideActiveClass: "swiper-slide-active",
      slideVisibleClass: "swiper-slide-visible",
      slideFullyVisibleClass: "swiper-slide-fully-visible",
      slideNextClass: "swiper-slide-next",
      slidePrevClass: "swiper-slide-prev",
      wrapperClass: "swiper-wrapper",
      lazyPreloaderClass: "swiper-lazy-preloader",
      lazyPreloadPrevNext: 0,
      runCallbacksOnInit: !0,
      _emitClasses: !1
  };

function N_(i, e) {
  return function(n) {
      n === void 0 && (n = {});
      const s = Object.keys(n)[0],
          r = n[s];
      if (typeof r != "object" || r === null) {
          Pt(e, n);
          return
      }
      if (i[s] === !0 && (i[s] = {
              enabled: !0
          }), s === "navigation" && i[s] && i[s].enabled && !i[s].prevEl && !i[s].nextEl && (i[s].auto = !0), ["pagination", "scrollbar"].indexOf(s) >= 0 && i[s] && i[s].enabled && !i[s].el && (i[s].auto = !0), !(s in i && "enabled" in r)) {
          Pt(e, n);
          return
      }
      typeof i[s] == "object" && !("enabled" in i[s]) && (i[s].enabled = !0), i[s] || (i[s] = {
          enabled: !1
      }), Pt(e, n)
  }
}
const kl = {
      eventsEmitter: Lk,
      update: Vk,
      translate: qk,
      transition: Jk,
      slide: s_,
      loop: o_,
      grabCursor: h_,
      events: __,
      breakpoints: S_,
      checkOverflow: I_,
      classes: L_
  },
  _l = {};
class At {
  constructor() {
      let e, t;
      for (var n = arguments.length, s = new Array(n), r = 0; r < n; r++) s[r] = arguments[r];
      s.length === 1 && s[0].constructor && Object.prototype.toString.call(s[0]).slice(8, -1) === "Object" ? t = s[0] : [e, t] = s, t || (t = {}), t = Pt({}, t), e && !t.el && (t.el = e);
      const a = Ci();
      if (t.el && typeof t.el == "string" && a.querySelectorAll(t.el).length > 1) {
          const c = [];
          return a.querySelectorAll(t.el).forEach(h => {
              const d = Pt({}, t, {
                  el: h
              });
              c.push(new At(d))
          }), c
      }
      const l = this;
      l.__swiper__ = !0, l.support = wp(), l.device = kp({
          userAgent: t.userAgent
      }), l.browser = Ek(), l.eventsListeners = {}, l.eventsAnyListeners = [], l.modules = [...l.__modules__], t.modules && Array.isArray(t.modules) && l.modules.push(...t.modules);
      const o = {};
      l.modules.forEach(c => {
          c({
              params: t,
              swiper: l,
              extendParams: N_(t, o),
              on: l.on.bind(l),
              once: l.once.bind(l),
              off: l.off.bind(l),
              emit: l.emit.bind(l)
          })
      });
      const u = Pt({}, vo, o);
      return l.params = Pt({}, u, _l, t), l.originalParams = Pt({}, l.params), l.passedParams = Pt({}, t), l.params && l.params.on && Object.keys(l.params.on).forEach(c => {
          l.on(c, l.params.on[c])
      }), l.params && l.params.onAny && l.onAny(l.params.onAny), Object.assign(l, {
          enabled: l.params.enabled,
          el: e,
          classNames: [],
          slides: [],
          slidesGrid: [],
          snapGrid: [],
          slidesSizesGrid: [],
          isHorizontal() {
              return l.params.direction === "horizontal"
          },
          isVertical() {
              return l.params.direction === "vertical"
          },
          activeIndex: 0,
          realIndex: 0,
          isBeginning: !0,
          isEnd: !1,
          translate: 0,
          previousTranslate: 0,
          progress: 0,
          velocity: 0,
          animating: !1,
          cssOverflowAdjustment() {
              return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
          },
          allowSlideNext: l.params.allowSlideNext,
          allowSlidePrev: l.params.allowSlidePrev,
          touchEventsData: {
              isTouched: void 0,
              isMoved: void 0,
              allowTouchCallbacks: void 0,
              touchStartTime: void 0,
              isScrolling: void 0,
              currentTranslate: void 0,
              startTranslate: void 0,
              allowThresholdMove: void 0,
              focusableElements: l.params.focusableElements,
              lastClickTime: 0,
              clickTimeout: void 0,
              velocities: [],
              allowMomentumBounce: void 0,
              startMoving: void 0,
              pointerId: null,
              touchId: null
          },
          allowClick: !0,
          allowTouchMove: l.params.allowTouchMove,
          touches: {
              startX: 0,
              startY: 0,
              currentX: 0,
              currentY: 0,
              diff: 0
          },
          imagesToLoad: [],
          imagesLoaded: 0
      }), l.emit("_swiper"), l.params.init && l.init(), l
  }
  getDirectionLabel(e) {
      return this.isHorizontal() ? e : {
          width: "height",
          "margin-top": "margin-left",
          "margin-bottom ": "margin-right",
          "margin-left": "margin-top",
          "margin-right": "margin-bottom",
          "padding-left": "padding-top",
          "padding-right": "padding-bottom",
          marginRight: "marginBottom"
      } [e]
  }
  getSlideIndex(e) {
      const {
          slidesEl: t,
          params: n
      } = this, s = di(t, `.${n.slideClass}, swiper-slide`), r = Xr(s[0]);
      return Xr(e) - r
  }
  getSlideIndexByData(e) {
      return this.getSlideIndex(this.slides.filter(t => t.getAttribute("data-swiper-slide-index") * 1 === e)[0])
  }
  recalcSlides() {
      const e = this,
          {
              slidesEl: t,
              params: n
          } = e;
      e.slides = di(t, `.${n.slideClass}, swiper-slide`)
  }
  enable() {
      const e = this;
      e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable"))
  }
  disable() {
      const e = this;
      !e.enabled || (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable"))
  }
  setProgress(e, t) {
      const n = this;
      e = Math.min(Math.max(e, 0), 1);
      const s = n.minTranslate(),
          a = (n.maxTranslate() - s) * e + s;
      n.translateTo(a, typeof t > "u" ? 0 : t), n.updateActiveIndex(), n.updateSlidesClasses()
  }
  emitContainerClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el) return;
      const t = e.el.className.split(" ").filter(n => n.indexOf("swiper") === 0 || n.indexOf(e.params.containerModifierClass) === 0);
      e.emit("_containerClasses", t.join(" "))
  }
  getSlideClasses(e) {
      const t = this;
      return t.destroyed ? "" : e.className.split(" ").filter(n => n.indexOf("swiper-slide") === 0 || n.indexOf(t.params.slideClass) === 0).join(" ")
  }
  emitSlidesClasses() {
      const e = this;
      if (!e.params._emitClasses || !e.el) return;
      const t = [];
      e.slides.forEach(n => {
          const s = e.getSlideClasses(n);
          t.push({
              slideEl: n,
              classNames: s
          }), e.emit("_slideClass", n, s)
      }), e.emit("_slideClasses", t)
  }
  slidesPerViewDynamic(e, t) {
      e === void 0 && (e = "current"), t === void 0 && (t = !1);
      const n = this,
          {
              params: s,
              slides: r,
              slidesGrid: a,
              slidesSizesGrid: l,
              size: o,
              activeIndex: u
          } = n;
      let c = 1;
      if (typeof s.slidesPerView == "number") return s.slidesPerView;
      if (s.centeredSlides) {
          let h = r[u] ? Math.ceil(r[u].swiperSlideSize) : 0,
              d;
          for (let f = u + 1; f < r.length; f += 1) r[f] && !d && (h += Math.ceil(r[f].swiperSlideSize), c += 1, h > o && (d = !0));
          for (let f = u - 1; f >= 0; f -= 1) r[f] && !d && (h += r[f].swiperSlideSize, c += 1, h > o && (d = !0))
      } else if (e === "current")
          for (let h = u + 1; h < r.length; h += 1)(t ? a[h] + l[h] - a[u] < o : a[h] - a[u] < o) && (c += 1);
      else
          for (let h = u - 1; h >= 0; h -= 1) a[u] - a[h] < o && (c += 1);
      return c
  }
  update() {
      const e = this;
      if (!e || e.destroyed) return;
      const {
          snapGrid: t,
          params: n
      } = e;
      n.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(a => {
          a.complete && Cr(e, a)
      }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses();

      function s() {
          const a = e.rtlTranslate ? e.translate * -1 : e.translate,
              l = Math.min(Math.max(a, e.maxTranslate()), e.minTranslate());
          e.setTranslate(l), e.updateActiveIndex(), e.updateSlidesClasses()
      }
      let r;
      if (n.freeMode && n.freeMode.enabled && !n.cssMode) s(), n.autoHeight && e.updateAutoHeight();
      else {
          if ((n.slidesPerView === "auto" || n.slidesPerView > 1) && e.isEnd && !n.centeredSlides) {
              const a = e.virtual && n.virtual.enabled ? e.virtual.slides : e.slides;
              r = e.slideTo(a.length - 1, 0, !1, !0)
          } else r = e.slideTo(e.activeIndex, 0, !1, !0);
          r || s()
      }
      n.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update")
  }
  changeDirection(e, t) {
      t === void 0 && (t = !0);
      const n = this,
          s = n.params.direction;
      return e || (e = s === "horizontal" ? "vertical" : "horizontal"), e === s || e !== "horizontal" && e !== "vertical" || (n.el.classList.remove(`${n.params.containerModifierClass}${s}`), n.el.classList.add(`${n.params.containerModifierClass}${e}`), n.emitContainerClasses(), n.params.direction = e, n.slides.forEach(r => {
          e === "vertical" ? r.style.width = "" : r.style.height = ""
      }), n.emit("changeDirection"), t && n.update()), n
  }
  changeLanguageDirection(e) {
      const t = this;
      t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update())
  }
  mount(e) {
      const t = this;
      if (t.mounted) return !0;
      let n = e || t.params.el;
      if (typeof n == "string" && (n = document.querySelector(n)), !n) return !1;
      n.swiper = t, n.parentNode && n.parentNode.host && n.parentNode.host.nodeName === t.params.swiperElementNodeName.toUpperCase() && (t.isElement = !0);
      const s = () => `.${(t.params.wrapperClass||"").trim().split(" ").join(".")}`;
      let a = (() => n && n.shadowRoot && n.shadowRoot.querySelector ? n.shadowRoot.querySelector(s()) : di(n, s())[0])();
      return !a && t.params.createElements && (a = Kr("div", t.params.wrapperClass), n.append(a), di(n, `.${t.params.slideClass}`).forEach(l => {
          a.append(l)
      })), Object.assign(t, {
          el: n,
          wrapperEl: a,
          slidesEl: t.isElement && !n.parentNode.host.slideSlots ? n.parentNode.host : a,
          hostEl: t.isElement ? n.parentNode.host : n,
          mounted: !0,
          rtl: n.dir.toLowerCase() === "rtl" || Vi(n, "direction") === "rtl",
          rtlTranslate: t.params.direction === "horizontal" && (n.dir.toLowerCase() === "rtl" || Vi(n, "direction") === "rtl"),
          wrongRTL: Vi(a, "display") === "-webkit-box"
      }), !0
  }
  init(e) {
      const t = this;
      if (t.initialized || t.mount(e) === !1) return t;
      t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents();
      const s = [...t.el.querySelectorAll('[loading="lazy"]')];
      return t.isElement && s.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), s.forEach(r => {
          r.complete ? Cr(t, r) : r.addEventListener("load", a => {
              Cr(t, a.target)
          })
      }), yo(t), t.initialized = !0, yo(t), t.emit("init"), t.emit("afterInit"), t
  }
  destroy(e, t) {
      e === void 0 && (e = !0), t === void 0 && (t = !0);
      const n = this,
          {
              params: s,
              el: r,
              wrapperEl: a,
              slides: l
          } = n;
      return typeof n.params > "u" || n.destroyed || (n.emit("beforeDestroy"), n.initialized = !1, n.detachEvents(), s.loop && n.loopDestroy(), t && (n.removeClasses(), r && typeof r != "string" && r.removeAttribute("style"), a && a.removeAttribute("style"), l && l.length && l.forEach(o => {
          o.classList.remove(s.slideVisibleClass, s.slideFullyVisibleClass, s.slideActiveClass, s.slideNextClass, s.slidePrevClass), o.removeAttribute("style"), o.removeAttribute("data-swiper-slide-index")
      })), n.emit("destroy"), Object.keys(n.eventsListeners).forEach(o => {
          n.off(o)
      }), e !== !1 && (n.el && typeof n.el != "string" && (n.el.swiper = null), gk(n)), n.destroyed = !0), null
  }
  static extendDefaults(e) {
      Pt(_l, e)
  }
  static get extendedDefaults() {
      return _l
  }
  static get defaults() {
      return vo
  }
  static installModule(e) {
      At.prototype.__modules__ || (At.prototype.__modules__ = []);
      const t = At.prototype.__modules__;
      typeof e == "function" && t.indexOf(e) < 0 && t.push(e)
  }
  static use(e) {
      return Array.isArray(e) ? (e.forEach(t => At.installModule(t)), At) : (At.installModule(e), At)
  }
}
Object.keys(kl).forEach(i => {
  Object.keys(kl[i]).forEach(e => {
      At.prototype[e] = kl[i][e]
  })
});
At.use([Ck, $k]);
const Tp = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"];

function cn(i) {
  return typeof i == "object" && i !== null && i.constructor && Object.prototype.toString.call(i).slice(8, -1) === "Object" && !i.__swiper__
}

function Fn(i, e) {
  const t = ["__proto__", "constructor", "prototype"];
  Object.keys(e).filter(n => t.indexOf(n) < 0).forEach(n => {
      typeof i[n] > "u" ? i[n] = e[n] : cn(e[n]) && cn(i[n]) && Object.keys(e[n]).length > 0 ? e[n].__swiper__ ? i[n] = e[n] : Fn(i[n], e[n]) : i[n] = e[n]
  })
}

function Sp(i) {
  return i === void 0 && (i = {}), i.navigation && typeof i.navigation.nextEl > "u" && typeof i.navigation.prevEl > "u"
}

function Ep(i) {
  return i === void 0 && (i = {}), i.pagination && typeof i.pagination.el > "u"
}

function Cp(i) {
  return i === void 0 && (i = {}), i.scrollbar && typeof i.scrollbar.el > "u"
}

function $p(i) {
  i === void 0 && (i = "");
  const e = i.split(" ").map(n => n.trim()).filter(n => !!n),
      t = [];
  return e.forEach(n => {
      t.indexOf(n) < 0 && t.push(n)
  }), t.join(" ")
}

function M_(i) {
  return i === void 0 && (i = ""), i ? i.includes("swiper-wrapper") ? i : `swiper-wrapper ${i}` : "swiper-wrapper"
}

function R_(i) {
  let {
      swiper: e,
      slides: t,
      passedParams: n,
      changedParams: s,
      nextEl: r,
      prevEl: a,
      scrollbarEl: l,
      paginationEl: o
  } = i;
  const u = s.filter(I => I !== "children" && I !== "direction" && I !== "wrapperClass"),
      {
          params: c,
          pagination: h,
          navigation: d,
          scrollbar: f,
          virtual: p,
          thumbs: g
      } = e;
  let w, y, b, x, k, S, B, D;
  s.includes("thumbs") && n.thumbs && n.thumbs.swiper && c.thumbs && !c.thumbs.swiper && (w = !0), s.includes("controller") && n.controller && n.controller.control && c.controller && !c.controller.control && (y = !0), s.includes("pagination") && n.pagination && (n.pagination.el || o) && (c.pagination || c.pagination === !1) && h && !h.el && (b = !0), s.includes("scrollbar") && n.scrollbar && (n.scrollbar.el || l) && (c.scrollbar || c.scrollbar === !1) && f && !f.el && (x = !0), s.includes("navigation") && n.navigation && (n.navigation.prevEl || a) && (n.navigation.nextEl || r) && (c.navigation || c.navigation === !1) && d && !d.prevEl && !d.nextEl && (k = !0);
  const P = I => {
      !e[I] || (e[I].destroy(), I === "navigation" ? (e.isElement && (e[I].prevEl.remove(), e[I].nextEl.remove()), c[I].prevEl = void 0, c[I].nextEl = void 0, e[I].prevEl = void 0, e[I].nextEl = void 0) : (e.isElement && e[I].el.remove(), c[I].el = void 0, e[I].el = void 0))
  };
  s.includes("loop") && e.isElement && (c.loop && !n.loop ? S = !0 : !c.loop && n.loop ? B = !0 : D = !0), u.forEach(I => {
      if (cn(c[I]) && cn(n[I])) Object.assign(c[I], n[I]), (I === "navigation" || I === "pagination" || I === "scrollbar") && "enabled" in n[I] && !n[I].enabled && P(I);
      else {
          const $ = n[I];
          ($ === !0 || $ === !1) && (I === "navigation" || I === "pagination" || I === "scrollbar") ? $ === !1 && P(I): c[I] = n[I]
      }
  }), u.includes("controller") && !y && e.controller && e.controller.control && c.controller && c.controller.control && (e.controller.control = c.controller.control), s.includes("children") && t && p && c.virtual.enabled ? (p.slides = t, p.update(!0)) : s.includes("virtual") && p && c.virtual.enabled && (t && (p.slides = t), p.update(!0)), s.includes("children") && t && c.loop && (D = !0), w && g.init() && g.update(!0), y && (e.controller.control = c.controller.control), b && (e.isElement && (!o || typeof o == "string") && (o = document.createElement("div"), o.classList.add("swiper-pagination"), o.part.add("pagination"), e.el.appendChild(o)), o && (c.pagination.el = o), h.init(), h.render(), h.update()), x && (e.isElement && (!l || typeof l == "string") && (l = document.createElement("div"), l.classList.add("swiper-scrollbar"), l.part.add("scrollbar"), e.el.appendChild(l)), l && (c.scrollbar.el = l), f.init(), f.updateSize(), f.setTranslate()), k && (e.isElement && ((!r || typeof r == "string") && (r = document.createElement("div"), r.classList.add("swiper-button-next"), r.innerHTML = e.hostEl.constructor.nextButtonSvg, r.part.add("button-next"), e.el.appendChild(r)), (!a || typeof a == "string") && (a = document.createElement("div"), a.classList.add("swiper-button-prev"), a.innerHTML = e.hostEl.constructor.prevButtonSvg, a.part.add("button-prev"), e.el.appendChild(a))), r && (c.navigation.nextEl = r), a && (c.navigation.prevEl = a), d.init(), d.update()), s.includes("allowSlideNext") && (e.allowSlideNext = n.allowSlideNext), s.includes("allowSlidePrev") && (e.allowSlidePrev = n.allowSlidePrev), s.includes("direction") && e.changeDirection(n.direction, !1), (S || D) && e.loopDestroy(), (B || D) && e.loopCreate(), e.update()
}

function oh(i, e) {
  i === void 0 && (i = {}), e === void 0 && (e = !0);
  const t = {
          on: {}
      },
      n = {},
      s = {};
  Fn(t, vo), t._emitClasses = !0, t.init = !1;
  const r = {},
      a = Tp.map(o => o.replace(/_/, "")),
      l = Object.assign({}, i);
  return Object.keys(l).forEach(o => {
      typeof i[o] > "u" || (a.indexOf(o) >= 0 ? cn(i[o]) ? (t[o] = {}, s[o] = {}, Fn(t[o], i[o]), Fn(s[o], i[o])) : (t[o] = i[o], s[o] = i[o]) : o.search(/on[A-Z]/) === 0 && typeof i[o] == "function" ? e ? n[`${o[2].toLowerCase()}${o.substr(3)}`] = i[o] : t.on[`${o[2].toLowerCase()}${o.substr(3)}`] = i[o] : r[o] = i[o])
  }), ["navigation", "pagination", "scrollbar"].forEach(o => {
      t[o] === !0 && (t[o] = {}), t[o] === !1 && delete t[o]
  }), {
      params: t,
      passedParams: s,
      rest: r,
      events: n
  }
}

function B_(i, e) {
  let {
      el: t,
      nextEl: n,
      prevEl: s,
      paginationEl: r,
      scrollbarEl: a,
      swiper: l
  } = i;
  Sp(e) && n && s && (l.params.navigation.nextEl = n, l.originalParams.navigation.nextEl = n, l.params.navigation.prevEl = s, l.originalParams.navigation.prevEl = s), Ep(e) && r && (l.params.pagination.el = r, l.originalParams.pagination.el = r), Cp(e) && a && (l.params.scrollbar.el = a, l.originalParams.scrollbar.el = a), l.init(t)
}

function O_(i, e, t, n, s) {
  const r = [];
  if (!e) return r;
  const a = o => {
      r.indexOf(o) < 0 && r.push(o)
  };
  if (t && n) {
      const o = n.map(s),
          u = t.map(s);
      o.join("") !== u.join("") && a("children"), n.length !== t.length && a("children")
  }
  return Tp.filter(o => o[0] === "_").map(o => o.replace(/_/, "")).forEach(o => {
      if (o in i && o in e)
          if (cn(i[o]) && cn(e[o])) {
              const u = Object.keys(i[o]),
                  c = Object.keys(e[o]);
              u.length !== c.length ? a(o) : (u.forEach(h => {
                  i[o][h] !== e[o][h] && a(o)
              }), c.forEach(h => {
                  i[o][h] !== e[o][h] && a(o)
              }))
          } else i[o] !== e[o] && a(o)
  }), r
}
const D_ = i => {
  !i || i.destroyed || !i.params.virtual || i.params.virtual && !i.params.virtual.enabled || (i.updateSlides(), i.updateProgress(), i.updateSlidesClasses(), i.parallax && i.params.parallax && i.params.parallax.enabled && i.parallax.setTranslate())
};

function xl(i, e, t) {
  i === void 0 && (i = {});
  const n = [],
      s = {
          "container-start": [],
          "container-end": [],
          "wrapper-start": [],
          "wrapper-end": []
      },
      r = (a, l) => {
          !Array.isArray(a) || a.forEach(o => {
              const u = typeof o.type == "symbol";
              l === "default" && (l = "container-end"), u && o.children ? r(o.children, l) : o.type && (o.type.name === "SwiperSlide" || o.type.name === "AsyncComponentWrapper") || o.componentOptions && o.componentOptions.tag === "SwiperSlide" ? n.push(o) : s[l] && s[l].push(o)
          })
      };
  return Object.keys(i).forEach(a => {
      if (typeof i[a] != "function") return;
      const l = i[a]();
      r(l, a)
  }), t.value = e.value, e.value = n, {
      slides: n,
      slots: s
  }
}

function F_(i, e, t) {
  if (!t) return null;
  const n = c => {
          let h = c;
          return c < 0 ? h = e.length + c : h >= e.length && (h = h - e.length), h
      },
      s = i.value.isHorizontal() ? {
          [i.value.rtlTranslate ? "right" : "left"]: `${t.offset}px`
      } : {
          top: `${t.offset}px`
      },
      {
          from: r,
          to: a
      } = t,
      l = i.value.params.loop ? -e.length : 0,
      o = i.value.params.loop ? e.length * 2 : e.length,
      u = [];
  for (let c = l; c < o; c += 1) c >= r && c <= a && u.length < e.length && u.push(e[n(c)]);
  return u.map(c => {
      if (c.props || (c.props = {}), c.props.style || (c.props.style = {}), c.props.swiperRef = i, c.props.style = s, c.type) return wt(c.type, {
          ...c.props
      }, c.children);
      if (c.componentOptions) return wt(c.componentOptions.Ctor, {
          ...c.props
      }, c.componentOptions.children)
  })
}
const qs = {
      name: "Swiper",
      props: {
          tag: {
              type: String,
              default: "div"
          },
          wrapperTag: {
              type: String,
              default: "div"
          },
          modules: {
              type: Array,
              default: void 0
          },
          init: {
              type: Boolean,
              default: void 0
          },
          direction: {
              type: String,
              default: void 0
          },
          oneWayMovement: {
              type: Boolean,
              default: void 0
          },
          swiperElementNodeName: {
              type: String,
              default: "SWIPER-CONTAINER"
          },
          touchEventsTarget: {
              type: String,
              default: void 0
          },
          initialSlide: {
              type: Number,
              default: void 0
          },
          speed: {
              type: Number,
              default: void 0
          },
          cssMode: {
              type: Boolean,
              default: void 0
          },
          updateOnWindowResize: {
              type: Boolean,
              default: void 0
          },
          resizeObserver: {
              type: Boolean,
              default: void 0
          },
          nested: {
              type: Boolean,
              default: void 0
          },
          focusableElements: {
              type: String,
              default: void 0
          },
          width: {
              type: Number,
              default: void 0
          },
          height: {
              type: Number,
              default: void 0
          },
          preventInteractionOnTransition: {
              type: Boolean,
              default: void 0
          },
          userAgent: {
              type: String,
              default: void 0
          },
          url: {
              type: String,
              default: void 0
          },
          edgeSwipeDetection: {
              type: [Boolean, String],
              default: void 0
          },
          edgeSwipeThreshold: {
              type: Number,
              default: void 0
          },
          autoHeight: {
              type: Boolean,
              default: void 0
          },
          setWrapperSize: {
              type: Boolean,
              default: void 0
          },
          virtualTranslate: {
              type: Boolean,
              default: void 0
          },
          effect: {
              type: String,
              default: void 0
          },
          breakpoints: {
              type: Object,
              default: void 0
          },
          breakpointsBase: {
              type: String,
              default: void 0
          },
          spaceBetween: {
              type: [Number, String],
              default: void 0
          },
          slidesPerView: {
              type: [Number, String],
              default: void 0
          },
          maxBackfaceHiddenSlides: {
              type: Number,
              default: void 0
          },
          slidesPerGroup: {
              type: Number,
              default: void 0
          },
          slidesPerGroupSkip: {
              type: Number,
              default: void 0
          },
          slidesPerGroupAuto: {
              type: Boolean,
              default: void 0
          },
          centeredSlides: {
              type: Boolean,
              default: void 0
          },
          centeredSlidesBounds: {
              type: Boolean,
              default: void 0
          },
          slidesOffsetBefore: {
              type: Number,
              default: void 0
          },
          slidesOffsetAfter: {
              type: Number,
              default: void 0
          },
          normalizeSlideIndex: {
              type: Boolean,
              default: void 0
          },
          centerInsufficientSlides: {
              type: Boolean,
              default: void 0
          },
          watchOverflow: {
              type: Boolean,
              default: void 0
          },
          roundLengths: {
              type: Boolean,
              default: void 0
          },
          touchRatio: {
              type: Number,
              default: void 0
          },
          touchAngle: {
              type: Number,
              default: void 0
          },
          simulateTouch: {
              type: Boolean,
              default: void 0
          },
          shortSwipes: {
              type: Boolean,
              default: void 0
          },
          longSwipes: {
              type: Boolean,
              default: void 0
          },
          longSwipesRatio: {
              type: Number,
              default: void 0
          },
          longSwipesMs: {
              type: Number,
              default: void 0
          },
          followFinger: {
              type: Boolean,
              default: void 0
          },
          allowTouchMove: {
              type: Boolean,
              default: void 0
          },
          threshold: {
              type: Number,
              default: void 0
          },
          touchMoveStopPropagation: {
              type: Boolean,
              default: void 0
          },
          touchStartPreventDefault: {
              type: Boolean,
              default: void 0
          },
          touchStartForcePreventDefault: {
              type: Boolean,
              default: void 0
          },
          touchReleaseOnEdges: {
              type: Boolean,
              default: void 0
          },
          uniqueNavElements: {
              type: Boolean,
              default: void 0
          },
          resistance: {
              type: Boolean,
              default: void 0
          },
          resistanceRatio: {
              type: Number,
              default: void 0
          },
          watchSlidesProgress: {
              type: Boolean,
              default: void 0
          },
          grabCursor: {
              type: Boolean,
              default: void 0
          },
          preventClicks: {
              type: Boolean,
              default: void 0
          },
          preventClicksPropagation: {
              type: Boolean,
              default: void 0
          },
          slideToClickedSlide: {
              type: Boolean,
              default: void 0
          },
          loop: {
              type: Boolean,
              default: void 0
          },
          loopedSlides: {
              type: Number,
              default: void 0
          },
          loopPreventsSliding: {
              type: Boolean,
              default: void 0
          },
          rewind: {
              type: Boolean,
              default: void 0
          },
          allowSlidePrev: {
              type: Boolean,
              default: void 0
          },
          allowSlideNext: {
              type: Boolean,
              default: void 0
          },
          swipeHandler: {
              type: Boolean,
              default: void 0
          },
          noSwiping: {
              type: Boolean,
              default: void 0
          },
          noSwipingClass: {
              type: String,
              default: void 0
          },
          noSwipingSelector: {
              type: String,
              default: void 0
          },
          passiveListeners: {
              type: Boolean,
              default: void 0
          },
          containerModifierClass: {
              type: String,
              default: void 0
          },
          slideClass: {
              type: String,
              default: void 0
          },
          slideActiveClass: {
              type: String,
              default: void 0
          },
          slideVisibleClass: {
              type: String,
              default: void 0
          },
          slideFullyVisibleClass: {
              type: String,
              default: void 0
          },
          slideBlankClass: {
              type: String,
              default: void 0
          },
          slideNextClass: {
              type: String,
              default: void 0
          },
          slidePrevClass: {
              type: String,
              default: void 0
          },
          wrapperClass: {
              type: String,
              default: void 0
          },
          lazyPreloaderClass: {
              type: String,
              default: void 0
          },
          lazyPreloadPrevNext: {
              type: Number,
              default: void 0
          },
          runCallbacksOnInit: {
              type: Boolean,
              default: void 0
          },
          observer: {
              type: Boolean,
              default: void 0
          },
          observeParents: {
              type: Boolean,
              default: void 0
          },
          observeSlideChildren: {
              type: Boolean,
              default: void 0
          },
          a11y: {
              type: [Boolean, Object],
              default: void 0
          },
          autoplay: {
              type: [Boolean, Object],
              default: void 0
          },
          controller: {
              type: Object,
              default: void 0
          },
          coverflowEffect: {
              type: Object,
              default: void 0
          },
          cubeEffect: {
              type: Object,
              default: void 0
          },
          fadeEffect: {
              type: Object,
              default: void 0
          },
          flipEffect: {
              type: Object,
              default: void 0
          },
          creativeEffect: {
              type: Object,
              default: void 0
          },
          cardsEffect: {
              type: Object,
              default: void 0
          },
          hashNavigation: {
              type: [Boolean, Object],
              default: void 0
          },
          history: {
              type: [Boolean, Object],
              default: void 0
          },
          keyboard: {
              type: [Boolean, Object],
              default: void 0
          },
          mousewheel: {
              type: [Boolean, Object],
              default: void 0
          },
          navigation: {
              type: [Boolean, Object],
              default: void 0
          },
          pagination: {
              type: [Boolean, Object],
              default: void 0
          },
          parallax: {
              type: [Boolean, Object],
              default: void 0
          },
          scrollbar: {
              type: [Boolean, Object],
              default: void 0
          },
          thumbs: {
              type: Object,
              default: void 0
          },
          virtual: {
              type: [Boolean, Object],
              default: void 0
          },
          zoom: {
              type: [Boolean, Object],
              default: void 0
          },
          grid: {
              type: [Object],
              default: void 0
          },
          freeMode: {
              type: [Boolean, Object],
              default: void 0
          },
          enabled: {
              type: Boolean,
              default: void 0
          }
      },
      emits: ["_beforeBreakpoint", "_containerClasses", "_slideClass", "_slideClasses", "_swiper", "_freeModeNoMomentumRelease", "activeIndexChange", "afterInit", "autoplay", "autoplayStart", "autoplayStop", "autoplayPause", "autoplayResume", "autoplayTimeLeft", "beforeDestroy", "beforeInit", "beforeLoopFix", "beforeResize", "beforeSlideChangeStart", "beforeTransitionStart", "breakpoint", "changeDirection", "click", "disable", "doubleTap", "doubleClick", "destroy", "enable", "fromEdge", "hashChange", "hashSet", "init", "keyPress", "lock", "loopFix", "momentumBounce", "navigationHide", "navigationShow", "navigationPrev", "navigationNext", "observerUpdate", "orientationchange", "paginationHide", "paginationRender", "paginationShow", "paginationUpdate", "progress", "reachBeginning", "reachEnd", "realIndexChange", "resize", "scroll", "scrollbarDragEnd", "scrollbarDragMove", "scrollbarDragStart", "setTransition", "setTranslate", "slidesUpdated", "slideChange", "slideChangeTransitionEnd", "slideChangeTransitionStart", "slideNextTransitionEnd", "slideNextTransitionStart", "slidePrevTransitionEnd", "slidePrevTransitionStart", "slideResetTransitionStart", "slideResetTransitionEnd", "sliderMove", "sliderFirstMove", "slidesLengthChange", "slidesGridLengthChange", "snapGridLengthChange", "snapIndexChange", "swiper", "tap", "toEdge", "touchEnd", "touchMove", "touchMoveOpposite", "touchStart", "transitionEnd", "transitionStart", "unlock", "update", "virtualUpdate", "zoomChange"],
      setup(i, e) {
          let {
              slots: t,
              emit: n
          } = e;
          const {
              tag: s,
              wrapperTag: r
          } = i, a = M("swiper"), l = M(null), o = M(!1), u = M(!1), c = M(null), h = M(null), d = M(null), f = {
              value: []
          }, p = {
              value: []
          }, g = M(null), w = M(null), y = M(null), b = M(null), {
              params: x,
              passedParams: k
          } = oh(i, !1);
          xl(t, f, p), d.value = k, p.value = f.value;
          const S = () => {
              xl(t, f, p), o.value = !0
          };
          x.onAny = function(P) {
              for (var I = arguments.length, $ = new Array(I > 1 ? I - 1 : 0), V = 1; V < I; V++) $[V - 1] = arguments[V];
              n(P, ...$)
          }, Object.assign(x.on, {
              _beforeBreakpoint: S,
              _containerClasses(P, I) {
                  a.value = I
              }
          });
          const B = {
              ...x
          };
          if (delete B.wrapperClass, h.value = new At(B), h.value.virtual && h.value.params.virtual.enabled) {
              h.value.virtual.slides = f.value;
              const P = {
                  cache: !1,
                  slides: f.value,
                  renderExternal: I => {
                      l.value = I
                  },
                  renderExternalUpdate: !1
              };
              Fn(h.value.params.virtual, P), Fn(h.value.originalParams.virtual, P)
          }
          ha(() => {
              !u.value && h.value && (h.value.emitSlidesClasses(), u.value = !0);
              const {
                  passedParams: P
              } = oh(i, !1), I = O_(P, d.value, f.value, p.value, $ => $.props && $.props.key);
              d.value = P, (I.length || o.value) && h.value && !h.value.destroyed && R_({
                  swiper: h.value,
                  slides: f.value,
                  passedParams: P,
                  changedParams: I,
                  nextEl: g.value,
                  prevEl: w.value,
                  scrollbarEl: b.value,
                  paginationEl: y.value
              }), o.value = !1
          }), Nn("swiper", h), Ie(l, () => {
              pi(() => {
                  D_(h.value)
              })
          }), Te(() => {
              !c.value || (B_({
                  el: c.value,
                  nextEl: g.value,
                  prevEl: w.value,
                  paginationEl: y.value,
                  scrollbarEl: b.value,
                  swiper: h.value
              }, x), n("swiper", h.value))
          }), da(() => {
              h.value && !h.value.destroyed && h.value.destroy(!0, !1)
          });

          function D(P) {
              return x.virtual ? F_(h, P, l.value) : (P.forEach((I, $) => {
                  I.props || (I.props = {}), I.props.swiperRef = h, I.props.swiperSlideIndex = $
              }), P)
          }
          return () => {
              const {
                  slides: P,
                  slots: I
              } = xl(t, f, p);
              return wt(s, {
                  ref: c,
                  class: $p(a.value)
              }, [I["container-start"], wt(r, {
                  class: M_(x.wrapperClass)
              }, [I["wrapper-start"], D(P), I["wrapper-end"]]), Sp(i) && [wt("div", {
                  ref: w,
                  class: "swiper-button-prev"
              }), wt("div", {
                  ref: g,
                  class: "swiper-button-next"
              })], Cp(i) && wt("div", {
                  ref: b,
                  class: "swiper-scrollbar"
              }), Ep(i) && wt("div", {
                  ref: y,
                  class: "swiper-pagination"
              }), I["container-end"]])
          }
      }
  },
  Gs = {
      name: "SwiperSlide",
      props: {
          tag: {
              type: String,
              default: "div"
          },
          swiperRef: {
              type: Object,
              required: !1
          },
          swiperSlideIndex: {
              type: Number,
              default: void 0,
              required: !1
          },
          zoom: {
              type: Boolean,
              default: void 0,
              required: !1
          },
          lazy: {
              type: Boolean,
              default: !1,
              required: !1
          },
          virtualIndex: {
              type: [String, Number],
              default: void 0
          }
      },
      setup(i, e) {
          let {
              slots: t
          } = e, n = !1;
          const {
              swiperRef: s
          } = i, r = M(null), a = M("swiper-slide"), l = M(!1);

          function o(h, d, f) {
              d === r.value && (a.value = f)
          }
          Te(() => {
              !s || !s.value || (s.value.on("_slideClass", o), n = !0)
          }), af(() => {
              n || !s || !s.value || (s.value.on("_slideClass", o), n = !0)
          }), ha(() => {
              !r.value || !s || !s.value || (typeof i.swiperSlideIndex < "u" && (r.value.swiperSlideIndex = i.swiperSlideIndex), s.value.destroyed && a.value !== "swiper-slide" && (a.value = "swiper-slide"))
          }), da(() => {
              !s || !s.value || s.value.off("_slideClass", o)
          });
          const u = q(() => ({
              isActive: a.value.indexOf("swiper-slide-active") >= 0,
              isVisible: a.value.indexOf("swiper-slide-visible") >= 0,
              isPrev: a.value.indexOf("swiper-slide-prev") >= 0,
              isNext: a.value.indexOf("swiper-slide-next") >= 0
          }));
          Nn("swiperSlide", u);
          const c = () => {
              l.value = !0
          };
          return () => wt(i.tag, {
              class: $p(`${a.value}`),
              ref: r,
              "data-swiper-slide-index": typeof i.virtualIndex > "u" && s && s.value && s.value.params.loop ? i.swiperSlideIndex : i.virtualIndex,
              onLoadCapture: c
          }, i.zoom ? wt("div", {
              class: "swiper-zoom-container",
              "data-swiper-zoom": typeof i.zoom == "number" ? i.zoom : void 0
          }, [t.default && t.default(u.value), i.lazy && !l.value && wt("div", {
              class: "swiper-lazy-preloader"
          })]) : [t.default && t.default(u.value), i.lazy && !l.value && wt("div", {
              class: "swiper-lazy-preloader"
          })])
      }
  };

function Lp(i, e, t, n) {
  return i.params.createElements && Object.keys(n).forEach(s => {
      if (!t[s] && t.auto === !0) {
          let r = di(i.el, `.${n[s]}`)[0];
          r || (r = Kr("div", n[s]), r.className = n[s], i.el.append(r)), t[s] = r, e[s] = r
      }
  }), t
}

function mu(i) {
  let {
      swiper: e,
      extendParams: t,
      on: n,
      emit: s
  } = i;
  t({
      navigation: {
          nextEl: null,
          prevEl: null,
          hideOnClick: !1,
          disabledClass: "swiper-button-disabled",
          hiddenClass: "swiper-button-hidden",
          lockClass: "swiper-button-lock",
          navigationDisabledClass: "swiper-navigation-disabled"
      }
  }), e.navigation = {
      nextEl: null,
      prevEl: null
  };

  function r(p) {
      let g;
      return p && typeof p == "string" && e.isElement && (g = e.el.querySelector(p), g) ? g : (p && (typeof p == "string" && (g = [...document.querySelectorAll(p)]), e.params.uniqueNavElements && typeof p == "string" && g && g.length > 1 && e.el.querySelectorAll(p).length === 1 ? g = e.el.querySelector(p) : g && g.length === 1 && (g = g[0])), p && !g ? p : g)
  }

  function a(p, g) {
      const w = e.params.navigation;
      p = rt(p), p.forEach(y => {
          y && (y.classList[g ? "add" : "remove"](...w.disabledClass.split(" ")), y.tagName === "BUTTON" && (y.disabled = g), e.params.watchOverflow && e.enabled && y.classList[e.isLocked ? "add" : "remove"](w.lockClass))
      })
  }

  function l() {
      const {
          nextEl: p,
          prevEl: g
      } = e.navigation;
      if (e.params.loop) {
          a(g, !1), a(p, !1);
          return
      }
      a(g, e.isBeginning && !e.params.rewind), a(p, e.isEnd && !e.params.rewind)
  }

  function o(p) {
      p.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), s("navigationPrev"))
  }

  function u(p) {
      p.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), s("navigationNext"))
  }

  function c() {
      const p = e.params.navigation;
      if (e.params.navigation = Lp(e, e.originalParams.navigation, e.params.navigation, {
              nextEl: "swiper-button-next",
              prevEl: "swiper-button-prev"
          }), !(p.nextEl || p.prevEl)) return;
      let g = r(p.nextEl),
          w = r(p.prevEl);
      Object.assign(e.navigation, {
          nextEl: g,
          prevEl: w
      }), g = rt(g), w = rt(w);
      const y = (b, x) => {
          b && b.addEventListener("click", x === "next" ? u : o), !e.enabled && b && b.classList.add(...p.lockClass.split(" "))
      };
      g.forEach(b => y(b, "next")), w.forEach(b => y(b, "prev"))
  }

  function h() {
      let {
          nextEl: p,
          prevEl: g
      } = e.navigation;
      p = rt(p), g = rt(g);
      const w = (y, b) => {
          y.removeEventListener("click", b === "next" ? u : o), y.classList.remove(...e.params.navigation.disabledClass.split(" "))
      };
      p.forEach(y => w(y, "next")), g.forEach(y => w(y, "prev"))
  }
  n("init", () => {
      e.params.navigation.enabled === !1 ? f() : (c(), l())
  }), n("toEdge fromEdge lock unlock", () => {
      l()
  }), n("destroy", () => {
      h()
  }), n("enable disable", () => {
      let {
          nextEl: p,
          prevEl: g
      } = e.navigation;
      if (p = rt(p), g = rt(g), e.enabled) {
          l();
          return
      } [...p, ...g].filter(w => !!w).forEach(w => w.classList.add(e.params.navigation.lockClass))
  }), n("click", (p, g) => {
      let {
          nextEl: w,
          prevEl: y
      } = e.navigation;
      w = rt(w), y = rt(y);
      const b = g.target;
      let x = y.includes(b) || w.includes(b);
      if (e.isElement && !x) {
          const k = g.path || g.composedPath && g.composedPath();
          k && (x = k.find(S => w.includes(S) || y.includes(S)))
      }
      if (e.params.navigation.hideOnClick && !x) {
          if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === b || e.pagination.el.contains(b))) return;
          let k;
          w.length ? k = w[0].classList.contains(e.params.navigation.hiddenClass) : y.length && (k = y[0].classList.contains(e.params.navigation.hiddenClass)), s(k === !0 ? "navigationShow" : "navigationHide"), [...w, ...y].filter(S => !!S).forEach(S => S.classList.toggle(e.params.navigation.hiddenClass))
      }
  });
  const d = () => {
          e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), c(), l()
      },
      f = () => {
          e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), h()
      };
  Object.assign(e.navigation, {
      enable: d,
      disable: f,
      update: l,
      init: c,
      destroy: h
  })
}

function as(i) {
  return i === void 0 && (i = ""), `.${i.trim().replace(/([\.:!+\/])/g,"\\$1").replace(/ /g,".")}`
}

function gu(i) {
  let {
      swiper: e,
      extendParams: t,
      on: n,
      emit: s
  } = i;
  const r = "swiper-pagination";
  t({
      pagination: {
          el: null,
          bulletElement: "span",
          clickable: !1,
          hideOnClick: !1,
          renderBullet: null,
          renderProgressbar: null,
          renderFraction: null,
          renderCustom: null,
          progressbarOpposite: !1,
          type: "bullets",
          dynamicBullets: !1,
          dynamicMainBullets: 1,
          formatFractionCurrent: y => y,
          formatFractionTotal: y => y,
          bulletClass: `${r}-bullet`,
          bulletActiveClass: `${r}-bullet-active`,
          modifierClass: `${r}-`,
          currentClass: `${r}-current`,
          totalClass: `${r}-total`,
          hiddenClass: `${r}-hidden`,
          progressbarFillClass: `${r}-progressbar-fill`,
          progressbarOppositeClass: `${r}-progressbar-opposite`,
          clickableClass: `${r}-clickable`,
          lockClass: `${r}-lock`,
          horizontalClass: `${r}-horizontal`,
          verticalClass: `${r}-vertical`,
          paginationDisabledClass: `${r}-disabled`
      }
  }), e.pagination = {
      el: null,
      bullets: []
  };
  let a, l = 0;

  function o() {
      return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0
  }

  function u(y, b) {
      const {
          bulletActiveClass: x
      } = e.params.pagination;
      !y || (y = y[`${b==="prev"?"previous":"next"}ElementSibling`], y && (y.classList.add(`${x}-${b}`), y = y[`${b==="prev"?"previous":"next"}ElementSibling`], y && y.classList.add(`${x}-${b}-${b}`)))
  }

  function c(y) {
      const b = y.target.closest(as(e.params.pagination.bulletClass));
      if (!b) return;
      y.preventDefault();
      const x = Xr(b) * e.params.slidesPerGroup;
      if (e.params.loop) {
          if (e.realIndex === x) return;
          e.slideToLoop(x)
      } else e.slideTo(x)
  }

  function h() {
      const y = e.rtl,
          b = e.params.pagination;
      if (o()) return;
      let x = e.pagination.el;
      x = rt(x);
      let k, S;
      const B = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length,
          D = e.params.loop ? Math.ceil(B / e.params.slidesPerGroup) : e.snapGrid.length;
      if (e.params.loop ? (S = e.previousRealIndex || 0, k = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (k = e.snapIndex, S = e.previousSnapIndex) : (S = e.previousIndex || 0, k = e.activeIndex || 0), b.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) {
          const P = e.pagination.bullets;
          let I, $, V;
          if (b.dynamicBullets && (a = go(P[0], e.isHorizontal() ? "width" : "height", !0), x.forEach(N => {
                  N.style[e.isHorizontal() ? "width" : "height"] = `${a*(b.dynamicMainBullets+4)}px`
              }), b.dynamicMainBullets > 1 && S !== void 0 && (l += k - (S || 0), l > b.dynamicMainBullets - 1 ? l = b.dynamicMainBullets - 1 : l < 0 && (l = 0)), I = Math.max(k - l, 0), $ = I + (Math.min(P.length, b.dynamicMainBullets) - 1), V = ($ + I) / 2), P.forEach(N => {
                  const O = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(se => `${b.bulletActiveClass}${se}`)].map(se => typeof se == "string" && se.includes(" ") ? se.split(" ") : se).flat();
                  N.classList.remove(...O)
              }), x.length > 1) P.forEach(N => {
              const O = Xr(N);
              O === k ? N.classList.add(...b.bulletActiveClass.split(" ")) : e.isElement && N.setAttribute("part", "bullet"), b.dynamicBullets && (O >= I && O <= $ && N.classList.add(...`${b.bulletActiveClass}-main`.split(" ")), O === I && u(N, "prev"), O === $ && u(N, "next"))
          });
          else {
              const N = P[k];
              if (N && N.classList.add(...b.bulletActiveClass.split(" ")), e.isElement && P.forEach((O, se) => {
                      O.setAttribute("part", se === k ? "bullet-active" : "bullet")
                  }), b.dynamicBullets) {
                  const O = P[I],
                      se = P[$];
                  for (let G = I; G <= $; G += 1) P[G] && P[G].classList.add(...`${b.bulletActiveClass}-main`.split(" "));
                  u(O, "prev"), u(se, "next")
              }
          }
          if (b.dynamicBullets) {
              const N = Math.min(P.length, b.dynamicMainBullets + 4),
                  O = (a * N - a) / 2 - V * a,
                  se = y ? "right" : "left";
              P.forEach(G => {
                  G.style[e.isHorizontal() ? se : "top"] = `${O}px`
              })
          }
      }
      x.forEach((P, I) => {
          if (b.type === "fraction" && (P.querySelectorAll(as(b.currentClass)).forEach($ => {
                  $.textContent = b.formatFractionCurrent(k + 1)
              }), P.querySelectorAll(as(b.totalClass)).forEach($ => {
                  $.textContent = b.formatFractionTotal(D)
              })), b.type === "progressbar") {
              let $;
              b.progressbarOpposite ? $ = e.isHorizontal() ? "vertical" : "horizontal" : $ = e.isHorizontal() ? "horizontal" : "vertical";
              const V = (k + 1) / D;
              let N = 1,
                  O = 1;
              $ === "horizontal" ? N = V : O = V, P.querySelectorAll(as(b.progressbarFillClass)).forEach(se => {
                  se.style.transform = `translate3d(0,0,0) scaleX(${N}) scaleY(${O})`, se.style.transitionDuration = `${e.params.speed}ms`
              })
          }
          b.type === "custom" && b.renderCustom ? (P.innerHTML = b.renderCustom(e, k + 1, D), I === 0 && s("paginationRender", P)) : (I === 0 && s("paginationRender", P), s("paginationUpdate", P)), e.params.watchOverflow && e.enabled && P.classList[e.isLocked ? "add" : "remove"](b.lockClass)
      })
  }

  function d() {
      const y = e.params.pagination;
      if (o()) return;
      const b = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length;
      let x = e.pagination.el;
      x = rt(x);
      let k = "";
      if (y.type === "bullets") {
          let S = e.params.loop ? Math.ceil(b / e.params.slidesPerGroup) : e.snapGrid.length;
          e.params.freeMode && e.params.freeMode.enabled && S > b && (S = b);
          for (let B = 0; B < S; B += 1) y.renderBullet ? k += y.renderBullet.call(e, B, y.bulletClass) : k += `<${y.bulletElement} ${e.isElement?'part="bullet"':""} class="${y.bulletClass}"></${y.bulletElement}>`
      }
      y.type === "fraction" && (y.renderFraction ? k = y.renderFraction.call(e, y.currentClass, y.totalClass) : k = `<span class="${y.currentClass}"></span> / <span class="${y.totalClass}"></span>`), y.type === "progressbar" && (y.renderProgressbar ? k = y.renderProgressbar.call(e, y.progressbarFillClass) : k = `<span class="${y.progressbarFillClass}"></span>`), e.pagination.bullets = [], x.forEach(S => {
          y.type !== "custom" && (S.innerHTML = k || ""), y.type === "bullets" && e.pagination.bullets.push(...S.querySelectorAll(as(y.bulletClass)))
      }), y.type !== "custom" && s("paginationRender", x[0])
  }

  function f() {
      e.params.pagination = Lp(e, e.originalParams.pagination, e.params.pagination, {
          el: "swiper-pagination"
      });
      const y = e.params.pagination;
      if (!y.el) return;
      let b;
      typeof y.el == "string" && e.isElement && (b = e.el.querySelector(y.el)), !b && typeof y.el == "string" && (b = [...document.querySelectorAll(y.el)]), b || (b = y.el), !(!b || b.length === 0) && (e.params.uniqueNavElements && typeof y.el == "string" && Array.isArray(b) && b.length > 1 && (b = [...e.el.querySelectorAll(y.el)], b.length > 1 && (b = b.filter(x => bp(x, ".swiper")[0] === e.el)[0])), Array.isArray(b) && b.length === 1 && (b = b[0]), Object.assign(e.pagination, {
          el: b
      }), b = rt(b), b.forEach(x => {
          y.type === "bullets" && y.clickable && x.classList.add(...(y.clickableClass || "").split(" ")), x.classList.add(y.modifierClass + y.type), x.classList.add(e.isHorizontal() ? y.horizontalClass : y.verticalClass), y.type === "bullets" && y.dynamicBullets && (x.classList.add(`${y.modifierClass}${y.type}-dynamic`), l = 0, y.dynamicMainBullets < 1 && (y.dynamicMainBullets = 1)), y.type === "progressbar" && y.progressbarOpposite && x.classList.add(y.progressbarOppositeClass), y.clickable && x.addEventListener("click", c), e.enabled || x.classList.add(y.lockClass)
      }))
  }

  function p() {
      const y = e.params.pagination;
      if (o()) return;
      let b = e.pagination.el;
      b && (b = rt(b), b.forEach(x => {
          x.classList.remove(y.hiddenClass), x.classList.remove(y.modifierClass + y.type), x.classList.remove(e.isHorizontal() ? y.horizontalClass : y.verticalClass), y.clickable && (x.classList.remove(...(y.clickableClass || "").split(" ")), x.removeEventListener("click", c))
      })), e.pagination.bullets && e.pagination.bullets.forEach(x => x.classList.remove(...y.bulletActiveClass.split(" ")))
  }
  n("changeDirection", () => {
      if (!e.pagination || !e.pagination.el) return;
      const y = e.params.pagination;
      let {
          el: b
      } = e.pagination;
      b = rt(b), b.forEach(x => {
          x.classList.remove(y.horizontalClass, y.verticalClass), x.classList.add(e.isHorizontal() ? y.horizontalClass : y.verticalClass)
      })
  }), n("init", () => {
      e.params.pagination.enabled === !1 ? w() : (f(), d(), h())
  }), n("activeIndexChange", () => {
      typeof e.snapIndex > "u" && h()
  }), n("snapIndexChange", () => {
      h()
  }), n("snapGridLengthChange", () => {
      d(), h()
  }), n("destroy", () => {
      p()
  }), n("enable disable", () => {
      let {
          el: y
      } = e.pagination;
      y && (y = rt(y), y.forEach(b => b.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass)))
  }), n("lock unlock", () => {
      h()
  }), n("click", (y, b) => {
      const x = b.target,
          k = rt(e.pagination.el);
      if (e.params.pagination.el && e.params.pagination.hideOnClick && k && k.length > 0 && !x.classList.contains(e.params.pagination.bulletClass)) {
          if (e.navigation && (e.navigation.nextEl && x === e.navigation.nextEl || e.navigation.prevEl && x === e.navigation.prevEl)) return;
          const S = k[0].classList.contains(e.params.pagination.hiddenClass);
          s(S === !0 ? "paginationShow" : "paginationHide"), k.forEach(B => B.classList.toggle(e.params.pagination.hiddenClass))
      }
  });
  const g = () => {
          e.el.classList.remove(e.params.pagination.paginationDisabledClass);
          let {
              el: y
          } = e.pagination;
          y && (y = rt(y), y.forEach(b => b.classList.remove(e.params.pagination.paginationDisabledClass))), f(), d(), h()
      },
      w = () => {
          e.el.classList.add(e.params.pagination.paginationDisabledClass);
          let {
              el: y
          } = e.pagination;
          y && (y = rt(y), y.forEach(b => b.classList.add(e.params.pagination.paginationDisabledClass))), p()
      };
  Object.assign(e.pagination, {
      enable: g,
      disable: w,
      render: d,
      update: h,
      init: f,
      destroy: p
  })
}

function yu(i) {
  let {
      swiper: e,
      extendParams: t,
      on: n,
      emit: s,
      params: r
  } = i;
  e.autoplay = {
      running: !1,
      paused: !1,
      timeLeft: 0
  }, t({
      autoplay: {
          enabled: !1,
          delay: 3e3,
          waitForTransition: !0,
          disableOnInteraction: !1,
          stopOnLastSlide: !1,
          reverseDirection: !1,
          pauseOnMouseEnter: !1
      }
  });
  let a, l, o = r && r.autoplay ? r.autoplay.delay : 3e3,
      u = r && r.autoplay ? r.autoplay.delay : 3e3,
      c, h = new Date().getTime(),
      d, f, p, g, w, y, b;

  function x(ae) {
      !e || e.destroyed || !e.wrapperEl || ae.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", x), !(b || ae.detail && ae.detail.bySwiperTouchMove) && $())
  }
  const k = () => {
          if (e.destroyed || !e.autoplay.running) return;
          e.autoplay.paused ? d = !0 : d && (u = c, d = !1);
          const ae = e.autoplay.paused ? c : h + u - new Date().getTime();
          e.autoplay.timeLeft = ae, s("autoplayTimeLeft", ae, ae / o), l = requestAnimationFrame(() => {
              k()
          })
      },
      S = () => {
          let ae;
          return e.virtual && e.params.virtual.enabled ? ae = e.slides.filter(Oe => Oe.classList.contains("swiper-slide-active"))[0] : ae = e.slides[e.activeIndex], ae ? parseInt(ae.getAttribute("data-swiper-autoplay"), 10) : void 0
      },
      B = ae => {
          if (e.destroyed || !e.autoplay.running) return;
          cancelAnimationFrame(l), k();
          let $e = typeof ae > "u" ? e.params.autoplay.delay : ae;
          o = e.params.autoplay.delay, u = e.params.autoplay.delay;
          const Oe = S();
          !Number.isNaN(Oe) && Oe > 0 && typeof ae > "u" && ($e = Oe, o = Oe, u = Oe), c = $e;
          const Ye = e.params.speed,
              it = () => {
                  !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(Ye, !0, !0), s("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, Ye, !0, !0), s("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(Ye, !0, !0), s("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, Ye, !0, !0), s("autoplay")), e.params.cssMode && (h = new Date().getTime(), requestAnimationFrame(() => {
                      B()
                  })))
              };
          return $e > 0 ? (clearTimeout(a), a = setTimeout(() => {
              it()
          }, $e)) : requestAnimationFrame(() => {
              it()
          }), $e
      },
      D = () => {
          h = new Date().getTime(), e.autoplay.running = !0, B(), s("autoplayStart")
      },
      P = () => {
          e.autoplay.running = !1, clearTimeout(a), cancelAnimationFrame(l), s("autoplayStop")
      },
      I = (ae, $e) => {
          if (e.destroyed || !e.autoplay.running) return;
          clearTimeout(a), ae || (y = !0);
          const Oe = () => {
              s("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", x) : $()
          };
          if (e.autoplay.paused = !0, $e) {
              w && (c = e.params.autoplay.delay), w = !1, Oe();
              return
          }
          c = (c || e.params.autoplay.delay) - (new Date().getTime() - h), !(e.isEnd && c < 0 && !e.params.loop) && (c < 0 && (c = 0), Oe())
      },
      $ = () => {
          e.isEnd && c < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (h = new Date().getTime(), y ? (y = !1, B(c)) : B(), e.autoplay.paused = !1, s("autoplayResume"))
      },
      V = () => {
          if (e.destroyed || !e.autoplay.running) return;
          const ae = Ci();
          ae.visibilityState === "hidden" && (y = !0, I(!0)), ae.visibilityState === "visible" && $()
      },
      N = ae => {
          ae.pointerType === "mouse" && (y = !0, b = !0, !(e.animating || e.autoplay.paused) && I(!0))
      },
      O = ae => {
          ae.pointerType === "mouse" && (b = !1, e.autoplay.paused && $())
      },
      se = () => {
          e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", N), e.el.addEventListener("pointerleave", O))
      },
      G = () => {
          e.el && typeof e.el != "string" && (e.el.removeEventListener("pointerenter", N), e.el.removeEventListener("pointerleave", O))
      },
      te = () => {
          Ci().addEventListener("visibilitychange", V)
      },
      le = () => {
          Ci().removeEventListener("visibilitychange", V)
      };
  n("init", () => {
      e.params.autoplay.enabled && (se(), te(), D())
  }), n("destroy", () => {
      G(), le(), e.autoplay.running && P()
  }), n("_freeModeStaticRelease", () => {
      (p || y) && $()
  }), n("_freeModeNoMomentumRelease", () => {
      e.params.autoplay.disableOnInteraction ? P() : I(!0, !0)
  }), n("beforeTransitionStart", (ae, $e, Oe) => {
      e.destroyed || !e.autoplay.running || (Oe || !e.params.autoplay.disableOnInteraction ? I(!0, !0) : P())
  }), n("sliderFirstMove", () => {
      if (!(e.destroyed || !e.autoplay.running)) {
          if (e.params.autoplay.disableOnInteraction) {
              P();
              return
          }
          f = !0, p = !1, y = !1, g = setTimeout(() => {
              y = !0, p = !0, I(!0)
          }, 200)
      }
  }), n("touchEnd", () => {
      if (!(e.destroyed || !e.autoplay.running || !f)) {
          if (clearTimeout(g), clearTimeout(a), e.params.autoplay.disableOnInteraction) {
              p = !1, f = !1;
              return
          }
          p && e.params.cssMode && $(), p = !1, f = !1
      }
  }), n("slideChange", () => {
      e.destroyed || !e.autoplay.running || (w = !0)
  }), Object.assign(e.autoplay, {
      start: D,
      stop: P,
      pause: I,
      resume: $
  })
}
const A_ = {
      class: "max-w-screen-2xl mx-auto mt-4 mb-6 w-full"
  },
  V_ = {
      key: 0
  },
  z_ = {
      class: "md:hidden"
  },
  W_ = {
      class: "hidden md:flex md:justify-between md:space-x-4"
  },
  U_ = {
      key: 1
  },
  j_ = {
      class: "lg:hidden"
  },
  H_ = {
      class: "hidden lg:flex lg:justify-between lg:space-x-4"
  },
  uh = M(!0),
  q_ = U({
      name: "TopSection",
      components: {
          Card: fo,
          CardLoading: po,
          Swiper: qs,
          SwiperSlide: Gs
      }
  }),
  G_ = U({
      ...q_,
      setup(i) {
          const e = M(window.innerWidth),
              t = si(),
              n = q(() => [...t.spotPairs.values()].sort((a, l) => l.dailyNtlVolume - a.dailyNtlVolume).slice(0, 4)),
              s = q(() => e.value < 640 ? 1 : 2),
              r = async () => {
                  await t.fetchSpotPairs(), setTimeout(() => {
                      uh.value = !1
                  }, 200)
              };
          return Te(() => {
              r(), window.addEventListener("resize", () => {
                  e.value = window.innerWidth
              })
          }), (a, l) => (_(), T("div", A_, [uh.value ? (_(), T("div", V_, [m("div", z_, [(_(), T(F, null, ue(1, o => z(po, {
              key: o
          })), 64))]), m("div", W_, [(_(), T(F, null, ue(4, o => z(po, {
              key: o
          })), 64))])])) : (_(), T("div", U_, [m("div", j_, [z(pe(qs), {
              "slides-per-view": s.value,
              "space-between": 20,
              modules: [pe(yu), pe(mu), pe(gu)],
              autoplay: {
                  delay: 3e3,
                  disableOnInteraction: !1
              },
              navigation: !1,
              pagination: !1
          }, {
              default: We(() => [(_(!0), T(F, null, ue(n.value, (o, u) => (_(), xe(pe(Gs), {
                  key: u
              }, {
                  default: We(() => [z(fo, {
                      pair: o
                  }, null, 8, ["pair"])]),
                  _: 2
              }, 1024))), 128))]),
              _: 1
          }, 8, ["slides-per-view", "modules"])]), m("div", H_, [(_(!0), T(F, null, ue(n.value, (o, u) => (_(), xe(fo, {
              key: u,
              pair: o
          }, null, 8, ["pair"]))), 128))])]))]))
      }
  }),
  K_ = Xi("exploreFilter", {
      state: () => ({
          sortColumn: "",
          sortDirection: "desc",
          filterValues: {
              volume: {
                  min: null,
                  max: null
              },
              marketCap: {
                  min: null,
                  max: null
              }
          }
      }),
      actions: {
          setSortColumn(i) {
              this.sortColumn = i, this.saveToLocalStorage()
          },
          setSortDirection(i) {
              this.sortDirection = i, this.saveToLocalStorage()
          },
          setFilterValues(i, e, t) {
              this.filterValues[i] = {
                  min: e,
                  max: t
              }, this.saveToLocalStorage()
          },
          resetFilter(i) {
              this.filterValues[i] = {
                  min: null,
                  max: null
              }, this.saveToLocalStorage()
          },
          loadFromLocalStorage() {
              const i = localStorage.getItem("exploreFilterState");
              if (i) try {
                  const e = JSON.parse(i);
                  this.$patch(e)
              } catch (e) {
                  console.error("Error parsing saved state:", e)
              }
          },
          saveToLocalStorage() {
              try {
                  localStorage.setItem("exploreFilterState", JSON.stringify({
                      sortColumn: this.sortColumn,
                      sortDirection: this.sortDirection,
                      filterValues: this.filterValues
                  }))
              } catch (i) {
                  console.error("Error saving state to localStorage:", i)
              }
          }
      }
  }),
  X_ = {
      class: "sticky top-0 z-20 bg-gray-50 dark:bg-slate-700 rounded-t-lg"
  },
  J_ = ["onClick"],
  Y_ = {
      class: "mr-4"
  },
  Q_ = {
      key: 0,
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-0 md:group-hover:opacity-100 transition-opacity duration-200"
  },
  Z_ = {
      key: 1
  },
  ex = {
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-100 md:group-hover:opacity-0 transition-opacity"
  },
  tx = {
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-0 md:group-hover:opacity-100 transition-opacity"
  },
  ix = ["onClick"],
  nx = {
      key: 0,
      stroke: "currentColor",
      fill: "currentColor",
      "stroke-width": "0",
      viewBox: "0 0 16 16",
      focusable: "false",
      class: "chakra-icon custom-eupi28",
      "aria-hidden": "true",
      height: "1em",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg"
  },
  sx = {
      key: 1,
      stroke: "currentColor",
      fill: "currentColor",
      "stroke-width": "0",
      viewBox: "0 0 16 16",
      focusable: "false",
      class: "chakra-icon custom-eupi28",
      "aria-hidden": "true",
      height: "1em",
      width: "1em",
      xmlns: "http://www.w3.org/2000/svg"
  },
  rx = {
      key: 0,
      class: "fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50"
  },
  ax = {
      class: "bg-gray-700 text-white p-6 sm:rounded-lg w-full h-full md:w-[400px] md:h-auto h-[calc(100vh-116px)] mt-2 pt-8 sm:pt-6"
  },
  lx = {
      class: "flex justify-between items-center mb-4"
  },
  ox = {
      class: "text-xl font-bold text-white"
  },
  ux = {
      class: "space-y-4"
  },
  cx = {
      class: "flex space-x-2"
  },
  hx = {
      class: "w-1/2"
  },
  dx = ["for"],
  fx = ["id"],
  px = {
      class: "w-1/2"
  },
  mx = ["for"],
  gx = ["id"],
  yx = {
      class: "grid grid-cols-3 gap-2"
  },
  vx = ["onClick"],
  bx = U({
      name: "GalleryFilter"
  }),
  Pp = U({
      ...bx,
      props: {
          pairs: {},
          columns: {}
      },
      emits: ["update"],
      setup(i, {
          emit: e
      }) {
          const t = i,
              n = e,
              s = K_(),
              r = M(!1),
              a = M("volume"),
              l = x => x === "dailyNtlVolume" ? s.filterValues.volume.min !== null && s.filterValues.volume.min > 0 || s.filterValues.volume.max !== null : x === "marketCap" ? s.filterValues.marketCap.min !== null && s.filterValues.marketCap.min > 0 || s.filterValues.marketCap.max !== null : !1,
              o = () => {
                  s.resetFilter(a.value), w(), d()
              },
              u = {
                  volume: [5e3, 1e4, 5e4, 1e5, 5e5, 1e6],
                  marketCap: [1e6, 1e7, 1e8, 1e9, 1e10, 1e11]
              },
              c = q(() => a.value === "volume" ? "Filter 24h Volume" : "Filter Market Cap"),
              h = x => {
                  a.value = x, r.value = !0
              },
              d = () => {
                  r.value = !1
              },
              f = x => {
                  s.setFilterValues(a.value, x, 1 / 0), p()
              },
              p = () => {
                  w(), d()
              },
              g = (x, k) => k.split(".").reduce((S, B) => S && S[B], x),
              w = () => {
                  let x = t.pairs.filter(k => {
                      const S = (s.filterValues.volume.min === null || s.filterValues.volume.min <= 0 || k.dailyNtlVolume >= s.filterValues.volume.min) && (s.filterValues.volume.max === null || k.dailyNtlVolume <= s.filterValues.volume.max),
                          B = k.midPrice * (k.base.circulatingSupply || 0),
                          D = (s.filterValues.marketCap.min === null || s.filterValues.marketCap.min <= 0 || B >= s.filterValues.marketCap.min) && (s.filterValues.marketCap.max === null || B <= s.filterValues.marketCap.max);
                      return S && D
                  });
                  x.sort((k, S) => {
                      let B, D;
                      if (s.sortColumn === "priceChange") {
                          const P = k.midPrice - k.previousDayPx,
                              I = S.midPrice - S.previousDayPx;
                          B = P / k.previousDayPx * 100 || void 0, D = I / S.previousDayPx * 100 || void 0
                      } else s.sortColumn === "marketCap" ? (B = k.midPrice * (k.base?.circulatingSupply || 0), D = S.midPrice * (S.base?.circulatingSupply || 0)) : (B = g(k, s.sortColumn), D = g(S, s.sortColumn));
                      return typeof B == "string" && (B = B.toLowerCase()), typeof D == "string" && (D = D.toLowerCase()), B < D ? s.sortDirection === "asc" ? -1 : 1 : B > D ? s.sortDirection === "asc" ? 1 : -1 : 0
                  }), n("update", x)
              },
              y = x => x >= 1e9 ? x / 1e9 + "M" : x >= 1e6 ? x / 1e6 + "m" : x.toLocaleString(),
              b = x => {
                  s.sortColumn === x ? s.sortDirection === "asc" ? (s.setSortColumn(""), s.setSortDirection("desc")) : s.setSortDirection("asc") : (s.setSortColumn(x), s.setSortDirection("desc")), w()
              };
          return Te(() => {
              s.loadFromLocalStorage(), s.filterValues.volume.min === null && s.filterValues.volume.max === null && s.setFilterValues("volume", 0, null), s.filterValues.marketCap.min === null && s.filterValues.marketCap.max === null && s.setFilterValues("marketCap", 0, null), w()
          }), Ie(() => t.pairs, w, {
              immediate: !0
          }), (x, k) => (_(), T(F, null, [m("thead", X_, [m("tr", null, [(_(!0), T(F, null, ue(x.columns, S => (_(), T("th", {
              key: S.key,
              scope: "col",
              style: tt([S.key === "marketCap" || S.key === "dailyNtlVolume" ? {
                  minWidth: "140px"
              } : {}, {
                  width: S.width
              }]),
              class: ie(["py-3 px-3 text-sm font-semibold text-gray-900 dark:text-gray-300 cursor-pointer white-space-nowrap", S.align === "right" ? "text-right" : "text-left", S.key === "base.name" ? "sticky left-0 bg-gray-50 dark:bg-slate-700 z-20" : ""])
          }, [m("div", {
              class: ie(["flex items-center", S.align === "right" ? "justify-end" : "justify-start"])
          }, [m("span", {
              onClick: B => b(S.key),
              class: "cursor-pointer group relative"
          }, [m("span", Y_, A(S.label), 1), pe(s).sortColumn !== S.key ? (_(), T("span", Q_, " \u25BC ")) : ye("", !0), pe(s).sortColumn === S.key ? (_(), T("span", Z_, [m("span", ex, A(pe(s).sortDirection === "asc" ? "\u25B2" : "\u25BC"), 1), m("span", tx, A(pe(s).sortDirection === "asc" ? "" : "\u25B2"), 1)])) : ye("", !0)], 8, J_), S.key === "dailyNtlVolume" || S.key === "marketCap" ? (_(), T("button", {
              key: 0,
              onClick: B => h(S.key === "dailyNtlVolume" ? "volume" : "marketCap"),
              class: ie(["ml-1 hover:text-green-500 transition-colors duration-200 mt-0.5", l(S.key) ? "text-green-500 hover:text-green-700" : ""])
          }, [l(S.key) ? ye("", !0) : (_(), T("svg", nx, k[2] || (k[2] = [m("path", {
              "fill-rule": "evenodd",
              "clip-rule": "evenodd",
              d: "M15 2v1.67l-5 4.759V14H6V8.429l-5-4.76V2h14zM7 8v5h2V8l5-4.76V3H2v.24L7 8z"
          }, null, -1)]))), l(S.key) ? (_(), T("svg", sx, k[3] || (k[3] = [m("path", {
              "fill-rule": "evenodd",
              "clip-rule": "evenodd",
              d: "M15 2v1.67l-5 4.759V14H6V8.429l-5-4.76V2h14z"
          }, null, -1)]))) : ye("", !0)], 10, ix)) : ye("", !0)], 2)], 6))), 128))])]), r.value ? (_(), T("div", rx, [m("div", ax, [m("div", lx, [m("h2", ox, A(c.value), 1), m("button", {
              onClick: d,
              class: "text-2xl"
          }, "\xD7")]), m("div", ux, [m("div", cx, [m("div", hx, [m("label", {
              for: `min${a.value}`,
              class: "block mb-1 text-white"
          }, "Minimum:", 8, dx), Mt(m("input", {
              id: `min${a.value}`,
              "onUpdate:modelValue": k[0] || (k[0] = S => pe(s).filterValues[a.value].min = S),
              type: "number",
              class: "w-full border rounded px-4 py-2 border-gray-300 focus:outline-none focus:ring-0 bg-gray-300 text-black placeholder-gray-800 gradient-focus"
          }, null, 8, fx), [
              [zr, pe(s).filterValues[a.value].min, void 0, {
                  number: !0
              }]
          ])]), m("div", px, [m("label", {
              for: `max${a.value}`,
              class: "block mb-1 text-white"
          }, "Maximum:", 8, mx), Mt(m("input", {
              id: `max${a.value}`,
              "onUpdate:modelValue": k[1] || (k[1] = S => pe(s).filterValues[a.value].max = S),
              type: "number",
              class: "w-full border rounded px-4 py-2 border-gray-300 focus:outline-none focus:ring-0 bg-gray-300 text-black placeholder-gray-800 gradient-focus"
          }, null, 8, gx), [
              [zr, pe(s).filterValues[a.value].max, void 0, {
                  number: !0
              }]
          ])])]), m("div", yx, [(_(!0), T(F, null, ue(u[a.value], S => (_(), T("button", {
              key: S,
              onClick: B => f(S),
              class: "px-3 py-1 bg-green-300 rounded text-sm whitespace-nowrap overflow-hidden text-ellipsis text-black"
          }, " >$" + A(y(S)), 9, vx))), 128))])]), m("div", {
              class: "flex space-x-2 mt-4"
          }, [m("button", {
              onClick: p,
              class: "px-4 py-2 bg-green-500 text-white rounded w-1/2 hover:bg-green-600 transition-colors duration-200"
          }, " Apply "), m("button", {
              onClick: o,
              class: "px-4 py-2 bg-gray-500 text-white rounded w-1/2 hover:bg-gray-600 transition-colors duration-200"
          }, " Reset ")])])])) : ye("", !0)], 64))
      }
  }),
  wx = U({
      name: "PairRow"
  }),
  Ip = U({
      ...wx,
      props: {
          pair: {},
          columns: {}
      },
      setup(i) {
          const e = i,
              t = a => new Intl.NumberFormat("en-US", {
                  minimumFractionDigits: 2
              }).format(a),
              n = (a, l) => new Intl.NumberFormat("en-US", {
                  style: "currency",
                  currency: "USD",
                  minimumFractionDigits: l
              }).format(a),
              s = () => {
                  const a = (e.pair.midPrice - e.pair.previousDayPx) / e.pair.previousDayPx * 100 || 0;
                  return e.pair.dailyNtlVolume === 0 ? "text-gray-500" : a >= 0 ? ["text-green-700", "dark:text-green-400"] : ["text-red-700", "dark:text-red-400"]
              },
              r = a => {
                  switch (a) {
                      case "base.name":
                          return e.pair.base.name;
                      case "markPrice":
                          let l = 8 - e.pair.base?.szDecimals || 0;
                          return n(e.pair.midPrice, l);
                      case "priceChange":
                          if (e.pair.dailyNtlVolume === 0 || e.pair.midPrice === 0 || e.pair.previousDayPx === 0) return "-";
                          const o = e.pair.midPrice - e.pair.previousDayPx,
                              u = o / e.pair.previousDayPx * 100 || 0;
                          return `${t(o)} / ${u.toFixed(2)}%`;
                      case "dailyNtlVolume":
                          return e.pair.dailyNtlVolume === 0 ? ut(0) : ut(e.pair.dailyNtlVolume);
                      case "marketCap":
                          return ut(e.pair.midPrice * (e.pair.base.circulatingSupply || 0));
                      default:
                          return ""
                  }
              };
          return (a, l) => {
              const o = st("router-link");
              return _(), T("tr", null, [(_(!0), T(F, null, ue(a.columns, u => (_(), T("td", {
                  key: u.key,
                  class: ie(["whitespace-nowrap py-4 px-3 text-sm bg-white dark:bg-slate-800", u.align === "right" ? "text-right" : "text-left", u.key === "base.name" ? "font-medium text-gray-900 dark:text-gray-300 sticky left-0 bg-white dark:bg-slate-800 z-10" : "text-gray-500 dark:text-gray-300", u.key === "priceChange" ? s() : ""]),
                  style: tt({
                      width: u.width
                  })
              }, [u.key === "base.name" ? (_(), xe(o, {
                  key: 0,
                  to: {
                      name: "PairDetail",
                      params: {
                          id: a.pair.id
                      }
                  }
              }, {
                  default: We(() => [Xe(A(r(u.key)), 1)]),
                  _: 2
              }, 1032, ["to"])) : (_(), T(F, {
                  key: 1
              }, [Xe(A(r(u.key)), 1)], 64))], 6))), 128))])
          }
      }
  }),
  kx = U({
      name: "PairRowLoading"
  }),
  Np = U({
      ...kx,
      props: {
          columns: {}
      },
      setup(i) {
          const e = t => {
              switch (t) {
                  case "base.name":
                      return "w-3/4";
                  case "markPrice":
                  case "priceChange":
                      return "w-2/3";
                  case "dailyNtlVolume":
                  case "marketCap":
                      return "w-1/2";
                  default:
                      return "w-1/2"
              }
          };
          return (t, n) => (_(), T("tr", null, [(_(!0), T(F, null, ue(t.columns, (s, r) => (_(), T("td", {
              key: r,
              class: ie(["whitespace-nowrap py-4 px-3 text-sm bg-white dark:bg-slate-800", s.key === "base.name" ? "font-medium text-gray-900 sticky left-0 bg-white dark:bg-slate-800 z-10" : "text-gray-500"]),
              style: tt({
                  width: s.width
              })
          }, [m("div", {
              class: ie(["animate-pulse bg-gray-300 dark:bg-slate-700 h-6 rounded", [e(s.key), s.align === "right" ? "ml-auto" : "mr-auto"]])
          }, null, 2)], 6))), 128))]))
      }
  }),
  _x = {
      class: "flex flex-col h-full max-w-screen-2xl mx-auto bg-gray-300/25 dark:bg-slate-700/25 rounded-lg lg:rounded-xl overflow-hidden border border-gray-300 dark:border-gray-700"
  },
  xx = {
      class: "overflow-x-auto overflow-y-auto"
  },
  Tx = {
      class: "w-full min-w-[640px]"
  },
  Sx = {
      class: "divide-y divide-gray-300 dark:divide-gray-700 w-full"
  },
  ch = M(!0),
  Ex = U({
      name: "Gallery",
      components: {
          GalleryFilter: Pp,
          PairRow: Ip,
          PairRowLoading: Np
      }
  }),
  Cx = U({
      ...Ex,
      setup(i) {
          const e = si(),
              t = q(() => Array.from(e.spotPairs.values())),
              n = M([]),
              s = M(""),
              r = [{
                  key: "base.name",
                  label: "Token",
                  align: "left",
                  width: "14%"
              }, {
                  key: "markPrice",
                  label: "Price",
                  align: "right",
                  width: "14%"
              }, {
                  key: "priceChange",
                  label: "24h Change",
                  align: "right",
                  width: "19%"
              }, {
                  key: "dailyNtlVolume",
                  label: "24h Volume",
                  align: "right",
                  width: "24%"
              }, {
                  key: "marketCap",
                  label: "Market Cap",
                  align: "right",
                  width: "29%"
              }],
              a = q(() => s.value ? t.value.filter(o => o.base.name.toLowerCase().includes(s.value.toLowerCase())) : t.value),
              l = o => {
                  n.value = o
              };
          return Te(async () => {
              await e.fetchSpotPairs(), setTimeout(() => {
                  ch.value = !1
              }, 200)
          }), (o, u) => (_(), T("div", _x, [m("div", xx, [m("table", Tx, [z(Pp, {
              pairs: a.value,
              columns: r,
              onUpdate: l
          }, null, 8, ["pairs"]), m("tbody", Sx, [ch.value ? (_(), T(F, {
              key: 0
          }, ue(24, c => z(Np, {
              key: c,
              columns: r
          })), 64)) : (_(!0), T(F, {
              key: 1
          }, ue(n.value, c => (_(), xe(Ip, {
              key: c.id,
              pair: c,
              columns: r
          }, null, 8, ["pair"]))), 128))])])])]))
      }
  });
const $x = Ee(Cx, [
      ["__scopeId", "data-v-e3e2a0c9"]
  ]),
  Lx = {
      name: "Home",
      components: {
          TopSection: G_,
          Gallery: $x
      }
  },
  Px = {
      class: "flex flex-col h-[calc(100vh-100px)] py-4 z-10 relative px-4 sm:px-6 xl:px-2 overflow-y-auto landscape:overflow-y-auto"
  },
  Ix = {
      class: "flex-shrink-0"
  },
  Nx = {
      class: "flex-grow overflow-hidden landscape:min-h-[300px]"
  };

function Mx(i, e, t, n, s, r) {
  const a = st("TopSection"),
      l = st("Gallery");
  return _(), T(F, null, [e[0] || (e[0] = m("div", {
      class: "absolute inset-y-0 right-1/2 z-1 -mr-96 w-[200%] origin-top-right skew-x-[-30deg] bg-white dark:bg-slate-900 ring-1 ring-green-50 dark:ring-green-400 sm:-mr-80 lg:-mr-48",
      "aria-hidden": "true"
  }, null, -1)), m("div", Px, [m("div", Ix, [z(a)]), m("div", Nx, [z(l)])])], 64)
}
const Rx = Ee(Lx, [
      ["render", Mx]
  ]),
  Bx = {
      class: "flex flex-col sm:flex-row gap-4 py-4 bg-base-200 rounded-lg"
  },
  Ox = {
      class: "flex-grow"
  },
  Dx = {
      class: "flex gap-2"
  },
  Fx = U({
      __name: "GalleryFilter",
      emits: ["search"],
      setup(i, {
          emit: e
      }) {
          const t = e,
              n = M(""),
              s = M("lastEvent"),
              r = M("desc"),
              a = () => {
                  t("search", n.value, {
                      by: s.value,
                      direction: r.value
                  })
              };
          return Ie(n, () => {
              a()
          }), Ie([s, r], () => {
              a()
          }), (l, o) => (_(), T("div", Bx, [m("div", Ox, [Mt(m("input", {
              type: "text",
              placeholder: "Search by name...",
              class: "search-input focus:ring-0 dark:bg-slate-800 dark:text-white dark:border-gray-400/25 border-solid border-gray-600/25 rounded-lg",
              "onUpdate:modelValue": o[0] || (o[0] = u => n.value = u),
              onInput: a
          }, null, 544), [
              [zr, n.value]
          ])]), m("div", Dx, [Mt(m("select", {
              class: "select px-4 dark:bg-slate-800 dark:text-white dark:border-gray-400/25 border-solid border-gray-600/25 rounded-lg focus:ring-0",
              "onUpdate:modelValue": o[1] || (o[1] = u => s.value = u),
              onChange: a
          }, o[2] || (o[2] = [m("option", {
              value: "lastEvent"
          }, "Latest Activity", -1), m("option", {
              value: "marketCap"
          }, "Market Cap", -1), m("option", {
              value: "timestamp"
          }, "Launch Date", -1), m("option", {
              value: "volume"
          }, "Volume", -1)]), 544), [
              [by, s.value]
          ])])]))
      }
  });
const Ax = Ee(Fx, [
      ["__scopeId", "data-v-bc115c83"]
  ]),
  Vx = {
      class: "mt-2 mb-2 w-full"
  },
  zx = {
      class: "w-full bg-gray-200 rounded-full h-2 dark:bg-gray-700"
  },
  Wx = {
      class: "text-xs text-gray-600 dark:text-gray-400 mt-1"
  },
  Ux = U({
      name: "LaunchProgress"
  }),
  ka = U({
      ...Ux,
      props: {
          launch: {
              type: Object,
              required: !0
          }
      },
      setup(i) {
          const e = St(),
              t = i;
          q(() => {
              if (!t.launch) return 0;
              switch (t.launch.poolType) {
                  case Gt.Quadratic: {
                      const r = t.launch.k / (t.launch.x + t.launch.x0);
                      return (t.launch.x + t.launch.x0) / r
                  }
                  case Gt.Fixed:
                      return t.launch.x0 / t.launch.k;
                  default:
                      return 0
              }
          });
          const n = q(() => !t.launch || e.auctionPrice == 0 ? 0 : t.launch.session && t.launch.session.step > 0 ? 100 : t.launch.x / 10 ** t.launch.decimals * .65 / e.auctionPrice * 100),
              s = q(() => n.value < 20 ? "\u{1F9A7} Aping in the initial liquidity" : n.value < 40 ? "\u{1F319} Loading moon.exe..." : n.value < 60 ? "\u{1F48E} Diamond hands assembling" : n.value < 80 ? "\u{1F680} Preparing for HyperLiquid takeoff" : n.value < 95 ? "\u{1F988} Big players entering the pool" : "\u{1F525} You late brother");
          return (r, a) => (_(), T("div", Vx, [a[0] || (a[0] = m("div", {
              class: "text-xs text-gray-700 dark:text-gray-300 mb-1"
          }, " Progress to deployment: ", -1)), m("div", zx, [m("div", {
              class: "bg-blue-600 h-2 rounded-full",
              style: tt({
                  width: `${n.value}%`
              })
          }, null, 4)]), m("div", Wx, A(n.value.toFixed(2)) + "% - " + A(s.value), 1)]))
      }
  }),
  jx = {
      class: "min-w-32 flex-shrink-0 relative"
  },
  Hx = {
      class: "pulse-loader absolute inset-0 rounded-lg w-32 h-32 bg-gray-300 dark:bg-slate-700"
  },
  qx = ["alt", "src"],
  Gx = ["src"],
  Kx = {
      class: "flex flex-col flex-grow ml-4"
  },
  Xx = {
      class: "gap-1 grid h-fit"
  },
  Jx = {
      class: "text-xs text-gray-700 dark:text-gray-300 flex items-center gap-2"
  },
  Yx = {
      type: "button",
      class: "-ml-1"
  },
  Qx = {
      class: "flex gap-1 items-center"
  },
  Zx = ["alt"],
  eT = {
      class: "rounded hover:underline flex -ml-1",
      style: {
          "background-color": "transparent"
      }
  },
  tT = {
      class: "text-xs text-green-500 dark:text-green-400 flex gap-1 -mt-1"
  },
  iT = {
      class: "text-sm w-full flex flex-col mt-2"
  },
  nT = {
      class: "font-bold uppercase dark:text-white"
  },
  sT = {
      class: "text-xs text-gray-700 dark:text-gray-300 description"
  },
  rT = {
      class: "trust-factor"
  },
  aT = {
      class: "trust-factor-badge py-0.5 px-2"
  },
  lT = {
      class: "trust-factor-emoji"
  },
  oT = {
      class: "flex flex-row justify-between absolute left-4 bottom-8 w-[calc(100%-48px)]"
  },
  uT = {
      class: "card-footer absolute bottom-2 left-4 w-full"
  },
  cT = {
      class: "flex flex-col items-center gap-2"
  },
  hT = {
      class: "flex gap-1 items-center"
  },
  dT = {
      key: 0,
      class: "flex gap-1 items-center text-xs has-tooltip"
  },
  fT = {
      key: 1,
      class: "flex flex-col w-full"
  },
  pT = {
      class: "flex flex-row items-center"
  },
  mT = {
      class: "min-w-16 flex-shrink-0 relative"
  },
  gT = {
      class: "pulse-loader absolute inset-0 rounded-lg w-16 h-16 bg-gray-300 dark:bg-slate-700"
  },
  yT = ["alt", "src"],
  vT = {
      class: "flex flex-col ml-4"
  },
  bT = {
      class: "text-xs text-gray-700 dark:text-gray-300 flex items-center gap-2"
  },
  wT = {
      type: "button",
      class: "-ml-1"
  },
  kT = {
      class: "flex gap-1 items-center"
  },
  _T = ["alt"],
  xT = {
      class: "rounded hover:underline flex -ml-1",
      style: {
          "background-color": "transparent"
      }
  },
  TT = {
      class: "text-xs text-green-500 dark:text-green-400 flex gap-1 -mt-1"
  },
  ST = {
      class: "trust-factor"
  },
  ET = {
      class: "trust-factor-badge py-0.5 px-2"
  },
  CT = {
      class: "trust-factor-emoji"
  },
  $T = {
      class: "text-xs w-full flex flex-col mt-2"
  },
  LT = {
      class: "font-bold uppercase"
  },
  PT = {
      class: "text-[10px] leading-[12px] text-gray-700 dark:text-gray-300 description"
  },
  IT = {
      class: "card-footer absolute bottom-2 left-4 w-full"
  },
  NT = {
      class: "flex flex-col items-center gap-2"
  },
  MT = {
      class: "flex gap-1 items-center"
  },
  RT = {
      key: 0,
      class: "flex gap-1 items-center text-xs has-tooltip"
  },
  BT = U({
      name: "Card",
      props: {
          launch: Object
      },
      components: {
          LaunchProgress: ka
      }
  }),
  OT = U({
      ...BT,
      props: {
          launch: Object
      },
      setup(i) {
          const e = i,
              t = M(window.innerWidth < 768),
              n = () => {
                  t.value = window.innerWidth < 768
              };
          Te(() => {
              window.addEventListener("resize", n)
          }), ct(() => {
              window.removeEventListener("resize", n)
          });
          const s = q(() => {
                  if (!e.launch.telegramUser) return "\u2753";
                  let p = e.launch.telegramUser.reputationScore;
                  return p < 3 ? "\u{1F534}" : p < 5 ? "\u{1F7E1}" : p < 8 ? "\u{1F7E2}" : "\u{1F451}"
              }),
              r = q(() => e.launch.session ? e.launch.session.fullName : "Unknown"),
              a = q(() => e.launch.session ? e.launch.session.tokenName : "Unknown"),
              l = q(() => e.launch.session ? "https://media.hypurr.fun/" + e.launch.mediaFileId : "Unknown"),
              o = q(() => {
                  switch (e.launch.poolType) {
                      case Gt.Quadratic:
                          let p = e.launch.k / (e.launch.x + e.launch.x0);
                          return (e.launch.x + e.launch.x0) / p;
                      case Gt.Fixed:
                          return e.launch.x0 / e.launch.k;
                      default:
                          return 0
                  }
              }),
              u = q(() => e.launch.telegramUser ? e.launch.telegramUser.username : "Unknown"),
              c = q(() => {
                  if (!e.launch.session) return "0";
                  let g = -e.launch.y / Math.pow(10, e.launch.decimals) * o.value;
                  return ut(g)
              }),
              h = q(() => {
                  const p = t ? 50 : 100;
                  return e.launch?.description && e.launch.description.length > p ? e.launch.description.slice(0, p) + "..." : e.launch?.description || ""
              }),
              d = M(!1),
              f = M(null);
          return Te(() => {
              f.value?.complete && f.value?.naturalHeight !== 0 && (d.value = !0)
          }), (p, g) => {
              const w = st("router-link");
              return _(), xe(w, {
                  to: {
                      name: "LaunchDetail",
                      params: {
                          id: i.launch.id
                      }
                  },
                  class: ie(["bg-white dark:bg-slate-800 dark:text-white rounded-lg shadow p-2 sm:p-4 relative border-solid border-gray-600/25 dark:border-gray-400/25 border-[1px] w-full flex flex-row opacity-0", [t.value ? "h-48" : "h-60", {
                      "animate-fade-in": !0
                  }]])
              }, {
                  default: We(() => [t.value ? (_(), T("div", fT, [m("div", pT, [m("div", mT, [Mt(m("div", gT, null, 512), [
                      [Ls, !d.value]
                  ]), m("img", {
                      alt: a.value,
                      loading: "lazy",
                      width: "128",
                      height: "128",
                      decoding: "async",
                      "data-nimg": "1",
                      class: ie(["w-16 h-16 object-cover rounded-lg transition-opacity duration-500 relative z-10", {
                          "opacity-0": !d.value,
                          "opacity-100": d.value
                      }]),
                      src: l.value,
                      ref: f.value,
                      onLoad: g[2] || (g[2] = y => d.value = !0)
                  }, null, 42, yT)]), m("div", vT, [m("div", bT, [g[10] || (g[10] = m("div", {
                      class: "text-black dark:text-white bold"
                  }, "Created by:", -1)), m("button", wT, [m("span", kT, [m("img", {
                      alt: u.value,
                      loading: "lazy",
                      width: "24",
                      height: "24",
                      decoding: "async",
                      "data-nimg": "1",
                      class: "w-6 h-6 rounded-full",
                      src: Is
                  }, null, 8, _T), m("span", xT, A(u.value), 1)])])]), m("div", TT, " Market cap: " + A(c.value), 1)])]), m("div", ST, [m("div", ET, [g[11] || (g[11] = m("span", {
                      class: "trust-factor-label text-[10px] text-gray-900 dark:text-gray-300"
                  }, "Trust Factor:", -1)), m("span", CT, A(s.value), 1)])]), m("p", $T, [m("span", LT, A(r.value.length > 64 ? r.value.slice(0, 64) + "..." : r.value) + " (" + A(a.value) + "): ", 1), m("span", PT, A(h.value), 1)]), m("div", IT, [m("div", NT, [m("div", MT, [g[13] || (g[13] = m("span", {
                      class: "text-xs text-black dark:text-white bold"
                  }, "Achievements", -1)), g[14] || (g[14] = Xe(" [ ")), e.launch?.session?.step > 0 ? (_(), T("span", RT, g[12] || (g[12] = [m("span", {
                      class: "rounded flex",
                      style: {
                          "background-color": "transparent"
                      }
                  }, " \u{1F680} ", -1), m("span", {
                      class: "tooltip-text"
                  }, "Token is launched", -1)]))) : ye("", !0), g[15] || (g[15] = Xe(" ] "))])])])])) : (_(), T(F, {
                      key: 0
                  }, [m("div", jx, [Mt(m("div", Hx, null, 512), [
                      [Ls, !d.value]
                  ]), i.launch.mediaType == "photo" ? (_(), T("img", {
                      key: 0,
                      ref_key: "imageElement",
                      ref: f,
                      alt: a.value,
                      loading: "lazy",
                      width: "128",
                      height: "128",
                      decoding: "async",
                      "data-nimg": "1",
                      class: ie(["w-32 h-32 object-cover rounded-lg transition-opacity duration-500 relative z-10", {
                          "opacity-0": !d.value,
                          "opacity-100": d.value
                      }]),
                      src: l.value,
                      onLoad: g[0] || (g[0] = y => d.value = !0)
                  }, null, 42, qx)) : (_(), T("video", {
                      key: 1,
                      width: "128",
                      height: "128",
                      loading: "lazy",
                      class: ie(["w-32 h-32 object-cover rounded-lg transition-opacity duration-500 relative z-10", {
                          "opacity-0": !d.value,
                          "opacity-100": d.value
                      }]),
                      onCanplay: g[1] || (g[1] = y => d.value = !0),
                      muted: !0,
                      autoplay: "",
                      loop: "",
                      playsinline: ""
                  }, [m("source", {
                      src: l.value,
                      type: "video/mp4"
                  }, null, 8, Gx), g[3] || (g[3] = Xe(" Your browser does not support the video tag. "))], 34))]), m("div", Kx, [m("div", Xx, [m("div", Jx, [g[4] || (g[4] = m("div", {
                      class: "text-black dark:text-white bold"
                  }, "Created by:", -1)), m("button", Yx, [m("span", Qx, [m("img", {
                      alt: u.value,
                      loading: "lazy",
                      width: "24",
                      height: "24",
                      decoding: "async",
                      "data-nimg": "1",
                      class: "w-6 h-6 rounded-full",
                      src: Is
                  }, null, 8, Zx), m("span", eT, A(u.value), 1)])])]), m("div", tT, " Market cap: " + A(c.value), 1), m("p", iT, [m("span", nT, A(r.value.length > 64 ? r.value.slice(0, 64) + "..." : r.value) + " (" + A(a.value) + "): ", 1), m("span", sT, A(h.value), 1)]), m("div", rT, [m("div", aT, [g[5] || (g[5] = m("span", {
                      class: "trust-factor-label text-[10px] text-gray-900 dark:text-gray-300"
                  }, "Trust Factor:", -1)), m("span", lT, A(s.value), 1)])])]), m("div", oT, [z(ka, {
                      launch: e.launch
                  }, null, 8, ["launch"])]), m("div", uT, [m("div", cT, [m("div", hT, [g[7] || (g[7] = m("span", {
                      class: "text-xs text-black dark:text-white bold"
                  }, "Achievements", -1)), g[8] || (g[8] = Xe(" [ ")), e.launch?.session?.step > 0 ? (_(), T("span", dT, g[6] || (g[6] = [m("span", {
                      class: "rounded flex",
                      style: {
                          "background-color": "transparent"
                      }
                  }, " \u{1F680} ", -1), m("span", {
                      class: "tooltip-text"
                  }, "Token is launched", -1)]))) : ye("", !0), g[9] || (g[9] = Xe(" ] "))])])])])], 64))]),
                  _: 1
              }, 8, ["to", "class"])
          }
      }
  });
const vu = Ee(OT, [
      ["__scopeId", "data-v-2d151ead"]
  ]),
  DT = {
      key: 1,
      class: "flex flex-col w-full"
  },
  FT = U({
      name: "CardLoading"
  }),
  AT = U({
      ...FT,
      setup(i) {
          const e = M(window.innerWidth < 768),
              t = () => {
                  e.value = window.innerWidth < 768
              };
          return Te(() => {
              window.addEventListener("resize", t)
          }), ct(() => {
              window.removeEventListener("resize", t)
          }), (n, s) => (_(), T("div", {
              class: ie(["bg-white dark:bg-slate-800 rounded-lg shadow p-2 sm:p-4 relative border-solid border-gray-600/25 border-[1px] w-full flex flex-row", e.value ? "h-48" : "h-60"])
          }, [e.value ? (_(), T("div", DT, s[1] || (s[1] = [un('<div class="flex flex-row items-center" data-v-6319e414><div class="min-w-16 flex-shrink-0" data-v-6319e414><div class="w-16 h-16 bg-gray-300 dark:bg-slate-700 rounded-lg animate-pulse" data-v-6319e414></div></div><div class="flex flex-col ml-4" data-v-6319e414><div class="text-xs text-gray-700 dark:text-gray-300 flex items-center gap-2" data-v-6319e414><div class="w-16 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div><div class="w-3 h-3 bg-gray-300 dark:bg-slate-700 rounded-full animate-pulse" data-v-6319e414></div><div class="w-20 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div><div class="text-xs flex gap-1 mt-1" data-v-6319e414><div class="w-16 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div><div class="w-12 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div></div><div class="trust-factor -mt-2 -mr-2" data-v-6319e414><div class="w-20 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div></div><div class="text-xs w-full flex flex-col mt-2" data-v-6319e414><div class="w-3/4 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse mb-2" data-v-6319e414></div><div class="w-full h-12 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div><div class="card-footer flex flex-row justify-start pl-4 w-full bottom-3" data-v-6319e414><div class="flex flex-col items-center gap-2" data-v-6319e414><div class="w-32 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div></div>', 3)]))) : (_(), T(F, {
              key: 0
          }, [s[0] || (s[0] = un('<div class="min-w-32 flex-shrink-0" data-v-6319e414><div class="w-32 h-32 bg-gray-300 dark:bg-slate-700 rounded-lg animate-pulse" data-v-6319e414></div></div><div class="flex flex-col flex-grow ml-4" data-v-6319e414><div class="gap-1 grid h-fit" data-v-6319e414><div class="text-xs text-gray-700 flex items-center gap-2" data-v-6319e414><div class="w-20 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div><div class="w-6 h-6 bg-gray-300 dark:bg-slate-700 rounded-full animate-pulse" data-v-6319e414></div><div class="w-24 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div><div class="text-xs flex gap-1 -mt-1" data-v-6319e414><div class="w-20 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div><div class="text-sm w-full flex flex-col mt-2" data-v-6319e414><div class="w-3/4 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse mb-2" data-v-6319e414></div><div class="w-full h-16 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div><div class="trust-factor -mt-2 -mr-2" data-v-6319e414><div class="w-24 h-6 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div></div><div class="card-footer w-full flex flex-row justify-start pl-4 bottom-3" data-v-6319e414><div class="flex flex-col items-center gap-2" data-v-6319e414><div class="w-32 h-4 bg-gray-300 dark:bg-slate-700 rounded animate-pulse" data-v-6319e414></div></div></div></div>', 2))], 64))], 2))
      }
  });
const bu = Ee(AT, [
      ["__scopeId", "data-v-6319e414"]
  ]),
  VT = {
      class: "max-w-screen-2xl mx-auto flow-root h-full flex flex-col w-full"
  },
  zT = {
      class: "gallery-wrapper flex-grow"
  },
  WT = {
      class: "grid grid-cols-1 sm:grid-cols-2 xl:grid-cols-3 w-full justify-items-center gap-4 pb-8"
  };
M(!0);
const UT = U({
      name: "Gallery",
      components: {
          Card: vu,
          CardLoading: bu
      }
  }),
  jT = U({
      ...UT,
      setup(i) {
          const e = St(),
              t = M(""),
              n = Ji(),
              s = q(() => n.animationsEnabled);
          let r = M([]);
          const a = M("lastEvent"),
              l = M("desc"),
              o = (h, d) => {
                  t.value = h, a.value = d.by, l.value = d.direction, u()
              };
          let u = () => {
              let h = e.launches.filter(d => !t.value || d.session?.tokenName.toLowerCase().includes(t.value.toLowerCase()) || d.session?.fullName.toLowerCase().includes(t.value.toLowerCase()));
              h.sort((d, f) => {
                  let p;
                  switch (a.value) {
                      case "marketCap":
                          p = (f.x || 0) - (d.x || 0);
                          break;
                      case "timestamp":
                          p = f.listedTimestamp - d.listedTimestamp;
                          break;
                      case "volume":
                          p = (f.dailyNtlVolume || 0) - (d.dailyNtlVolume || 0);
                          break;
                      case "lastEvent":
                      default:
                          p = f.lastEventTimestamp - d.lastEventTimestamp;
                          break
                  }
                  return l.value === "desc" ? p : -p
              }), r.value = h.slice(0, 100)
          };
          Ie(e.launches, (h, d) => {
              console.log(r.value.length, h.length, d.length),
                console.log("##### - h", h),
                console.log("##### - d", d),
                console.log("##### - r.value", r.value),
                
                !(s.value && r.value.length > 0 && h.length === d.length) && u()
          }), Ie(t, (h, d) => {
              h !== d && u()
          });
          let c = q(() => e.launches.length === 0);
          return Te(() => {
              u()
          }), (h, d) => (_(), T("div", VT, [z(Ax, {
              onSearch: o
          }), m("div", zT, [m("div", WT, [pe(c) ? (_(), T(F, {
              key: 0
          }, ue(16, f => z(bu, {
              key: f
          })), 64)) : (_(!0), T(F, {
              key: 1
          }, ue(pe(r), f => (_(), xe(vu, {
              key: f.id,
              launch: f
          }, null, 8, ["launch"]))), 128))])])]))
      }
  });
const Mp = Ee(jT, [
      ["__scopeId", "data-v-0936fb31"]
  ]),
  HT = U({
      name: "TopSection",
      components: {
          Card: vu,
          CardLoading: bu,
          Swiper: qs,
          SwiperSlide: Gs
      },
      setup() {
          const i = St(),
              e = M(window.innerWidth),
              t = q(() => i.launches.size === 0),
              n = q(() => Array.from(i.launches.values())),
              s = c => {
                  switch (c.poolType) {
                      case Gt.Quadratic: {
                          const h = c.k / (c.x + c.x0);
                          return (c.x + c.x0) / h
                      }
                      case Gt.Fixed:
                          return c.x0 / c.k;
                      default:
                          return 0
                  }
              },
              r = q(() => [...n.value].sort((c, h) => {
                  const d = f => {
                      if (!f.session || f.session.step > 0) return 0;
                      const p = f.session.tokenSupply,
                          g = s(f);
                      return p * g
                  };
                  return d(h) - d(c)
              }).slice(0, 3)),
              a = q(() => e.value < 640 ? 1 : 2),
              l = async () => {
                  await i.fetchLaunches()
              }, o = M(null), u = () => {
                  e.value = window.innerWidth, o.value && o.value.update()
              };
          return Ie(e, () => {
              o.value && o.value.update()
          }), Te(() => {
              l(), window.addEventListener("resize", u)
          }), ct(() => {
              window.removeEventListener("resize", u)
          }), {
              isLoading: t,
              leaders: r,
              slidesPerView: a,
              Autoplay: yu,
              Navigation: mu,
              Pagination: gu
          }
      }
  });
const qT = {
      class: "max-w-screen-2xl mx-auto w-full dark:text-white"
  },
  GT = {
      key: 0
  },
  KT = {
      class: "md:hidden"
  },
  XT = {
      class: "hidden md:flex md:justify-between md:space-x-4"
  },
  JT = {
      key: 1
  },
  YT = {
      class: "xl:hidden"
  },
  QT = {
      class: "hidden xl:flex xl:justify-between xl:space-x-4"
  };

function ZT(i, e, t, n, s, r) {
  const a = st("CardLoading"),
      l = st("Card"),
      o = st("swiper-slide"),
      u = st("swiper");
  return _(), T("div", qT, [e[0] || (e[0] = m("h2", {
      class: "text-2xl font-bold mb-2"
  }, "Current Leaders", -1)), i.isLoading ? (_(), T("div", GT, [m("div", KT, [(_(!0), T(F, null, ue(i.slidesPerView, c => (_(), xe(a, {
      key: c
  }))), 128))]), m("div", XT, [(_(), T(F, null, ue(3, c => z(a, {
      key: c
  })), 64))])])) : (_(), T("div", JT, [m("div", YT, [z(u, {
      "slides-per-view": i.slidesPerView,
      "space-between": 20,
      modules: [i.Autoplay, i.Navigation, i.Pagination],
      autoplay: {
          delay: 3e3,
          disableOnInteraction: !1
      },
      navigation: !1,
      pagination: !1,
      observer: !0,
      "observe-parents": !0,
      "resize-observer": !0,
      onSwiper: i.onSwiper
  }, {
      default: We(() => [(_(!0), T(F, null, ue(i.leaders, (c, h) => (_(), xe(o, {
          key: h
      }, {
          default: We(() => [z(l, {
              launch: c
          }, null, 8, ["launch"])]),
          _: 2
      }, 1024))), 128))]),
      _: 1
  }, 8, ["slides-per-view", "modules", "onSwiper"])]), m("div", QT, [(_(!0), T(F, null, ue(i.leaders, (c, h) => (_(), xe(l, {
      key: h,
      launch: c
  }, null, 8, ["launch"]))), 128))])]))])
}
const Rp = Ee(HT, [
      ["render", ZT],
      ["__scopeId", "data-v-02ef357a"]
  ]),
  eS = {
      class: "relative min-h-[80px] overflow-hidden z-10 flex flex-row items-center align-start max-w-screen-2xl mx-auto my-2"
  },
  tS = {
      class: "absolute top-0 left-0 w-full flex flex-row justify-between"
  },
  iS = {
      class: "text-xs text-gray-800 dark:text-gray-200 font-semibold bg-gray-200 dark:bg-slate-600 px-2 py-1 rounded-tl-lg rounded-br-lg"
  },
  nS = {
      class: "text-xs text-gray-800 dark:text-gray-200 font-semibold bg-gray-200 dark:bg-slate-600 px-2 py-1 rounded-tr-lg rounded-bl-lg"
  },
  sS = {
      class: "flex flex-col items-start pt-4"
  },
  rS = {
      class: "text-xs text-gray-800 dark:text-gray-200 font-semibold mt-1"
  },
  aS = {
      class: "flex flex-col items-end pt-4"
  },
  lS = {
      class: "font-bold text-sm text-gray-800 dark:text-gray-200"
  },
  oS = {
      class: "text-xs text-gray-800 dark:text-gray-200 font-semibold mt-1"
  },
  uS = U({
      name: "LatestFillsBanner"
  }),
  cS = U({
      ...uS,
      setup(i) {
          const e = St(),
              t = Uu(e, "latestFills"),
              n = Uu(e, "launches"),
              s = M([]);
          M(null), M(!0);
          const r = M(!0),
              a = M(!1),
              l = M(null),
              o = M(null),
              u = M(window.innerWidth),
              c = q(() => u.value < 640 ? 2 : u.value < 1024 ? 4 : 7),
              h = 500;
          let d = null;
          const f = M(!1),
              p = () => {
                  d && clearTimeout(d), f.value = !0, o.value && clearTimeout(o.value), u.value = window.innerWidth, d = setTimeout(() => {
                      a.value && (P(), f.value = !1, $())
                  }, h)
              },
              g = V => `${V.slice(0,6)}...${V.slice(-4)}`,
              w = V => {
                  const N = new Date(V);
                  return `${N.toLocaleDateString()} ${N.toLocaleTimeString([],{hour:"2-digit",minute:"2-digit"})}`
              },
              y = V => n.value.get(V)?.session?.tokenName || "Unknown",
              b = M([]);
          M(0);
          const x = M(!1),
              k = 20,
              S = 5e3,
              B = 250,
              D = () => {
                  if (s.value.length === 0) {
                      const V = t.value.sort((N, O) => O.timestamp - N.timestamp).slice(0, k);
                      b.value = V.slice(V.length - 1 - c.value, V.length - 1), P(), setTimeout(() => {
                          r.value = !1, setTimeout(() => {
                              a.value = !0, x.value || $()
                          }, B)
                      }, 500)
                  }
              },
              P = () => {
                  s.value = b.value.slice(0, c.value)
              },
              I = V => {
                  const N = s.value[0];
                  V.timestamp > N.timestamp && (b.value.push(V), b.value = b.value.slice(-k))
              },
              $ = () => {
                  f.value || (x.value = !0, o.value = setTimeout(() => {
                      if (b.value.length > 0 && s.value.length > 0 && !f.value) {
                          const V = s.value[0].timestamp,
                              N = b.value.filter(O => O.timestamp > V).sort((O, se) => O.timestamp - se.timestamp)[0];
                          N && (s.value = [N, ...s.value.slice(0, -1)], b.value = [N, ...b.value.filter(O => O !== N)])
                      }
                      $()
                  }, S))
              };
          return Te(() => {
              window.addEventListener("resize", p)
          }), ct(() => {
              window.removeEventListener("resize", p), o.value && clearTimeout(o.value), l.value && clearTimeout(l.value), d && clearTimeout(d)
          }), Ie(t, V => {
              if (s.value.length === 0) D();
              else if (a.value) {
                  const N = b.value[0];
                  V.filter(se => se.timestamp > N.timestamp).sort((se, G) => G.timestamp - se.timestamp).forEach(I)
              }
          }, {
              deep: !0
          }), Ie(u, () => {
              a.value && P()
          }), (V, N) => (_(), T("div", eS, [z(Vf, {
              name: "fill",
              tag: "div",
              class: ie(["flex items-center", {
                  "opacity-0": !a.value,
                  "opacity-100 transition-opacity duration-300": a.value,
                  "pause-animation": f.value
              }])
          }, {
              default: We(() => [r.value ? (_(!0), T(F, {
                  key: 0
              }, ue(c.value, O => (_(), T("div", {
                  key: O,
                  class: "relative rounded-xl min-w-[200px] flex items-center justify-between mr-6 my-auto shadow-md whitespace-nowrap bg-gray-100 dark:bg-slate-700 rounded-md px-3 py-3 shadow-sm"
              }, N[0] || (N[0] = [m("div", {
                  class: "absolute top-0 left-0 w-full flex flex-row justify-between"
              }, [m("div", {
                  class: "text-xs bg-gray-200 dark:bg-slate-600 px-2 py-1 rounded-tl-lg rounded-br-lg w-16 h-5 animate-pulse"
              }), m("div", {
                  class: "text-xs bg-gray-200 dark:bg-slate-600 px-2 py-1 rounded-tr-lg rounded-bl-lg w-16 h-5 animate-pulse"
              })], -1), m("div", {
                  class: "flex flex-col items-start pt-4"
              }, [m("div", {
                  class: "text-sm font-bold w-16 h-5 bg-gray-200 dark:bg-slate-600 rounded animate-pulse"
              }), m("div", {
                  class: "text-xs mt-1 w-12 h-4 bg-gray-200 dark:bg-slate-600 rounded animate-pulse"
              })], -1), m("hr", {
                  class: "h-full mx-2 border-gray-300 dark:border-gray-700 w-[2px] bg-gray-300 dark:bg-gray-700"
              }, null, -1), m("div", {
                  class: "flex flex-col items-end pt-4"
              }, [m("div", {
                  class: "font-bold text-sm w-24 h-5 bg-gray-200 dark:bg-slate-600 rounded animate-pulse"
              }), m("div", {
                  class: "text-xs mt-1 w-20 h-4 bg-gray-200 dark:bg-slate-600 rounded animate-pulse"
              })], -1)])))), 128)) : (_(!0), T(F, {
                  key: 1
              }, ue(s.value, O => (_(), T("div", {
                  key: O.movementHash.value,
                  class: "relative rounded-xl min-w-[200px] flex items-center justify-between mr-6 my-auto shadow-md whitespace-nowrap bg-gray-100 dark:bg-slate-700 rounded-md px-3 py-3 shadow-sm transition-all duration-300 ease-in-out"
              }, [m("div", tS, [m("span", iS, A(y(O.launchId)), 1), m("span", nS, A(w(O.timestamp)), 1)]), m("div", sS, [m("span", {
                  class: ie([{
                      "text-green-600": O.launchDelta > 0,
                      "text-red-600": O.launchDelta < 0
                  }, "text-sm font-bold"])
              }, A(O.launchDelta > 0 ? "BOUGHT" : "SOLD"), 3), m("span", rS, A(pe(ut)(O.usdcDelta).replace("$", "").replace("-", "")) + " $", 1)]), N[1] || (N[1] = m("hr", {
                  class: "h-full mx-2 border-gray-300 dark:border-gray-700 w-[2px] bg-gray-300 dark:bg-gray-700"
              }, null, -1)), m("div", aS, [m("span", lS, A(g(O.wallet.ethereumAddress)), 1), m("span", oS, A(pe(ut)(O.launchDelta).replace("$", "").replace("-", "")) + " " + A(y(O.launchId)), 1)])]))), 128))]),
              _: 1
          }, 8, ["class"])]))
      }
  });
const wu = Ee(cS, [
      ["__scopeId", "data-v-00a13d36"]
  ]),
  hS = {
      class: "flex flex-col h-[calc(100vh-100px)] py-4 z-10 relative px-2 sm:px-6 xl:px-2 overflow-x-hidden overflow-y-auto landscape:overflow-y-auto custom-scrollbar"
  },
  dS = U({
      name: "Launches",
      components: {
          Gallery: Mp,
          TopSection: Rp,
          LatestFillsBanner: wu
      }
  }),
  fS = U({
      ...dS,
      setup(i) {
          const e = St();
          return Te(() => {
              e.startLatestFillStream(), e.fetchAuction()
          }), ct(() => {
              e.stopLatestFillStream()
          }), (t, n) => (_(), T(F, null, [n[0] || (n[0] = m("div", {
              class: "absolute inset-y-0 right-1/2 z-1 -mr-96 w-[200%] origin-top-right skew-x-[-30deg] bg-white dark:bg-slate-900 ring-1 ring-green-50 dark:ring-green-400 sm:-mr-80 lg:-mr-48",
              "aria-hidden": "true"
          }, null, -1)), m("div", hS, [z(wu), z(Rp), z(Mp)])], 64))
      }
  });
const pS = Ee(fS, [
      ["__scopeId", "data-v-4ab341ef"]
  ]),
  Jr = i => {
      switch (i.poolType) {
          case Gt.Quadratic:
              let e = i.k / (i.x + i.x0);
              return (i.x + i.x0) / e;
          case Gt.Fixed:
              return i.x0 / i.k;
          default:
              return 0
      }
  },
  Yr = (i, e, t) => {
      let n = i.cost / Math.pow(10, t),
          s = i.balance / Math.pow(10, t);
      return e * s - n
  };

function Ge(i) {
  var e = i.width,
      t = i.height;
  if (e < 0) throw new Error("Negative width is not allowed for Size");
  if (t < 0) throw new Error("Negative height is not allowed for Size");
  return {
      width: e,
      height: t
  }
}

function an(i, e) {
  return i.width === e.width && i.height === e.height
}
var mS = function() {
  function i(e) {
      var t = this;
      this._resolutionListener = function() {
          return t._onResolutionChanged()
      }, this._resolutionMediaQueryList = null, this._observers = [], this._window = e, this._installResolutionListener()
  }
  return i.prototype.dispose = function() {
      this._uninstallResolutionListener(), this._window = null
  }, Object.defineProperty(i.prototype, "value", {
      get: function() {
          return this._window.devicePixelRatio
      },
      enumerable: !1,
      configurable: !0
  }), i.prototype.subscribe = function(e) {
      var t = this,
          n = {
              next: e
          };
      return this._observers.push(n), {
          unsubscribe: function() {
              t._observers = t._observers.filter(function(s) {
                  return s !== n
              })
          }
      }
  }, i.prototype._installResolutionListener = function() {
      if (this._resolutionMediaQueryList !== null) throw new Error("Resolution listener is already installed");
      var e = this._window.devicePixelRatio;
      this._resolutionMediaQueryList = this._window.matchMedia("all and (resolution: ".concat(e, "dppx)")), this._resolutionMediaQueryList.addListener(this._resolutionListener)
  }, i.prototype._uninstallResolutionListener = function() {
      this._resolutionMediaQueryList !== null && (this._resolutionMediaQueryList.removeListener(this._resolutionListener), this._resolutionMediaQueryList = null)
  }, i.prototype._reinstallResolutionListener = function() {
      this._uninstallResolutionListener(), this._installResolutionListener()
  }, i.prototype._onResolutionChanged = function() {
      var e = this;
      this._observers.forEach(function(t) {
          return t.next(e._window.devicePixelRatio)
      }), this._reinstallResolutionListener()
  }, i
}();

function gS(i) {
  return new mS(i)
}
var yS = function() {
  function i(e, t, n) {
      var s;
      this._canvasElement = null, this._bitmapSizeChangedListeners = [], this._suggestedBitmapSize = null, this._suggestedBitmapSizeChangedListeners = [], this._devicePixelRatioObservable = null, this._canvasElementResizeObserver = null, this._canvasElement = e, this._canvasElementClientSize = Ge({
          width: this._canvasElement.clientWidth,
          height: this._canvasElement.clientHeight
      }), this._transformBitmapSize = t ?? function(r) {
          return r
      }, this._allowResizeObserver = (s = n?.allowResizeObserver) !== null && s !== void 0 ? s : !0, this._chooseAndInitObserver()
  }
  return i.prototype.dispose = function() {
      var e, t;
      if (this._canvasElement === null) throw new Error("Object is disposed");
      (e = this._canvasElementResizeObserver) === null || e === void 0 || e.disconnect(), this._canvasElementResizeObserver = null, (t = this._devicePixelRatioObservable) === null || t === void 0 || t.dispose(), this._devicePixelRatioObservable = null, this._suggestedBitmapSizeChangedListeners.length = 0, this._bitmapSizeChangedListeners.length = 0, this._canvasElement = null
  }, Object.defineProperty(i.prototype, "canvasElement", {
      get: function() {
          if (this._canvasElement === null) throw new Error("Object is disposed");
          return this._canvasElement
      },
      enumerable: !1,
      configurable: !0
  }), Object.defineProperty(i.prototype, "canvasElementClientSize", {
      get: function() {
          return this._canvasElementClientSize
      },
      enumerable: !1,
      configurable: !0
  }), Object.defineProperty(i.prototype, "bitmapSize", {
      get: function() {
          return Ge({
              width: this.canvasElement.width,
              height: this.canvasElement.height
          })
      },
      enumerable: !1,
      configurable: !0
  }), i.prototype.resizeCanvasElement = function(e) {
      this._canvasElementClientSize = Ge(e), this.canvasElement.style.width = "".concat(this._canvasElementClientSize.width, "px"), this.canvasElement.style.height = "".concat(this._canvasElementClientSize.height, "px"), this._invalidateBitmapSize()
  }, i.prototype.subscribeBitmapSizeChanged = function(e) {
      this._bitmapSizeChangedListeners.push(e)
  }, i.prototype.unsubscribeBitmapSizeChanged = function(e) {
      this._bitmapSizeChangedListeners = this._bitmapSizeChangedListeners.filter(function(t) {
          return t !== e
      })
  }, Object.defineProperty(i.prototype, "suggestedBitmapSize", {
      get: function() {
          return this._suggestedBitmapSize
      },
      enumerable: !1,
      configurable: !0
  }), i.prototype.subscribeSuggestedBitmapSizeChanged = function(e) {
      this._suggestedBitmapSizeChangedListeners.push(e)
  }, i.prototype.unsubscribeSuggestedBitmapSizeChanged = function(e) {
      this._suggestedBitmapSizeChangedListeners = this._suggestedBitmapSizeChangedListeners.filter(function(t) {
          return t !== e
      })
  }, i.prototype.applySuggestedBitmapSize = function() {
      if (this._suggestedBitmapSize !== null) {
          var e = this._suggestedBitmapSize;
          this._suggestedBitmapSize = null, this._resizeBitmap(e), this._emitSuggestedBitmapSizeChanged(e, this._suggestedBitmapSize)
      }
  }, i.prototype._resizeBitmap = function(e) {
      var t = this.bitmapSize;
      an(t, e) || (this.canvasElement.width = e.width, this.canvasElement.height = e.height, this._emitBitmapSizeChanged(t, e))
  }, i.prototype._emitBitmapSizeChanged = function(e, t) {
      var n = this;
      this._bitmapSizeChangedListeners.forEach(function(s) {
          return s.call(n, e, t)
      })
  }, i.prototype._suggestNewBitmapSize = function(e) {
      var t = this._suggestedBitmapSize,
          n = Ge(this._transformBitmapSize(e, this._canvasElementClientSize)),
          s = an(this.bitmapSize, n) ? null : n;
      t === null && s === null || t !== null && s !== null && an(t, s) || (this._suggestedBitmapSize = s, this._emitSuggestedBitmapSizeChanged(t, s))
  }, i.prototype._emitSuggestedBitmapSizeChanged = function(e, t) {
      var n = this;
      this._suggestedBitmapSizeChangedListeners.forEach(function(s) {
          return s.call(n, e, t)
      })
  }, i.prototype._chooseAndInitObserver = function() {
      var e = this;
      if (!this._allowResizeObserver) {
          this._initDevicePixelRatioObservable();
          return
      }
      bS().then(function(t) {
          return t ? e._initResizeObserver() : e._initDevicePixelRatioObservable()
      })
  }, i.prototype._initDevicePixelRatioObservable = function() {
      var e = this;
      if (this._canvasElement !== null) {
          var t = hh(this._canvasElement);
          if (t === null) throw new Error("No window is associated with the canvas");
          this._devicePixelRatioObservable = gS(t), this._devicePixelRatioObservable.subscribe(function() {
              return e._invalidateBitmapSize()
          }), this._invalidateBitmapSize()
      }
  }, i.prototype._invalidateBitmapSize = function() {
      var e, t;
      if (this._canvasElement !== null) {
          var n = hh(this._canvasElement);
          if (n !== null) {
              var s = (t = (e = this._devicePixelRatioObservable) === null || e === void 0 ? void 0 : e.value) !== null && t !== void 0 ? t : n.devicePixelRatio,
                  r = this._canvasElement.getClientRects(),
                  a = r[0] !== void 0 ? wS(r[0], s) : Ge({
                      width: this._canvasElementClientSize.width * s,
                      height: this._canvasElementClientSize.height * s
                  });
              this._suggestNewBitmapSize(a)
          }
      }
  }, i.prototype._initResizeObserver = function() {
      var e = this;
      this._canvasElement !== null && (this._canvasElementResizeObserver = new ResizeObserver(function(t) {
          var n = t.find(function(a) {
              return a.target === e._canvasElement
          });
          if (!(!n || !n.devicePixelContentBoxSize || !n.devicePixelContentBoxSize[0])) {
              var s = n.devicePixelContentBoxSize[0],
                  r = Ge({
                      width: s.inlineSize,
                      height: s.blockSize
                  });
              e._suggestNewBitmapSize(r)
          }
      }), this._canvasElementResizeObserver.observe(this._canvasElement, {
          box: "device-pixel-content-box"
      }))
  }, i
}();

function vS(i, e) {
  if (e.type === "device-pixel-content-box") return new yS(i, e.transform, e.options);
  throw new Error("Unsupported binding target")
}

function hh(i) {
  return i.ownerDocument.defaultView
}

function bS() {
  return new Promise(function(i) {
      var e = new ResizeObserver(function(t) {
          i(t.every(function(n) {
              return "devicePixelContentBoxSize" in n
          })), e.disconnect()
      });
      e.observe(document.body, {
          box: "device-pixel-content-box"
      })
  }).catch(function() {
      return !1
  })
}

function wS(i, e) {
  return Ge({
      width: Math.round(i.left * e + i.width * e) - Math.round(i.left * e),
      height: Math.round(i.top * e + i.height * e) - Math.round(i.top * e)
  })
}
var kS = function() {
  function i(e, t, n) {
      if (t.width === 0 || t.height === 0) throw new TypeError("Rendering target could only be created on a media with positive width and height");
      if (this._mediaSize = t, n.width === 0 || n.height === 0) throw new TypeError("Rendering target could only be created using a bitmap with positive integer width and height");
      this._bitmapSize = n, this._context = e
  }
  return i.prototype.useMediaCoordinateSpace = function(e) {
      try {
          return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.scale(this._horizontalPixelRatio, this._verticalPixelRatio), e({
              context: this._context,
              mediaSize: this._mediaSize
          })
      } finally {
          this._context.restore()
      }
  }, i.prototype.useBitmapCoordinateSpace = function(e) {
      try {
          return this._context.save(), this._context.setTransform(1, 0, 0, 1, 0, 0), e({
              context: this._context,
              mediaSize: this._mediaSize,
              bitmapSize: this._bitmapSize,
              horizontalPixelRatio: this._horizontalPixelRatio,
              verticalPixelRatio: this._verticalPixelRatio
          })
      } finally {
          this._context.restore()
      }
  }, Object.defineProperty(i.prototype, "_horizontalPixelRatio", {
      get: function() {
          return this._bitmapSize.width / this._mediaSize.width
      },
      enumerable: !1,
      configurable: !0
  }), Object.defineProperty(i.prototype, "_verticalPixelRatio", {
      get: function() {
          return this._bitmapSize.height / this._mediaSize.height
      },
      enumerable: !1,
      configurable: !0
  }), i
}();

function hn(i, e) {
  var t = i.canvasElementClientSize;
  if (t.width === 0 || t.height === 0) return null;
  var n = i.bitmapSize;
  if (n.width === 0 || n.height === 0) return null;
  var s = i.canvasElement.getContext("2d", e);
  return s === null ? null : new kS(s, t, n)
}
/*!
* @license
* TradingView Lightweight Charts™ v4.2.0
* Copyright (c) 2024 TradingView, Inc.
* Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
*/
const _S = {
      upColor: "#26a69a",
      downColor: "#ef5350",
      wickVisible: !0,
      borderVisible: !0,
      borderColor: "#378658",
      borderUpColor: "#26a69a",
      borderDownColor: "#ef5350",
      wickColor: "#737375",
      wickUpColor: "#26a69a",
      wickDownColor: "#ef5350"
  },
  xS = {
      upColor: "#26a69a",
      downColor: "#ef5350",
      openVisible: !0,
      thinBars: !0
  },
  TS = {
      color: "#2196f3",
      lineStyle: 0,
      lineWidth: 3,
      lineType: 0,
      lineVisible: !0,
      crosshairMarkerVisible: !0,
      crosshairMarkerRadius: 4,
      crosshairMarkerBorderColor: "",
      crosshairMarkerBorderWidth: 2,
      crosshairMarkerBackgroundColor: "",
      lastPriceAnimation: 0,
      pointMarkersVisible: !1
  },
  SS = {
      topColor: "rgba( 46, 220, 135, 0.4)",
      bottomColor: "rgba( 40, 221, 100, 0)",
      invertFilledArea: !1,
      lineColor: "#33D778",
      lineStyle: 0,
      lineWidth: 3,
      lineType: 0,
      lineVisible: !0,
      crosshairMarkerVisible: !0,
      crosshairMarkerRadius: 4,
      crosshairMarkerBorderColor: "",
      crosshairMarkerBorderWidth: 2,
      crosshairMarkerBackgroundColor: "",
      lastPriceAnimation: 0,
      pointMarkersVisible: !1
  },
  ES = {
      baseValue: {
          type: "price",
          price: 0
      },
      topFillColor1: "rgba(38, 166, 154, 0.28)",
      topFillColor2: "rgba(38, 166, 154, 0.05)",
      topLineColor: "rgba(38, 166, 154, 1)",
      bottomFillColor1: "rgba(239, 83, 80, 0.05)",
      bottomFillColor2: "rgba(239, 83, 80, 0.28)",
      bottomLineColor: "rgba(239, 83, 80, 1)",
      lineWidth: 3,
      lineStyle: 0,
      lineType: 0,
      lineVisible: !0,
      crosshairMarkerVisible: !0,
      crosshairMarkerRadius: 4,
      crosshairMarkerBorderColor: "",
      crosshairMarkerBorderWidth: 2,
      crosshairMarkerBackgroundColor: "",
      lastPriceAnimation: 0,
      pointMarkersVisible: !1
  },
  CS = {
      color: "#26a69a",
      base: 0
  },
  Bp = {
      color: "#2196f3"
  },
  Op = {
      title: "",
      visible: !0,
      lastValueVisible: !0,
      priceLineVisible: !0,
      priceLineSource: 0,
      priceLineWidth: 1,
      priceLineColor: "",
      priceLineStyle: 2,
      baseLineVisible: !0,
      baseLineWidth: 1,
      baseLineColor: "#B2B5BE",
      baseLineStyle: 0,
      priceFormat: {
          type: "price",
          precision: 2,
          minMove: .01
      }
  };
var dh, fh;

function dn(i, e) {
  const t = {
      0: [],
      1: [i.lineWidth, i.lineWidth],
      2: [2 * i.lineWidth, 2 * i.lineWidth],
      3: [6 * i.lineWidth, 6 * i.lineWidth],
      4: [i.lineWidth, 4 * i.lineWidth]
  } [e];
  i.setLineDash(t)
}

function Dp(i, e, t, n) {
  i.beginPath();
  const s = i.lineWidth % 2 ? .5 : 0;
  i.moveTo(t, e + s), i.lineTo(n, e + s), i.stroke()
}

function Hi(i, e) {
  if (!i) throw new Error("Assertion failed" + (e ? ": " + e : ""))
}

function xt(i) {
  if (i === void 0) throw new Error("Value is undefined");
  return i
}

function Q(i) {
  if (i === null) throw new Error("Value is null");
  return i
}

function En(i) {
  return Q(xt(i))
}(function(i) {
  i[i.Simple = 0] = "Simple", i[i.WithSteps = 1] = "WithSteps", i[i.Curved = 2] = "Curved"
})(dh || (dh = {})),
function(i) {
  i[i.Solid = 0] = "Solid", i[i.Dotted = 1] = "Dotted", i[i.Dashed = 2] = "Dashed", i[i.LargeDashed = 3] = "LargeDashed", i[i.SparseDotted = 4] = "SparseDotted"
}(fh || (fh = {}));
const ph = {
  khaki: "#f0e68c",
  azure: "#f0ffff",
  aliceblue: "#f0f8ff",
  ghostwhite: "#f8f8ff",
  gold: "#ffd700",
  goldenrod: "#daa520",
  gainsboro: "#dcdcdc",
  gray: "#808080",
  green: "#008000",
  honeydew: "#f0fff0",
  floralwhite: "#fffaf0",
  lightblue: "#add8e6",
  lightcoral: "#f08080",
  lemonchiffon: "#fffacd",
  hotpink: "#ff69b4",
  lightyellow: "#ffffe0",
  greenyellow: "#adff2f",
  lightgoldenrodyellow: "#fafad2",
  limegreen: "#32cd32",
  linen: "#faf0e6",
  lightcyan: "#e0ffff",
  magenta: "#f0f",
  maroon: "#800000",
  olive: "#808000",
  orange: "#ffa500",
  oldlace: "#fdf5e6",
  mediumblue: "#0000cd",
  transparent: "#0000",
  lime: "#0f0",
  lightpink: "#ffb6c1",
  mistyrose: "#ffe4e1",
  moccasin: "#ffe4b5",
  midnightblue: "#191970",
  orchid: "#da70d6",
  mediumorchid: "#ba55d3",
  mediumturquoise: "#48d1cc",
  orangered: "#ff4500",
  royalblue: "#4169e1",
  powderblue: "#b0e0e6",
  red: "#f00",
  coral: "#ff7f50",
  turquoise: "#40e0d0",
  white: "#fff",
  whitesmoke: "#f5f5f5",
  wheat: "#f5deb3",
  teal: "#008080",
  steelblue: "#4682b4",
  bisque: "#ffe4c4",
  aquamarine: "#7fffd4",
  aqua: "#0ff",
  sienna: "#a0522d",
  silver: "#c0c0c0",
  springgreen: "#00ff7f",
  antiquewhite: "#faebd7",
  burlywood: "#deb887",
  brown: "#a52a2a",
  beige: "#f5f5dc",
  chocolate: "#d2691e",
  chartreuse: "#7fff00",
  cornflowerblue: "#6495ed",
  cornsilk: "#fff8dc",
  crimson: "#dc143c",
  cadetblue: "#5f9ea0",
  tomato: "#ff6347",
  fuchsia: "#f0f",
  blue: "#00f",
  salmon: "#fa8072",
  blanchedalmond: "#ffebcd",
  slateblue: "#6a5acd",
  slategray: "#708090",
  thistle: "#d8bfd8",
  tan: "#d2b48c",
  cyan: "#0ff",
  darkblue: "#00008b",
  darkcyan: "#008b8b",
  darkgoldenrod: "#b8860b",
  darkgray: "#a9a9a9",
  blueviolet: "#8a2be2",
  black: "#000",
  darkmagenta: "#8b008b",
  darkslateblue: "#483d8b",
  darkkhaki: "#bdb76b",
  darkorchid: "#9932cc",
  darkorange: "#ff8c00",
  darkgreen: "#006400",
  darkred: "#8b0000",
  dodgerblue: "#1e90ff",
  darkslategray: "#2f4f4f",
  dimgray: "#696969",
  deepskyblue: "#00bfff",
  firebrick: "#b22222",
  forestgreen: "#228b22",
  indigo: "#4b0082",
  ivory: "#fffff0",
  lavenderblush: "#fff0f5",
  feldspar: "#d19275",
  indianred: "#cd5c5c",
  lightgreen: "#90ee90",
  lightgrey: "#d3d3d3",
  lightskyblue: "#87cefa",
  lightslategray: "#789",
  lightslateblue: "#8470ff",
  snow: "#fffafa",
  lightseagreen: "#20b2aa",
  lightsalmon: "#ffa07a",
  darksalmon: "#e9967a",
  darkviolet: "#9400d3",
  mediumpurple: "#9370d8",
  mediumaquamarine: "#66cdaa",
  skyblue: "#87ceeb",
  lavender: "#e6e6fa",
  lightsteelblue: "#b0c4de",
  mediumvioletred: "#c71585",
  mintcream: "#f5fffa",
  navajowhite: "#ffdead",
  navy: "#000080",
  olivedrab: "#6b8e23",
  palevioletred: "#d87093",
  violetred: "#d02090",
  yellow: "#ff0",
  yellowgreen: "#9acd32",
  lawngreen: "#7cfc00",
  pink: "#ffc0cb",
  paleturquoise: "#afeeee",
  palegoldenrod: "#eee8aa",
  darkolivegreen: "#556b2f",
  darkseagreen: "#8fbc8f",
  darkturquoise: "#00ced1",
  peachpuff: "#ffdab9",
  deeppink: "#ff1493",
  violet: "#ee82ee",
  palegreen: "#98fb98",
  mediumseagreen: "#3cb371",
  peru: "#cd853f",
  saddlebrown: "#8b4513",
  sandybrown: "#f4a460",
  rosybrown: "#bc8f8f",
  purple: "#800080",
  seagreen: "#2e8b57",
  seashell: "#fff5ee",
  papayawhip: "#ffefd5",
  mediumslateblue: "#7b68ee",
  plum: "#dda0dd",
  mediumspringgreen: "#00fa9a"
};

function Ft(i) {
  return i < 0 ? 0 : i > 255 ? 255 : Math.round(i) || 0
}

function Fp(i) {
  return i <= 0 || i > 1 ? Math.min(Math.max(i, 0), 1) : Math.round(1e4 * i) / 1e4
}
const $S = /^#([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?$/i,
  LS = /^#([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i,
  PS = /^rgb\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*\)$/,
  IS = /^rgba\(\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d{1,10})\s*,\s*(-?\d*\.?\d+)\s*\)$/;

function Rs(i) {
  (i = i.toLowerCase()) in ph && (i = ph[i]);
  {
      const e = IS.exec(i) || PS.exec(i);
      if (e) return [Ft(parseInt(e[1], 10)), Ft(parseInt(e[2], 10)), Ft(parseInt(e[3], 10)), Fp(e.length < 5 ? 1 : parseFloat(e[4]))]
  } {
      const e = LS.exec(i);
      if (e) return [Ft(parseInt(e[1], 16)), Ft(parseInt(e[2], 16)), Ft(parseInt(e[3], 16)), 1]
  } {
      const e = $S.exec(i);
      if (e) return [Ft(17 * parseInt(e[1], 16)), Ft(17 * parseInt(e[2], 16)), Ft(17 * parseInt(e[3], 16)), 1]
  }
  throw new Error(`Cannot parse color: ${i}`)
}

function Ap(i) {
  return .199 * i[0] + .687 * i[1] + .114 * i[2]
}

function _a(i) {
  const e = Rs(i);
  return {
      t: `rgb(${e[0]}, ${e[1]}, ${e[2]})`,
      i: Ap(e) > 160 ? "black" : "white"
  }
}
class Ze {
  constructor() {
      this.h = []
  }
  l(e, t, n) {
      const s = {
          o: e,
          _: t,
          u: n === !0
      };
      this.h.push(s)
  }
  v(e) {
      const t = this.h.findIndex(n => e === n.o);
      t > -1 && this.h.splice(t, 1)
  }
  p(e) {
      this.h = this.h.filter(t => t._ !== e)
  }
  m(e, t, n) {
      const s = [...this.h];
      this.h = this.h.filter(r => !r.u), s.forEach(r => r.o(e, t, n))
  }
  M() {
      return this.h.length > 0
  }
  S() {
      this.h = []
  }
}

function ni(i, ...e) {
  for (const t of e)
      for (const n in t) t[n] !== void 0 && (typeof t[n] != "object" || i[n] === void 0 || Array.isArray(t[n]) ? i[n] = t[n] : ni(i[n], t[n]));
  return i
}

function fi(i) {
  return typeof i == "number" && isFinite(i)
}

function Bs(i) {
  return typeof i == "number" && i % 1 == 0
}

function Ks(i) {
  return typeof i == "string"
}

function cr(i) {
  return typeof i == "boolean"
}

function xi(i) {
  const e = i;
  if (!e || typeof e != "object") return e;
  let t, n, s;
  for (n in t = Array.isArray(e) ? [] : {}, e) e.hasOwnProperty(n) && (s = e[n], t[n] = s && typeof s == "object" ? xi(s) : s);
  return t
}

function NS(i) {
  return i !== null
}

function Os(i) {
  return i === null ? void 0 : i
}
const ku = "-apple-system, BlinkMacSystemFont, 'Trebuchet MS', Roboto, Ubuntu, sans-serif";

function qn(i, e, t) {
  return e === void 0 && (e = ku), `${t=t!==void 0?`${t} `:""}${i}px ${e}`
}
class MS {
  constructor(e) {
      this.k = {
          C: 1,
          T: 5,
          P: NaN,
          R: "",
          D: "",
          V: "",
          O: "",
          B: 0,
          A: 0,
          I: 0,
          L: 0,
          N: 0
      }, this.F = e
  }
  W() {
      const e = this.k,
          t = this.j(),
          n = this.H();
      return e.P === t && e.D === n || (e.P = t, e.D = n, e.R = qn(t, n), e.L = 2.5 / 12 * t, e.B = e.L, e.A = t / 12 * e.T, e.I = t / 12 * e.T, e.N = 0), e.V = this.$(), e.O = this.U(), this.k
  }
  $() {
      return this.F.W().layout.textColor
  }
  U() {
      return this.F.q()
  }
  j() {
      return this.F.W().layout.fontSize
  }
  H() {
      return this.F.W().layout.fontFamily
  }
}
class _u {
  constructor() {
      this.Y = []
  }
  Z(e) {
      this.Y = e
  }
  X(e, t, n) {
      this.Y.forEach(s => {
          s.X(e, t, n)
      })
  }
}
class ri {
  X(e, t, n) {
      e.useBitmapCoordinateSpace(s => this.K(s, t, n))
  }
}
class RS extends ri {
  constructor() {
      super(...arguments), this.G = null
  }
  J(e) {
      this.G = e
  }
  K({
      context: e,
      horizontalPixelRatio: t,
      verticalPixelRatio: n
  }) {
      if (this.G === null || this.G.tt === null) return;
      const s = this.G.tt,
          r = this.G,
          a = Math.max(1, Math.floor(t)) % 2 / 2,
          l = o => {
              e.beginPath();
              for (let u = s.to - 1; u >= s.from; --u) {
                  const c = r.it[u],
                      h = Math.round(c.nt * t) + a,
                      d = c.st * n,
                      f = o * n + a;
                  e.moveTo(h, d), e.arc(h, d, f, 0, 2 * Math.PI)
              }
              e.fill()
          };
      r.et > 0 && (e.fillStyle = r.rt, l(r.ht + r.et)), e.fillStyle = r.lt, l(r.ht)
  }
}

function BS() {
  return {
      it: [{
          nt: 0,
          st: 0,
          ot: 0,
          _t: 0
      }],
      lt: "",
      rt: "",
      ht: 0,
      et: 0,
      tt: null
  }
}
const OS = {
  from: 0,
  to: 1
};
class DS {
  constructor(e, t) {
      this.ut = new _u, this.ct = [], this.dt = [], this.ft = !0, this.F = e, this.vt = t, this.ut.Z(this.ct)
  }
  bt(e) {
      const t = this.F.wt();
      t.length !== this.ct.length && (this.dt = t.map(BS), this.ct = this.dt.map(n => {
          const s = new RS;
          return s.J(n), s
      }), this.ut.Z(this.ct)), this.ft = !0
  }
  gt() {
      return this.ft && (this.Mt(), this.ft = !1), this.ut
  }
  Mt() {
      const e = this.vt.W().mode === 2,
          t = this.F.wt(),
          n = this.vt.xt(),
          s = this.F.St();
      t.forEach((r, a) => {
          var l;
          const o = this.dt[a],
              u = r.kt(n);
          if (e || u === null || !r.yt()) return void(o.tt = null);
          const c = Q(r.Ct());
          o.lt = u.Tt, o.ht = u.ht, o.et = u.Pt, o.it[0]._t = u._t, o.it[0].st = r.Dt().Rt(u._t, c.Vt), o.rt = (l = u.Ot) !== null && l !== void 0 ? l : this.F.Bt(o.it[0].st / r.Dt().At()), o.it[0].ot = n, o.it[0].nt = s.It(n), o.tt = OS
      })
  }
}
class FS extends ri {
  constructor(e) {
      super(), this.zt = e
  }
  K({
      context: e,
      bitmapSize: t,
      horizontalPixelRatio: n,
      verticalPixelRatio: s
  }) {
      if (this.zt === null) return;
      const r = this.zt.Lt.yt,
          a = this.zt.Et.yt;
      if (!r && !a) return;
      const l = Math.round(this.zt.nt * n),
          o = Math.round(this.zt.st * s);
      e.lineCap = "butt", r && l >= 0 && (e.lineWidth = Math.floor(this.zt.Lt.et * n), e.strokeStyle = this.zt.Lt.V, e.fillStyle = this.zt.Lt.V, dn(e, this.zt.Lt.Nt), function(u, c, h, d) {
          u.beginPath();
          const f = u.lineWidth % 2 ? .5 : 0;
          u.moveTo(c + f, h), u.lineTo(c + f, d), u.stroke()
      }(e, l, 0, t.height)), a && o >= 0 && (e.lineWidth = Math.floor(this.zt.Et.et * s), e.strokeStyle = this.zt.Et.V, e.fillStyle = this.zt.Et.V, dn(e, this.zt.Et.Nt), Dp(e, o, 0, t.width))
  }
}
class AS {
  constructor(e) {
      this.ft = !0, this.Ft = {
          Lt: {
              et: 1,
              Nt: 0,
              V: "",
              yt: !1
          },
          Et: {
              et: 1,
              Nt: 0,
              V: "",
              yt: !1
          },
          nt: 0,
          st: 0
      }, this.Wt = new FS(this.Ft), this.jt = e
  }
  bt() {
      this.ft = !0
  }
  gt() {
      return this.ft && (this.Mt(), this.ft = !1), this.Wt
  }
  Mt() {
      const e = this.jt.yt(),
          t = Q(this.jt.Ht()),
          n = t.$t().W().crosshair,
          s = this.Ft;
      if (n.mode === 2) return s.Et.yt = !1, void(s.Lt.yt = !1);
      s.Et.yt = e && this.jt.Ut(t), s.Lt.yt = e && this.jt.qt(), s.Et.et = n.horzLine.width, s.Et.Nt = n.horzLine.style, s.Et.V = n.horzLine.color, s.Lt.et = n.vertLine.width, s.Lt.Nt = n.vertLine.style, s.Lt.V = n.vertLine.color, s.nt = this.jt.Yt(), s.st = this.jt.Zt()
  }
}

function VS(i, e, t, n, s, r) {
  i.fillRect(e + r, t, n - 2 * r, r), i.fillRect(e + r, t + s - r, n - 2 * r, r), i.fillRect(e, t, r, s), i.fillRect(e + n - r, t, r, s)
}

function xa(i, e, t, n, s, r) {
  i.save(), i.globalCompositeOperation = "copy", i.fillStyle = r, i.fillRect(e, t, n, s), i.restore()
}

function mh(i, e, t, n, s, r) {
  i.beginPath(), i.roundRect ? i.roundRect(e, t, n, s, r) : (i.lineTo(e + n - r[1], t), r[1] !== 0 && i.arcTo(e + n, t, e + n, t + r[1], r[1]), i.lineTo(e + n, t + s - r[2]), r[2] !== 0 && i.arcTo(e + n, t + s, e + n - r[2], t + s, r[2]), i.lineTo(e + r[3], t + s), r[3] !== 0 && i.arcTo(e, t + s, e, t + s - r[3], r[3]), i.lineTo(e, t + r[0]), r[0] !== 0 && i.arcTo(e, t, e + r[0], t, r[0]))
}

function gh(i, e, t, n, s, r, a = 0, l = [0, 0, 0, 0], o = "") {
  if (i.save(), !a || !o || o === r) return mh(i, e, t, n, s, l), i.fillStyle = r, i.fill(), void i.restore();
  const u = a / 2;
  var c;
  mh(i, e + u, t + u, n - a, s - a, (c = -u, l.map(h => h === 0 ? h : h + c))), r !== "transparent" && (i.fillStyle = r, i.fill()), o !== "transparent" && (i.lineWidth = a, i.strokeStyle = o, i.closePath(), i.stroke()), i.restore()
}

function Vp(i, e, t, n, s, r, a) {
  i.save(), i.globalCompositeOperation = "copy";
  const l = i.createLinearGradient(0, 0, 0, s);
  l.addColorStop(0, r), l.addColorStop(1, a), i.fillStyle = l, i.fillRect(e, t, n, s), i.restore()
}
class yh {
  constructor(e, t) {
      this.J(e, t)
  }
  J(e, t) {
      this.zt = e, this.Xt = t
  }
  At(e, t) {
      return this.zt.yt ? e.P + e.L + e.B : 0
  }
  X(e, t, n, s) {
      if (!this.zt.yt || this.zt.Kt.length === 0) return;
      const r = this.zt.V,
          a = this.Xt.t,
          l = e.useBitmapCoordinateSpace(o => {
              const u = o.context;
              u.font = t.R;
              const c = this.Gt(o, t, n, s),
                  h = c.Jt,
                  d = (f, p) => {
                      c.Qt ? gh(u, h.ti, h.ii, h.ni, h.si, f, h.ei, [h.ht, 0, 0, h.ht], p) : gh(u, h.ri, h.ii, h.ni, h.si, f, h.ei, [0, h.ht, h.ht, 0], p)
                  };
              return d(a, "transparent"), this.zt.hi && (u.fillStyle = r, u.fillRect(h.ri, h.li, h.ai - h.ri, h.oi)), d("transparent", a), this.zt._i && (u.fillStyle = t.O, u.fillRect(c.Qt ? h.ui - h.ei : 0, h.ii, h.ei, h.ci - h.ii)), c
          });
      e.useMediaCoordinateSpace(({
          context: o
      }) => {
          const u = l.di;
          o.font = t.R, o.textAlign = l.Qt ? "right" : "left", o.textBaseline = "middle", o.fillStyle = r, o.fillText(this.zt.Kt, u.fi, (u.ii + u.ci) / 2 + u.pi)
      })
  }
  Gt(e, t, n, s) {
      var r;
      const {
          context: a,
          bitmapSize: l,
          mediaSize: o,
          horizontalPixelRatio: u,
          verticalPixelRatio: c
      } = e, h = this.zt.hi || !this.zt.mi ? t.T : 0, d = this.zt.bi ? t.C : 0, f = t.L + this.Xt.wi, p = t.B + this.Xt.gi, g = t.A, w = t.I, y = this.zt.Kt, b = t.P, x = n.Mi(a, y), k = Math.ceil(n.xi(a, y)), S = b + f + p, B = t.C + g + w + k + h, D = Math.max(1, Math.floor(c));
      let P = Math.round(S * c);
      P % 2 != D % 2 && (P += 1);
      const I = d > 0 ? Math.max(1, Math.floor(d * u)) : 0,
          $ = Math.round(B * u),
          V = Math.round(h * u),
          N = (r = this.Xt.Si) !== null && r !== void 0 ? r : this.Xt.ki,
          O = Math.round(N * c) - Math.floor(.5 * c),
          se = Math.floor(O + D / 2 - P / 2),
          G = se + P,
          te = s === "right",
          le = te ? o.width - d : d,
          ae = te ? l.width - I : I;
      let $e, Oe, Ye;
      return te ? ($e = ae - $, Oe = ae - V, Ye = le - h - g - d) : ($e = ae + $, Oe = ae + V, Ye = le + h + g), {
          Qt: te,
          Jt: {
              ii: se,
              li: O,
              ci: G,
              ni: $,
              si: P,
              ht: 2 * u,
              ei: I,
              ti: $e,
              ri: ae,
              ai: Oe,
              oi: D,
              ui: l.width
          },
          di: {
              ii: se / c,
              ci: G / c,
              fi: Ye,
              pi: x
          }
      }
  }
}
class Ta {
  constructor(e) {
      this.yi = {
          ki: 0,
          t: "#000",
          gi: 0,
          wi: 0
      }, this.Ci = {
          Kt: "",
          yt: !1,
          hi: !0,
          mi: !1,
          Ot: "",
          V: "#FFF",
          _i: !1,
          bi: !1
      }, this.Ti = {
          Kt: "",
          yt: !1,
          hi: !1,
          mi: !0,
          Ot: "",
          V: "#FFF",
          _i: !0,
          bi: !0
      }, this.ft = !0, this.Pi = new(e || yh)(this.Ci, this.yi), this.Ri = new(e || yh)(this.Ti, this.yi)
  }
  Kt() {
      return this.Di(), this.Ci.Kt
  }
  ki() {
      return this.Di(), this.yi.ki
  }
  bt() {
      this.ft = !0
  }
  At(e, t = !1) {
      return Math.max(this.Pi.At(e, t), this.Ri.At(e, t))
  }
  Vi() {
      return this.yi.Si || 0
  }
  Oi(e) {
      this.yi.Si = e
  }
  Bi() {
      return this.Di(), this.Ci.yt || this.Ti.yt
  }
  Ai() {
      return this.Di(), this.Ci.yt
  }
  gt(e) {
      return this.Di(), this.Ci.hi = this.Ci.hi && e.W().ticksVisible, this.Ti.hi = this.Ti.hi && e.W().ticksVisible, this.Pi.J(this.Ci, this.yi), this.Ri.J(this.Ti, this.yi), this.Pi
  }
  Ii() {
      return this.Di(), this.Pi.J(this.Ci, this.yi), this.Ri.J(this.Ti, this.yi), this.Ri
  }
  Di() {
      this.ft && (this.Ci.hi = !0, this.Ti.hi = !1, this.zi(this.Ci, this.Ti, this.yi))
  }
}
class zS extends Ta {
  constructor(e, t, n) {
      super(), this.jt = e, this.Li = t, this.Ei = n
  }
  zi(e, t, n) {
      if (e.yt = !1, this.jt.W().mode === 2) return;
      const s = this.jt.W().horzLine;
      if (!s.labelVisible) return;
      const r = this.Li.Ct();
      if (!this.jt.yt() || this.Li.Ni() || r === null) return;
      const a = _a(s.labelBackgroundColor);
      n.t = a.t, e.V = a.i;
      const l = 2 / 12 * this.Li.P();
      n.wi = l, n.gi = l;
      const o = this.Ei(this.Li);
      n.ki = o.ki, e.Kt = this.Li.Fi(o._t, r), e.yt = !0
  }
}
const WS = /[1-9]/g;
class zp {
  constructor() {
      this.zt = null
  }
  J(e) {
      this.zt = e
  }
  X(e, t) {
      if (this.zt === null || this.zt.yt === !1 || this.zt.Kt.length === 0) return;
      const n = e.useMediaCoordinateSpace(({
          context: d
      }) => (d.font = t.R, Math.round(t.Wi.xi(d, Q(this.zt).Kt, WS))));
      if (n <= 0) return;
      const s = t.ji,
          r = n + 2 * s,
          a = r / 2,
          l = this.zt.Hi;
      let o = this.zt.ki,
          u = Math.floor(o - a) + .5;
      u < 0 ? (o += Math.abs(0 - u), u = Math.floor(o - a) + .5) : u + r > l && (o -= Math.abs(l - (u + r)), u = Math.floor(o - a) + .5);
      const c = u + r,
          h = Math.ceil(0 + t.C + t.T + t.L + t.P + t.B);
      e.useBitmapCoordinateSpace(({
          context: d,
          horizontalPixelRatio: f,
          verticalPixelRatio: p
      }) => {
          const g = Q(this.zt);
          d.fillStyle = g.t;
          const w = Math.round(u * f),
              y = Math.round(0 * p),
              b = Math.round(c * f),
              x = Math.round(h * p),
              k = Math.round(2 * f);
          if (d.beginPath(), d.moveTo(w, y), d.lineTo(w, x - k), d.arcTo(w, x, w + k, x, k), d.lineTo(b - k, x), d.arcTo(b, x, b, x - k, k), d.lineTo(b, y), d.fill(), g.hi) {
              const S = Math.round(g.ki * f),
                  B = y,
                  D = Math.round((B + t.T) * p);
              d.fillStyle = g.V;
              const P = Math.max(1, Math.floor(f)),
                  I = Math.floor(.5 * f);
              d.fillRect(S - I, B, P, D - B)
          }
      }), e.useMediaCoordinateSpace(({
          context: d
      }) => {
          const f = Q(this.zt),
              p = 0 + t.C + t.T + t.L + t.P / 2;
          d.font = t.R, d.textAlign = "left", d.textBaseline = "middle", d.fillStyle = f.V;
          const g = t.Wi.Mi(d, "Apr0");
          d.translate(u + s, p + g), d.fillText(f.Kt, 0, 0)
      })
  }
}
class US {
  constructor(e, t, n) {
      this.ft = !0, this.Wt = new zp, this.Ft = {
          yt: !1,
          t: "#4c525e",
          V: "white",
          Kt: "",
          Hi: 0,
          ki: NaN,
          hi: !0
      }, this.vt = e, this.$i = t, this.Ei = n
  }
  bt() {
      this.ft = !0
  }
  gt() {
      return this.ft && (this.Mt(), this.ft = !1), this.Wt.J(this.Ft), this.Wt
  }
  Mt() {
      const e = this.Ft;
      if (e.yt = !1, this.vt.W().mode === 2) return;
      const t = this.vt.W().vertLine;
      if (!t.labelVisible) return;
      const n = this.$i.St();
      if (n.Ni()) return;
      e.Hi = n.Hi();
      const s = this.Ei();
      if (s === null) return;
      e.ki = s.ki;
      const r = n.Ui(this.vt.xt());
      e.Kt = n.qi(Q(r)), e.yt = !0;
      const a = _a(t.labelBackgroundColor);
      e.t = a.t, e.V = a.i, e.hi = n.W().ticksVisible
  }
}
class xu {
  constructor() {
      this.Yi = null, this.Zi = 0
  }
  Xi() {
      return this.Zi
  }
  Ki(e) {
      this.Zi = e
  }
  Dt() {
      return this.Yi
  }
  Gi(e) {
      this.Yi = e
  }
  Ji(e) {
      return []
  }
  Qi() {
      return []
  }
  yt() {
      return !0
  }
}
var vh;
(function(i) {
  i[i.Normal = 0] = "Normal", i[i.Magnet = 1] = "Magnet", i[i.Hidden = 2] = "Hidden"
})(vh || (vh = {}));
class jS extends xu {
  constructor(e, t) {
      super(), this.tn = null, this.nn = NaN, this.sn = 0, this.en = !0, this.rn = new Map, this.hn = !1, this.ln = NaN, this.an = NaN, this._n = NaN, this.un = NaN, this.$i = e, this.cn = t, this.dn = new DS(e, this), this.fn = ((s, r) => a => {
          const l = r(),
              o = s();
          if (a === Q(this.tn).vn()) return {
              _t: o,
              ki: l
          };
          {
              const u = Q(a.Ct());
              return {
                  _t: a.pn(l, u),
                  ki: l
              }
          }
      })(() => this.nn, () => this.an);
      const n = ((s, r) => () => {
          const a = this.$i.St().mn(s()),
              l = r();
          return a && Number.isFinite(l) ? {
              ot: a,
              ki: l
          } : null
      })(() => this.sn, () => this.Yt());
      this.bn = new US(this, e, n), this.wn = new AS(this)
  }
  W() {
      return this.cn
  }
  gn(e, t) {
      this._n = e, this.un = t
  }
  Mn() {
      this._n = NaN, this.un = NaN
  }
  xn() {
      return this._n
  }
  Sn() {
      return this.un
  }
  kn(e, t, n) {
      this.hn || (this.hn = !0), this.en = !0, this.yn(e, t, n)
  }
  xt() {
      return this.sn
  }
  Yt() {
      return this.ln
  }
  Zt() {
      return this.an
  }
  yt() {
      return this.en
  }
  Cn() {
      this.en = !1, this.Tn(), this.nn = NaN, this.ln = NaN, this.an = NaN, this.tn = null, this.Mn()
  }
  Pn(e) {
      return this.tn !== null ? [this.wn, this.dn] : []
  }
  Ut(e) {
      return e === this.tn && this.cn.horzLine.visible
  }
  qt() {
      return this.cn.vertLine.visible
  }
  Rn(e, t) {
      this.en && this.tn === e || this.rn.clear();
      const n = [];
      return this.tn === e && n.push(this.Dn(this.rn, t, this.fn)), n
  }
  Qi() {
      return this.en ? [this.bn] : []
  }
  Ht() {
      return this.tn
  }
  Vn() {
      this.wn.bt(), this.rn.forEach(e => e.bt()), this.bn.bt(), this.dn.bt()
  }
  On(e) {
      return e && !e.vn().Ni() ? e.vn() : null
  }
  yn(e, t, n) {
      this.Bn(e, t, n) && this.Vn()
  }
  Bn(e, t, n) {
      const s = this.ln,
          r = this.an,
          a = this.nn,
          l = this.sn,
          o = this.tn,
          u = this.On(n);
      this.sn = e, this.ln = isNaN(e) ? NaN : this.$i.St().It(e), this.tn = n;
      const c = u !== null ? u.Ct() : null;
      return u !== null && c !== null ? (this.nn = t, this.an = u.Rt(t, c)) : (this.nn = NaN, this.an = NaN), s !== this.ln || r !== this.an || l !== this.sn || a !== this.nn || o !== this.tn
  }
  Tn() {
      const e = this.$i.wt().map(n => n.In().An()).filter(NS),
          t = e.length === 0 ? null : Math.max(...e);
      this.sn = t !== null ? t : NaN
  }
  Dn(e, t, n) {
      let s = e.get(t);
      return s === void 0 && (s = new zS(this, t, n), e.set(t, s)), s
  }
}

function Sa(i) {
  return i === "left" || i === "right"
}
class ht {
  constructor(e) {
      this.zn = new Map, this.Ln = [], this.En = e
  }
  Nn(e, t) {
      const n = function(s, r) {
          return s === void 0 ? r : {
              Fn: Math.max(s.Fn, r.Fn),
              Wn: s.Wn || r.Wn
          }
      }(this.zn.get(e), t);
      this.zn.set(e, n)
  }
  jn() {
      return this.En
  }
  Hn(e) {
      const t = this.zn.get(e);
      return t === void 0 ? {
          Fn: this.En
      } : {
          Fn: Math.max(this.En, t.Fn),
          Wn: t.Wn
      }
  }
  $n() {
      this.Un(), this.Ln = [{
          qn: 0
      }]
  }
  Yn(e) {
      this.Un(), this.Ln = [{
          qn: 1,
          Vt: e
      }]
  }
  Zn(e) {
      this.Xn(), this.Ln.push({
          qn: 5,
          Vt: e
      })
  }
  Un() {
      this.Xn(), this.Ln.push({
          qn: 6
      })
  }
  Kn() {
      this.Un(), this.Ln = [{
          qn: 4
      }]
  }
  Gn(e) {
      this.Un(), this.Ln.push({
          qn: 2,
          Vt: e
      })
  }
  Jn(e) {
      this.Un(), this.Ln.push({
          qn: 3,
          Vt: e
      })
  }
  Qn() {
      return this.Ln
  }
  ts(e) {
      for (const t of e.Ln) this.ns(t);
      this.En = Math.max(this.En, e.En), e.zn.forEach((t, n) => {
          this.Nn(n, t)
      })
  }
  static ss() {
      return new ht(2)
  }
  static es() {
      return new ht(3)
  }
  ns(e) {
      switch (e.qn) {
          case 0:
              this.$n();
              break;
          case 1:
              this.Yn(e.Vt);
              break;
          case 2:
              this.Gn(e.Vt);
              break;
          case 3:
              this.Jn(e.Vt);
              break;
          case 4:
              this.Kn();
              break;
          case 5:
              this.Zn(e.Vt);
              break;
          case 6:
              this.Xn()
      }
  }
  Xn() {
      const e = this.Ln.findIndex(t => t.qn === 5);
      e !== -1 && this.Ln.splice(e, 1)
  }
}
const bh = ".";

function Ti(i, e) {
  if (!fi(i)) return "n/a";
  if (!Bs(e)) throw new TypeError("invalid length");
  if (e < 0 || e > 16) throw new TypeError("invalid length");
  return e === 0 ? i.toString() : ("0000000000000000" + i.toString()).slice(-e)
}
class Ea {
  constructor(e, t) {
      if (t || (t = 1), fi(e) && Bs(e) || (e = 100), e < 0) throw new TypeError("invalid base");
      this.Li = e, this.rs = t, this.hs()
  }
  format(e) {
      const t = e < 0 ? "\u2212" : "";
      return e = Math.abs(e), t + this.ls(e)
  }
  hs() {
      if (this.os = 0, this.Li > 0 && this.rs > 0) {
          let e = this.Li;
          for (; e > 1;) e /= 10, this.os++
      }
  }
  ls(e) {
      const t = this.Li / this.rs;
      let n = Math.floor(e),
          s = "";
      const r = this.os !== void 0 ? this.os : NaN;
      if (t > 1) {
          let a = +(Math.round(e * t) - n * t).toFixed(this.os);
          a >= t && (a -= t, n += 1), s = bh + Ti(+a.toFixed(this.os) * this.rs, r)
      } else n = Math.round(n * t) / t, r > 0 && (s = bh + Ti(0, r));
      return n.toFixed(0) + s
  }
}
class Wp extends Ea {
  constructor(e = 100) {
      super(e)
  }
  format(e) {
      return `${super.format(e)}%`
  }
}
class HS {
  constructor(e) {
      this._s = e
  }
  format(e) {
      let t = "";
      return e < 0 && (t = "-", e = -e), e < 995 ? t + this.us(e) : e < 999995 ? t + this.us(e / 1e3) + "K" : e < 999999995 ? (e = 1e3 * Math.round(e / 1e3), t + this.us(e / 1e6) + "M") : (e = 1e6 * Math.round(e / 1e6), t + this.us(e / 1e9) + "B")
  }
  us(e) {
      let t;
      const n = Math.pow(10, this._s);
      return t = (e = Math.round(e * n) / n) >= 1e-15 && e < 1 ? e.toFixed(this._s).replace(/\.?0+$/, "") : String(e), t.replace(/(\.[1-9]*)0+$/, (s, r) => r)
  }
}

function Up(i, e, t, n, s, r, a) {
  if (e.length === 0 || n.from >= e.length || n.to <= 0) return;
  const {
      context: l,
      horizontalPixelRatio: o,
      verticalPixelRatio: u
  } = i, c = e[n.from];
  let h = r(i, c),
      d = c;
  if (n.to - n.from < 2) {
      const f = s / 2;
      l.beginPath();
      const p = {
              nt: c.nt - f,
              st: c.st
          },
          g = {
              nt: c.nt + f,
              st: c.st
          };
      l.moveTo(p.nt * o, p.st * u), l.lineTo(g.nt * o, g.st * u), a(i, h, p, g)
  } else {
      const f = (g, w) => {
          a(i, h, d, w), l.beginPath(), h = g, d = w
      };
      let p = d;
      l.beginPath(), l.moveTo(c.nt * o, c.st * u);
      for (let g = n.from + 1; g < n.to; ++g) {
          p = e[g];
          const w = r(i, p);
          switch (t) {
              case 0:
                  l.lineTo(p.nt * o, p.st * u);
                  break;
              case 1:
                  l.lineTo(p.nt * o, e[g - 1].st * u), w !== h && (f(w, p), l.lineTo(p.nt * o, e[g - 1].st * u)), l.lineTo(p.nt * o, p.st * u);
                  break;
              case 2: {
                  const [y, b] = qS(e, g - 1, g);
                  l.bezierCurveTo(y.nt * o, y.st * u, b.nt * o, b.st * u, p.nt * o, p.st * u);
                  break
              }
          }
          t !== 1 && w !== h && (f(w, p), l.moveTo(p.nt * o, p.st * u))
      }(d !== p || d === p && t === 1) && a(i, h, d, p)
  }
}
const wh = 6;

function Tl(i, e) {
  return {
      nt: i.nt - e.nt,
      st: i.st - e.st
  }
}

function kh(i, e) {
  return {
      nt: i.nt / e,
      st: i.st / e
  }
}

function qS(i, e, t) {
  const n = Math.max(0, e - 1),
      s = Math.min(i.length - 1, t + 1);
  var r, a;
  return [(r = i[e], a = kh(Tl(i[t], i[n]), wh), {
      nt: r.nt + a.nt,
      st: r.st + a.st
  }), Tl(i[t], kh(Tl(i[s], i[e]), wh))]
}

function GS(i, e, t, n, s) {
  const {
      context: r,
      horizontalPixelRatio: a,
      verticalPixelRatio: l
  } = e;
  r.lineTo(s.nt * a, i * l), r.lineTo(n.nt * a, i * l), r.closePath(), r.fillStyle = t, r.fill()
}
class jp extends ri {
  constructor() {
      super(...arguments), this.G = null
  }
  J(e) {
      this.G = e
  }
  K(e) {
      var t;
      if (this.G === null) return;
      const {
          it: n,
          tt: s,
          cs: r,
          et: a,
          Nt: l,
          ds: o
      } = this.G, u = (t = this.G.fs) !== null && t !== void 0 ? t : this.G.vs ? 0 : e.mediaSize.height;
      if (s === null) return;
      const c = e.context;
      c.lineCap = "butt", c.lineJoin = "round", c.lineWidth = a, dn(c, l), c.lineWidth = 1, Up(e, n, o, s, r, this.ps.bind(this), GS.bind(null, u))
  }
}

function bo(i, e, t) {
  return Math.min(Math.max(i, e), t)
}

function hr(i, e, t) {
  return e - i <= t
}

function Hp(i) {
  const e = Math.ceil(i);
  return e % 2 == 0 ? e - 1 : e
}
class Tu {
  bs(e, t) {
      const n = this.ws,
          {
              gs: s,
              Ms: r,
              xs: a,
              Ss: l,
              ks: o,
              fs: u
          } = t;
      if (this.ys === void 0 || n === void 0 || n.gs !== s || n.Ms !== r || n.xs !== a || n.Ss !== l || n.fs !== u || n.ks !== o) {
          const c = e.context.createLinearGradient(0, 0, 0, o);
          if (c.addColorStop(0, s), u != null) {
              const h = bo(u * e.verticalPixelRatio / o, 0, 1);
              c.addColorStop(h, r), c.addColorStop(h, a)
          }
          c.addColorStop(1, l), this.ys = c, this.ws = t
      }
      return this.ys
  }
}
class KS extends jp {
  constructor() {
      super(...arguments), this.Cs = new Tu
  }
  ps(e, t) {
      return this.Cs.bs(e, {
          gs: t.Ts,
          Ms: "",
          xs: "",
          Ss: t.Ps,
          ks: e.bitmapSize.height
      })
  }
}

function XS(i, e) {
  const t = i.context;
  t.strokeStyle = e, t.stroke()
}
class qp extends ri {
  constructor() {
      super(...arguments), this.G = null
  }
  J(e) {
      this.G = e
  }
  K(e) {
      if (this.G === null) return;
      const {
          it: t,
          tt: n,
          cs: s,
          ds: r,
          et: a,
          Nt: l,
          Rs: o
      } = this.G;
      if (n === null) return;
      const u = e.context;
      u.lineCap = "butt", u.lineWidth = a * e.verticalPixelRatio, dn(u, l), u.lineJoin = "round";
      const c = this.Ds.bind(this);
      r !== void 0 && Up(e, t, r, n, s, c, XS), o && function(h, d, f, p, g) {
          const {
              horizontalPixelRatio: w,
              verticalPixelRatio: y,
              context: b
          } = h;
          let x = null;
          const k = Math.max(1, Math.floor(w)) % 2 / 2,
              S = f * y + k;
          for (let B = p.to - 1; B >= p.from; --B) {
              const D = d[B];
              if (D) {
                  const P = g(h, D);
                  P !== x && (b.beginPath(), x !== null && b.fill(), b.fillStyle = P, x = P);
                  const I = Math.round(D.nt * w) + k,
                      $ = D.st * y;
                  b.moveTo(I, $), b.arc(I, $, S, 0, 2 * Math.PI)
              }
          }
          b.fill()
      }(e, t, o, n, c)
  }
}
class Gp extends qp {
  Ds(e, t) {
      return t.lt
  }
}

function Kp(i, e, t, n, s = 0, r = e.length) {
  let a = r - s;
  for (; 0 < a;) {
      const l = a >> 1,
          o = s + l;
      n(e[o], t) === i ? (s = o + 1, a -= l + 1) : a = l
  }
  return s
}
const Xs = Kp.bind(null, !0),
  Xp = Kp.bind(null, !1);

function JS(i, e) {
  return i.ot < e
}

function YS(i, e) {
  return e < i.ot
}

function Jp(i, e, t) {
  const n = e.Vs(),
      s = e.ui(),
      r = Xs(i, n, JS),
      a = Xp(i, s, YS);
  if (!t) return {
      from: r,
      to: a
  };
  let l = r,
      o = a;
  return r > 0 && r < i.length && i[r].ot >= n && (l = r - 1), a > 0 && a < i.length && i[a - 1].ot <= s && (o = a + 1), {
      from: l,
      to: o
  }
}
class Su {
  constructor(e, t, n) {
      this.Os = !0, this.Bs = !0, this.As = !0, this.Is = [], this.zs = null, this.Ls = e, this.Es = t, this.Ns = n
  }
  bt(e) {
      this.Os = !0, e === "data" && (this.Bs = !0), e === "options" && (this.As = !0)
  }
  gt() {
      return this.Ls.yt() ? (this.Fs(), this.zs === null ? null : this.Ws) : null
  }
  js() {
      this.Is = this.Is.map(e => Object.assign(Object.assign({}, e), this.Ls.$s().Hs(e.ot)))
  }
  Us() {
      this.zs = null
  }
  Fs() {
      this.Bs && (this.qs(), this.Bs = !1), this.As && (this.js(), this.As = !1), this.Os && (this.Ys(), this.Os = !1)
  }
  Ys() {
      const e = this.Ls.Dt(),
          t = this.Es.St();
      if (this.Us(), t.Ni() || e.Ni()) return;
      const n = t.Zs();
      if (n === null || this.Ls.In().Xs() === 0) return;
      const s = this.Ls.Ct();
      s !== null && (this.zs = Jp(this.Is, n, this.Ns), this.Ks(e, t, s.Vt), this.Gs())
  }
}
class Ca extends Su {
  constructor(e, t) {
      super(e, t, !0)
  }
  Ks(e, t, n) {
      t.Js(this.Is, Os(this.zs)), e.Qs(this.Is, n, Os(this.zs))
  }
  te(e, t) {
      return {
          ot: e,
          _t: t,
          nt: NaN,
          st: NaN
      }
  }
  qs() {
      const e = this.Ls.$s();
      this.Is = this.Ls.In().ie().map(t => {
          const n = t.Vt[3];
          return this.ne(t.se, n, e)
      })
  }
}
class QS extends Ca {
  constructor(e, t) {
      super(e, t), this.Ws = new _u, this.ee = new KS, this.re = new Gp, this.Ws.Z([this.ee, this.re])
  }
  ne(e, t, n) {
      return Object.assign(Object.assign({}, this.te(e, t)), n.Hs(e))
  }
  Gs() {
      const e = this.Ls.W();
      this.ee.J({
          ds: e.lineType,
          it: this.Is,
          Nt: e.lineStyle,
          et: e.lineWidth,
          fs: null,
          vs: e.invertFilledArea,
          tt: this.zs,
          cs: this.Es.St().he()
      }), this.re.J({
          ds: e.lineVisible ? e.lineType : void 0,
          it: this.Is,
          Nt: e.lineStyle,
          et: e.lineWidth,
          tt: this.zs,
          cs: this.Es.St().he(),
          Rs: e.pointMarkersVisible ? e.pointMarkersRadius || e.lineWidth / 2 + 2 : void 0
      })
  }
}
class ZS extends ri {
  constructor() {
      super(...arguments), this.zt = null, this.le = 0, this.ae = 0
  }
  J(e) {
      this.zt = e
  }
  K({
      context: e,
      horizontalPixelRatio: t,
      verticalPixelRatio: n
  }) {
      if (this.zt === null || this.zt.In.length === 0 || this.zt.tt === null) return;
      this.le = this.oe(t), this.le >= 2 && Math.max(1, Math.floor(t)) % 2 != this.le % 2 && this.le--, this.ae = this.zt._e ? Math.min(this.le, Math.floor(t)) : this.le;
      let s = null;
      const r = this.ae <= this.le && this.zt.he >= Math.floor(1.5 * t);
      for (let a = this.zt.tt.from; a < this.zt.tt.to; ++a) {
          const l = this.zt.In[a];
          s !== l.ue && (e.fillStyle = l.ue, s = l.ue);
          const o = Math.floor(.5 * this.ae),
              u = Math.round(l.nt * t),
              c = u - o,
              h = this.ae,
              d = c + h - 1,
              f = Math.min(l.ce, l.de),
              p = Math.max(l.ce, l.de),
              g = Math.round(f * n) - o,
              w = Math.round(p * n) + o,
              y = Math.max(w - g, this.ae);
          e.fillRect(c, g, h, y);
          const b = Math.ceil(1.5 * this.le);
          if (r) {
              if (this.zt.fe) {
                  const B = u - b;
                  let D = Math.max(g, Math.round(l.ve * n) - o),
                      P = D + h - 1;
                  P > g + y - 1 && (P = g + y - 1, D = P - h + 1), e.fillRect(B, D, c - B, P - D + 1)
              }
              const x = u + b;
              let k = Math.max(g, Math.round(l.pe * n) - o),
                  S = k + h - 1;
              S > g + y - 1 && (S = g + y - 1, k = S - h + 1), e.fillRect(d + 1, k, x - d, S - k + 1)
          }
      }
  }
  oe(e) {
      const t = Math.floor(e);
      return Math.max(t, Math.floor(function(n, s) {
          return Math.floor(.3 * n * s)
      }(Q(this.zt).he, e)))
  }
}
class Yp extends Su {
  constructor(e, t) {
      super(e, t, !1)
  }
  Ks(e, t, n) {
      t.Js(this.Is, Os(this.zs)), e.me(this.Is, n, Os(this.zs))
  }
  be(e, t, n) {
      return {
          ot: e,
          we: t.Vt[0],
          ge: t.Vt[1],
          Me: t.Vt[2],
          xe: t.Vt[3],
          nt: NaN,
          ve: NaN,
          ce: NaN,
          de: NaN,
          pe: NaN
      }
  }
  qs() {
      const e = this.Ls.$s();
      this.Is = this.Ls.In().ie().map(t => this.ne(t.se, t, e))
  }
}
class e2 extends Yp {
  constructor() {
      super(...arguments), this.Ws = new ZS
  }
  ne(e, t, n) {
      return Object.assign(Object.assign({}, this.be(e, t, n)), n.Hs(e))
  }
  Gs() {
      const e = this.Ls.W();
      this.Ws.J({
          In: this.Is,
          he: this.Es.St().he(),
          fe: e.openVisible,
          _e: e.thinBars,
          tt: this.zs
      })
  }
}
class t2 extends jp {
  constructor() {
      super(...arguments), this.Cs = new Tu
  }
  ps(e, t) {
      const n = this.G;
      return this.Cs.bs(e, {
          gs: t.Se,
          Ms: t.ke,
          xs: t.ye,
          Ss: t.Ce,
          ks: e.bitmapSize.height,
          fs: n.fs
      })
  }
}
class i2 extends qp {
  constructor() {
      super(...arguments), this.Te = new Tu
  }
  Ds(e, t) {
      const n = this.G;
      return this.Te.bs(e, {
          gs: t.Pe,
          Ms: t.Pe,
          xs: t.Re,
          Ss: t.Re,
          ks: e.bitmapSize.height,
          fs: n.fs
      })
  }
}
class n2 extends Ca {
  constructor(e, t) {
      super(e, t), this.Ws = new _u, this.De = new t2, this.Ve = new i2, this.Ws.Z([this.De, this.Ve])
  }
  ne(e, t, n) {
      return Object.assign(Object.assign({}, this.te(e, t)), n.Hs(e))
  }
  Gs() {
      const e = this.Ls.Ct();
      if (e === null) return;
      const t = this.Ls.W(),
          n = this.Ls.Dt().Rt(t.baseValue.price, e.Vt),
          s = this.Es.St().he();
      this.De.J({
          it: this.Is,
          et: t.lineWidth,
          Nt: t.lineStyle,
          ds: t.lineType,
          fs: n,
          vs: !1,
          tt: this.zs,
          cs: s
      }), this.Ve.J({
          it: this.Is,
          et: t.lineWidth,
          Nt: t.lineStyle,
          ds: t.lineVisible ? t.lineType : void 0,
          Rs: t.pointMarkersVisible ? t.pointMarkersRadius || t.lineWidth / 2 + 2 : void 0,
          fs: n,
          tt: this.zs,
          cs: s
      })
  }
}
class s2 extends ri {
  constructor() {
      super(...arguments), this.zt = null, this.le = 0
  }
  J(e) {
      this.zt = e
  }
  K(e) {
      if (this.zt === null || this.zt.In.length === 0 || this.zt.tt === null) return;
      const {
          horizontalPixelRatio: t
      } = e;
      this.le = function(r, a) {
          if (r >= 2.5 && r <= 4) return Math.floor(3 * a);
          const l = 1 - .2 * Math.atan(Math.max(4, r) - 4) / (.5 * Math.PI),
              o = Math.floor(r * l * a),
              u = Math.floor(r * a),
              c = Math.min(o, u);
          return Math.max(Math.floor(a), c)
      }(this.zt.he, t), this.le >= 2 && Math.floor(t) % 2 != this.le % 2 && this.le--;
      const n = this.zt.In;
      this.zt.Oe && this.Be(e, n, this.zt.tt), this.zt._i && this.Ae(e, n, this.zt.tt);
      const s = this.Ie(t);
      (!this.zt._i || this.le > 2 * s) && this.ze(e, n, this.zt.tt)
  }
  Be(e, t, n) {
      if (this.zt === null) return;
      const {
          context: s,
          horizontalPixelRatio: r,
          verticalPixelRatio: a
      } = e;
      let l = "",
          o = Math.min(Math.floor(r), Math.floor(this.zt.he * r));
      o = Math.max(Math.floor(r), Math.min(o, this.le));
      const u = Math.floor(.5 * o);
      let c = null;
      for (let h = n.from; h < n.to; h++) {
          const d = t[h];
          d.Le !== l && (s.fillStyle = d.Le, l = d.Le);
          const f = Math.round(Math.min(d.ve, d.pe) * a),
              p = Math.round(Math.max(d.ve, d.pe) * a),
              g = Math.round(d.ce * a),
              w = Math.round(d.de * a);
          let y = Math.round(r * d.nt) - u;
          const b = y + o - 1;
          c !== null && (y = Math.max(c + 1, y), y = Math.min(y, b));
          const x = b - y + 1;
          s.fillRect(y, g, x, f - g), s.fillRect(y, p + 1, x, w - p), c = b
      }
  }
  Ie(e) {
      let t = Math.floor(1 * e);
      this.le <= 2 * t && (t = Math.floor(.5 * (this.le - 1)));
      const n = Math.max(Math.floor(e), t);
      return this.le <= 2 * n ? Math.max(Math.floor(e), Math.floor(1 * e)) : n
  }
  Ae(e, t, n) {
      if (this.zt === null) return;
      const {
          context: s,
          horizontalPixelRatio: r,
          verticalPixelRatio: a
      } = e;
      let l = "";
      const o = this.Ie(r);
      let u = null;
      for (let c = n.from; c < n.to; c++) {
          const h = t[c];
          h.Ee !== l && (s.fillStyle = h.Ee, l = h.Ee);
          let d = Math.round(h.nt * r) - Math.floor(.5 * this.le);
          const f = d + this.le - 1,
              p = Math.round(Math.min(h.ve, h.pe) * a),
              g = Math.round(Math.max(h.ve, h.pe) * a);
          if (u !== null && (d = Math.max(u + 1, d), d = Math.min(d, f)), this.zt.he * r > 2 * o) VS(s, d, p, f - d + 1, g - p + 1, o);
          else {
              const w = f - d + 1;
              s.fillRect(d, p, w, g - p + 1)
          }
          u = f
      }
  }
  ze(e, t, n) {
      if (this.zt === null) return;
      const {
          context: s,
          horizontalPixelRatio: r,
          verticalPixelRatio: a
      } = e;
      let l = "";
      const o = this.Ie(r);
      for (let u = n.from; u < n.to; u++) {
          const c = t[u];
          let h = Math.round(Math.min(c.ve, c.pe) * a),
              d = Math.round(Math.max(c.ve, c.pe) * a),
              f = Math.round(c.nt * r) - Math.floor(.5 * this.le),
              p = f + this.le - 1;
          if (c.ue !== l) {
              const g = c.ue;
              s.fillStyle = g, l = g
          }
          this.zt._i && (f += o, h += o, p -= o, d -= o), h > d || s.fillRect(f, h, p - f + 1, d - h + 1)
      }
  }
}
class r2 extends Yp {
  constructor() {
      super(...arguments), this.Ws = new s2
  }
  ne(e, t, n) {
      return Object.assign(Object.assign({}, this.be(e, t, n)), n.Hs(e))
  }
  Gs() {
      const e = this.Ls.W();
      this.Ws.J({
          In: this.Is,
          he: this.Es.St().he(),
          Oe: e.wickVisible,
          _i: e.borderVisible,
          tt: this.zs
      })
  }
}
class a2 {
  constructor(e, t) {
      this.Ne = e, this.Li = t
  }
  X(e, t, n) {
      this.Ne.draw(e, this.Li, t, n)
  }
}
class Sl extends Su {
  constructor(e, t, n) {
      super(e, t, !1), this.wn = n, this.Ws = new a2(this.wn.renderer(), s => {
          const r = e.Ct();
          return r === null ? null : e.Dt().Rt(s, r.Vt)
      })
  }
  Fe(e) {
      return this.wn.priceValueBuilder(e)
  }
  We(e) {
      return this.wn.isWhitespace(e)
  }
  qs() {
      const e = this.Ls.$s();
      this.Is = this.Ls.In().ie().map(t => Object.assign(Object.assign({
          ot: t.se,
          nt: NaN
      }, e.Hs(t.se)), {
          je: t.He
      }))
  }
  Ks(e, t) {
      t.Js(this.Is, Os(this.zs))
  }
  Gs() {
      this.wn.update({
          bars: this.Is.map(l2),
          barSpacing: this.Es.St().he(),
          visibleRange: this.zs
      }, this.Ls.W())
  }
}

function l2(i) {
  return {
      x: i.nt,
      time: i.ot,
      originalData: i.je,
      barColor: i.ue
  }
}
class o2 extends ri {
  constructor() {
      super(...arguments), this.zt = null, this.$e = []
  }
  J(e) {
      this.zt = e, this.$e = []
  }
  K({
      context: e,
      horizontalPixelRatio: t,
      verticalPixelRatio: n
  }) {
      if (this.zt === null || this.zt.it.length === 0 || this.zt.tt === null) return;
      this.$e.length || this.Ue(t);
      const s = Math.max(1, Math.floor(n)),
          r = Math.round(this.zt.qe * n) - Math.floor(s / 2),
          a = r + s;
      for (let l = this.zt.tt.from; l < this.zt.tt.to; l++) {
          const o = this.zt.it[l],
              u = this.$e[l - this.zt.tt.from],
              c = Math.round(o.st * n);
          let h, d;
          e.fillStyle = o.ue, c <= r ? (h = c, d = a) : (h = r, d = c - Math.floor(s / 2) + s), e.fillRect(u.Vs, h, u.ui - u.Vs + 1, d - h)
      }
  }
  Ue(e) {
      if (this.zt === null || this.zt.it.length === 0 || this.zt.tt === null) return void(this.$e = []);
      const t = Math.ceil(this.zt.he * e) <= 1 ? 0 : Math.max(1, Math.floor(e)),
          n = Math.round(this.zt.he * e) - t;
      this.$e = new Array(this.zt.tt.to - this.zt.tt.from);
      for (let r = this.zt.tt.from; r < this.zt.tt.to; r++) {
          const a = this.zt.it[r],
              l = Math.round(a.nt * e);
          let o, u;
          if (n % 2) {
              const c = (n - 1) / 2;
              o = l - c, u = l + c
          } else {
              const c = n / 2;
              o = l - c, u = l + c - 1
          }
          this.$e[r - this.zt.tt.from] = {
              Vs: o,
              ui: u,
              Ye: l,
              Ze: a.nt * e,
              ot: a.ot
          }
      }
      for (let r = this.zt.tt.from + 1; r < this.zt.tt.to; r++) {
          const a = this.$e[r - this.zt.tt.from],
              l = this.$e[r - this.zt.tt.from - 1];
          a.ot === l.ot + 1 && a.Vs - l.ui !== t + 1 && (l.Ye > l.Ze ? l.ui = a.Vs - t - 1 : a.Vs = l.ui + t + 1)
      }
      let s = Math.ceil(this.zt.he * e);
      for (let r = this.zt.tt.from; r < this.zt.tt.to; r++) {
          const a = this.$e[r - this.zt.tt.from];
          a.ui < a.Vs && (a.ui = a.Vs);
          const l = a.ui - a.Vs + 1;
          s = Math.min(l, s)
      }
      if (t > 0 && s < 4)
          for (let r = this.zt.tt.from; r < this.zt.tt.to; r++) {
              const a = this.$e[r - this.zt.tt.from];
              a.ui - a.Vs + 1 > s && (a.Ye > a.Ze ? a.ui -= 1 : a.Vs += 1)
          }
  }
}
class u2 extends Ca {
  constructor() {
      super(...arguments), this.Ws = new o2
  }
  ne(e, t, n) {
      return Object.assign(Object.assign({}, this.te(e, t)), n.Hs(e))
  }
  Gs() {
      const e = {
          it: this.Is,
          he: this.Es.St().he(),
          tt: this.zs,
          qe: this.Ls.Dt().Rt(this.Ls.W().base, Q(this.Ls.Ct()).Vt)
      };
      this.Ws.J(e)
  }
}
class c2 extends Ca {
  constructor() {
      super(...arguments), this.Ws = new Gp
  }
  ne(e, t, n) {
      return Object.assign(Object.assign({}, this.te(e, t)), n.Hs(e))
  }
  Gs() {
      const e = this.Ls.W(),
          t = {
              it: this.Is,
              Nt: e.lineStyle,
              ds: e.lineVisible ? e.lineType : void 0,
              et: e.lineWidth,
              Rs: e.pointMarkersVisible ? e.pointMarkersRadius || e.lineWidth / 2 + 2 : void 0,
              tt: this.zs,
              cs: this.Es.St().he()
          };
      this.Ws.J(t)
  }
}
const h2 = /[2-9]/g;
class Ds {
  constructor(e = 50) {
      this.Xe = 0, this.Ke = 1, this.Ge = 1, this.Je = {}, this.Qe = new Map, this.tr = e
  }
  ir() {
      this.Xe = 0, this.Qe.clear(), this.Ke = 1, this.Ge = 1, this.Je = {}
  }
  xi(e, t, n) {
      return this.nr(e, t, n).width
  }
  Mi(e, t, n) {
      const s = this.nr(e, t, n);
      return ((s.actualBoundingBoxAscent || 0) - (s.actualBoundingBoxDescent || 0)) / 2
  }
  nr(e, t, n) {
      const s = n || h2,
          r = String(t).replace(s, "0");
      if (this.Qe.has(r)) return xt(this.Qe.get(r)).sr;
      if (this.Xe === this.tr) {
          const l = this.Je[this.Ge];
          delete this.Je[this.Ge], this.Qe.delete(l), this.Ge++, this.Xe--
      }
      e.save(), e.textBaseline = "middle";
      const a = e.measureText(r);
      return e.restore(), a.width === 0 && t.length || (this.Qe.set(r, {
          sr: a,
          er: this.Ke
      }), this.Je[this.Ke] = r, this.Xe++, this.Ke++), a
  }
}
class d2 {
  constructor(e) {
      this.rr = null, this.k = null, this.hr = "right", this.lr = e
  }
  ar(e, t, n) {
      this.rr = e, this.k = t, this.hr = n
  }
  X(e) {
      this.k !== null && this.rr !== null && this.rr.X(e, this.k, this.lr, this.hr)
  }
}
class Qp {
  constructor(e, t, n) {
      this._r = e, this.lr = new Ds(50), this.ur = t, this.F = n, this.j = -1, this.Wt = new d2(this.lr)
  }
  gt() {
      const e = this.F.cr(this.ur);
      if (e === null) return null;
      const t = e.dr(this.ur) ? e.vr() : this.ur.Dt();
      if (t === null) return null;
      const n = e.pr(t);
      if (n === "overlay") return null;
      const s = this.F.mr();
      return s.P !== this.j && (this.j = s.P, this.lr.ir()), this.Wt.ar(this._r.Ii(), s, n), this.Wt
  }
}
class f2 extends ri {
  constructor() {
      super(...arguments), this.zt = null
  }
  J(e) {
      this.zt = e
  }
  br(e, t) {
      var n;
      if (!(!((n = this.zt) === null || n === void 0) && n.yt)) return null;
      const {
          st: s,
          et: r,
          wr: a
      } = this.zt;
      return t >= s - r - 7 && t <= s + r + 7 ? {
          gr: this.zt,
          wr: a
      } : null
  }
  K({
      context: e,
      bitmapSize: t,
      horizontalPixelRatio: n,
      verticalPixelRatio: s
  }) {
      if (this.zt === null || this.zt.yt === !1) return;
      const r = Math.round(this.zt.st * s);
      r < 0 || r > t.height || (e.lineCap = "butt", e.strokeStyle = this.zt.V, e.lineWidth = Math.floor(this.zt.et * n), dn(e, this.zt.Nt), Dp(e, r, 0, t.width))
  }
}
class Eu {
  constructor(e) {
      this.Mr = {
          st: 0,
          V: "rgba(0, 0, 0, 0)",
          et: 1,
          Nt: 0,
          yt: !1
      }, this.Sr = new f2, this.ft = !0, this.Ls = e, this.Es = e.$t(), this.Sr.J(this.Mr)
  }
  bt() {
      this.ft = !0
  }
  gt() {
      return this.Ls.yt() ? (this.ft && (this.kr(), this.ft = !1), this.Sr) : null
  }
}
class p2 extends Eu {
  constructor(e) {
      super(e)
  }
  kr() {
      this.Mr.yt = !1;
      const e = this.Ls.Dt(),
          t = e.yr().yr;
      if (t !== 2 && t !== 3) return;
      const n = this.Ls.W();
      if (!n.baseLineVisible || !this.Ls.yt()) return;
      const s = this.Ls.Ct();
      s !== null && (this.Mr.yt = !0, this.Mr.st = e.Rt(s.Vt, s.Vt), this.Mr.V = n.baseLineColor, this.Mr.et = n.baseLineWidth, this.Mr.Nt = n.baseLineStyle)
  }
}
class m2 extends ri {
  constructor() {
      super(...arguments), this.zt = null
  }
  J(e) {
      this.zt = e
  }
  He() {
      return this.zt
  }
  K({
      context: e,
      horizontalPixelRatio: t,
      verticalPixelRatio: n
  }) {
      const s = this.zt;
      if (s === null) return;
      const r = Math.max(1, Math.floor(t)),
          a = r % 2 / 2,
          l = Math.round(s.Ze.x * t) + a,
          o = s.Ze.y * n;
      e.fillStyle = s.Cr, e.beginPath();
      const u = Math.max(2, 1.5 * s.Tr) * t;
      e.arc(l, o, u, 0, 2 * Math.PI, !1), e.fill(), e.fillStyle = s.Pr, e.beginPath(), e.arc(l, o, s.ht * t, 0, 2 * Math.PI, !1), e.fill(), e.lineWidth = r, e.strokeStyle = s.Rr, e.beginPath(), e.arc(l, o, s.ht * t + r / 2, 0, 2 * Math.PI, !1), e.stroke()
  }
}
const g2 = [{
  Dr: 0,
  Vr: .25,
  Or: 4,
  Br: 10,
  Ar: .25,
  Ir: 0,
  zr: .4,
  Lr: .8
}, {
  Dr: .25,
  Vr: .525,
  Or: 10,
  Br: 14,
  Ar: 0,
  Ir: 0,
  zr: .8,
  Lr: 0
}, {
  Dr: .525,
  Vr: 1,
  Or: 14,
  Br: 14,
  Ar: 0,
  Ir: 0,
  zr: 0,
  Lr: 0
}];

function _h(i, e, t, n) {
  return function(s, r) {
      if (s === "transparent") return s;
      const a = Rs(s),
          l = a[3];
      return `rgba(${a[0]}, ${a[1]}, ${a[2]}, ${r*l})`
  }(i, t + (n - t) * e)
}

function xh(i, e) {
  const t = i % 2600 / 2600;
  let n;
  for (const o of g2)
      if (t >= o.Dr && t <= o.Vr) {
          n = o;
          break
      } Hi(n !== void 0, "Last price animation internal logic error");
  const s = (t - n.Dr) / (n.Vr - n.Dr);
  return {
      Pr: _h(e, s, n.Ar, n.Ir),
      Rr: _h(e, s, n.zr, n.Lr),
      ht: (r = s, a = n.Or, l = n.Br, a + (l - a) * r)
  };
  var r, a, l
}
class y2 {
  constructor(e) {
      this.Wt = new m2, this.ft = !0, this.Er = !0, this.Nr = performance.now(), this.Fr = this.Nr - 1, this.Wr = e
  }
  jr() {
      this.Fr = this.Nr - 1, this.bt()
  }
  Hr() {
      if (this.bt(), this.Wr.W().lastPriceAnimation === 2) {
          const e = performance.now(),
              t = this.Fr - e;
          if (t > 0) return void(t < 650 && (this.Fr += 2600));
          this.Nr = e, this.Fr = e + 2600
      }
  }
  bt() {
      this.ft = !0
  }
  $r() {
      this.Er = !0
  }
  yt() {
      return this.Wr.W().lastPriceAnimation !== 0
  }
  Ur() {
      switch (this.Wr.W().lastPriceAnimation) {
          case 0:
              return !1;
          case 1:
              return !0;
          case 2:
              return performance.now() <= this.Fr
      }
  }
  gt() {
      return this.ft ? (this.Mt(), this.ft = !1, this.Er = !1) : this.Er && (this.qr(), this.Er = !1), this.Wt
  }
  Mt() {
      this.Wt.J(null);
      const e = this.Wr.$t().St(),
          t = e.Zs(),
          n = this.Wr.Ct();
      if (t === null || n === null) return;
      const s = this.Wr.Yr(!0);
      if (s.Zr || !t.Xr(s.se)) return;
      const r = {
              x: e.It(s.se),
              y: this.Wr.Dt().Rt(s._t, n.Vt)
          },
          a = s.V,
          l = this.Wr.W().lineWidth,
          o = xh(this.Kr(), a);
      this.Wt.J({
          Cr: a,
          Tr: l,
          Pr: o.Pr,
          Rr: o.Rr,
          ht: o.ht,
          Ze: r
      })
  }
  qr() {
      const e = this.Wt.He();
      if (e !== null) {
          const t = xh(this.Kr(), e.Cr);
          e.Pr = t.Pr, e.Rr = t.Rr, e.ht = t.ht
      }
  }
  Kr() {
      return this.Ur() ? performance.now() - this.Nr : 2599
  }
}

function vs(i, e) {
  return Hp(Math.min(Math.max(i, 12), 30) * e)
}

function Fs(i, e) {
  switch (i) {
      case "arrowDown":
      case "arrowUp":
          return vs(e, 1);
      case "circle":
          return vs(e, .8);
      case "square":
          return vs(e, .7)
  }
}

function Zp(i) {
  return function(e) {
      const t = Math.ceil(e);
      return t % 2 != 0 ? t - 1 : t
  }(vs(i, 1))
}

function Th(i) {
  return Math.max(vs(i, .1), 3)
}

function Sh(i, e, t) {
  return e ? i : t ? Math.ceil(i / 2) : 0
}

function em(i, e, t, n, s) {
  const r = Fs("square", t),
      a = (r - 1) / 2,
      l = i - a,
      o = e - a;
  return n >= l && n <= l + r && s >= o && s <= o + r
}

function Eh(i, e, t, n) {
  const s = (Fs("arrowUp", n) - 1) / 2 * t.Gr,
      r = (Hp(n / 2) - 1) / 2 * t.Gr;
  e.beginPath(), i ? (e.moveTo(t.nt - s, t.st), e.lineTo(t.nt, t.st - s), e.lineTo(t.nt + s, t.st), e.lineTo(t.nt + r, t.st), e.lineTo(t.nt + r, t.st + s), e.lineTo(t.nt - r, t.st + s), e.lineTo(t.nt - r, t.st)) : (e.moveTo(t.nt - s, t.st), e.lineTo(t.nt, t.st + s), e.lineTo(t.nt + s, t.st), e.lineTo(t.nt + r, t.st), e.lineTo(t.nt + r, t.st - s), e.lineTo(t.nt - r, t.st - s), e.lineTo(t.nt - r, t.st)), e.fill()
}

function v2(i, e, t, n, s, r) {
  return em(e, t, n, s, r)
}
class b2 extends ri {
  constructor() {
      super(...arguments), this.zt = null, this.lr = new Ds, this.j = -1, this.H = "", this.Jr = ""
  }
  J(e) {
      this.zt = e
  }
  ar(e, t) {
      this.j === e && this.H === t || (this.j = e, this.H = t, this.Jr = qn(e, t), this.lr.ir())
  }
  br(e, t) {
      if (this.zt === null || this.zt.tt === null) return null;
      for (let n = this.zt.tt.from; n < this.zt.tt.to; n++) {
          const s = this.zt.it[n];
          if (k2(s, e, t)) return {
              gr: s.Qr,
              wr: s.wr
          }
      }
      return null
  }
  K({
      context: e,
      horizontalPixelRatio: t,
      verticalPixelRatio: n
  }, s, r) {
      if (this.zt !== null && this.zt.tt !== null) {
          e.textBaseline = "middle", e.font = this.Jr;
          for (let a = this.zt.tt.from; a < this.zt.tt.to; a++) {
              const l = this.zt.it[a];
              l.Kt !== void 0 && (l.Kt.Hi = this.lr.xi(e, l.Kt.th), l.Kt.At = this.j, l.Kt.nt = l.nt - l.Kt.Hi / 2), w2(l, e, t, n)
          }
      }
  }
}

function w2(i, e, t, n) {
  e.fillStyle = i.V, i.Kt !== void 0 && function(s, r, a, l, o, u) {
          s.save(), s.scale(o, u), s.fillText(r, a, l), s.restore()
      }(e, i.Kt.th, i.Kt.nt, i.Kt.st, t, n),
      function(s, r, a) {
          if (s.Xs !== 0) {
              switch (s.ih) {
                  case "arrowDown":
                      return void Eh(!1, r, a, s.Xs);
                  case "arrowUp":
                      return void Eh(!0, r, a, s.Xs);
                  case "circle":
                      return void
                      function(l, o, u) {
                          const c = (Fs("circle", u) - 1) / 2;
                          l.beginPath(), l.arc(o.nt, o.st, c * o.Gr, 0, 2 * Math.PI, !1), l.fill()
                      }(r, a, s.Xs);
                  case "square":
                      return void
                      function(l, o, u) {
                          const c = Fs("square", u),
                              h = (c - 1) * o.Gr / 2,
                              d = o.nt - h,
                              f = o.st - h;
                          l.fillRect(d, f, c * o.Gr, c * o.Gr)
                      }(r, a, s.Xs)
              }
              s.ih
          }
      }(i, e, function(s, r, a) {
          const l = Math.max(1, Math.floor(r)) % 2 / 2;
          return {
              nt: Math.round(s.nt * r) + l,
              st: s.st * a,
              Gr: r
          }
      }(i, t, n))
}

function k2(i, e, t) {
  return !(i.Kt === void 0 || ! function(n, s, r, a, l, o) {
      const u = a / 2;
      return l >= n && l <= n + r && o >= s - u && o <= s + u
  }(i.Kt.nt, i.Kt.st, i.Kt.Hi, i.Kt.At, e, t)) || function(n, s, r) {
      if (n.Xs === 0) return !1;
      switch (n.ih) {
          case "arrowDown":
          case "arrowUp":
              return v2(0, n.nt, n.st, n.Xs, s, r);
          case "circle":
              return function(a, l, o, u, c) {
                  const h = 2 + Fs("circle", o) / 2,
                      d = a - u,
                      f = l - c;
                  return Math.sqrt(d * d + f * f) <= h
              }(n.nt, n.st, n.Xs, s, r);
          case "square":
              return em(n.nt, n.st, n.Xs, s, r)
      }
  }(i, e, t)
}

function _2(i, e, t, n, s, r, a, l, o) {
  const u = fi(t) ? t : t.xe,
      c = fi(t) ? t : t.ge,
      h = fi(t) ? t : t.Me,
      d = fi(e.size) ? Math.max(e.size, 0) : 1,
      f = Zp(l.he()) * d,
      p = f / 2;
  switch (i.Xs = f, e.position) {
      case "inBar":
          return i.st = a.Rt(u, o), void(i.Kt !== void 0 && (i.Kt.st = i.st + p + r + .6 * s));
      case "aboveBar":
          return i.st = a.Rt(c, o) - p - n.nh, i.Kt !== void 0 && (i.Kt.st = i.st - p - .6 * s, n.nh += 1.2 * s), void(n.nh += f + r);
      case "belowBar":
          return i.st = a.Rt(h, o) + p + n.sh, i.Kt !== void 0 && (i.Kt.st = i.st + p + r + .6 * s, n.sh += 1.2 * s), void(n.sh += f + r)
  }
  e.position
}
class x2 {
  constructor(e, t) {
      this.ft = !0, this.eh = !0, this.rh = !0, this.hh = null, this.ah = null, this.Wt = new b2, this.Wr = e, this.$i = t, this.zt = {
          it: [],
          tt: null
      }
  }
  bt(e) {
      this.ft = !0, this.rh = !0, e === "data" && (this.eh = !0, this.ah = null)
  }
  gt(e) {
      if (!this.Wr.yt()) return null;
      this.ft && this.oh();
      const t = this.$i.W().layout;
      return this.Wt.ar(t.fontSize, t.fontFamily), this.Wt.J(this.zt), this.Wt
  }
  _h() {
      if (this.rh) {
          if (this.Wr.uh().length > 0) {
              const e = this.$i.St().he(),
                  t = Th(e),
                  n = 1.5 * Zp(e) + 2 * t,
                  s = this.dh();
              this.hh = {
                  above: Sh(n, s.aboveBar, s.inBar),
                  below: Sh(n, s.belowBar, s.inBar)
              }
          } else this.hh = null;
          this.rh = !1
      }
      return this.hh
  }
  dh() {
      return this.ah === null && (this.ah = this.Wr.uh().reduce((e, t) => (e[t.position] || (e[t.position] = !0), e), {
          inBar: !1,
          aboveBar: !1,
          belowBar: !1
      })), this.ah
  }
  oh() {
      const e = this.Wr.Dt(),
          t = this.$i.St(),
          n = this.Wr.uh();
      this.eh && (this.zt.it = n.map(c => ({
          ot: c.time,
          nt: 0,
          st: 0,
          Xs: 0,
          ih: c.shape,
          V: c.color,
          Qr: c.Qr,
          wr: c.id,
          Kt: void 0
      })), this.eh = !1);
      const s = this.$i.W().layout;
      this.zt.tt = null;
      const r = t.Zs();
      if (r === null) return;
      const a = this.Wr.Ct();
      if (a === null || this.zt.it.length === 0) return;
      let l = NaN;
      const o = Th(t.he()),
          u = {
              nh: o,
              sh: o
          };
      this.zt.tt = Jp(this.zt.it, r, !0);
      for (let c = this.zt.tt.from; c < this.zt.tt.to; c++) {
          const h = n[c];
          h.time !== l && (u.nh = o, u.sh = o, l = h.time);
          const d = this.zt.it[c];
          d.nt = t.It(h.time), h.text !== void 0 && h.text.length > 0 && (d.Kt = {
              th: h.text,
              nt: 0,
              st: 0,
              Hi: 0,
              At: 0
          });
          const f = this.Wr.fh(h.time);
          f !== null && _2(d, h, f, u, s.fontSize, o, e, t, a.Vt)
      }
      this.ft = !1
  }
}
class T2 extends Eu {
  constructor(e) {
      super(e)
  }
  kr() {
      const e = this.Mr;
      e.yt = !1;
      const t = this.Ls.W();
      if (!t.priceLineVisible || !this.Ls.yt()) return;
      const n = this.Ls.Yr(t.priceLineSource === 0);
      n.Zr || (e.yt = !0, e.st = n.ki, e.V = this.Ls.ph(n.V), e.et = t.priceLineWidth, e.Nt = t.priceLineStyle)
  }
}
class S2 extends Ta {
  constructor(e) {
      super(), this.jt = e
  }
  zi(e, t, n) {
      e.yt = !1, t.yt = !1;
      const s = this.jt;
      if (!s.yt()) return;
      const r = s.W(),
          a = r.lastValueVisible,
          l = s.mh() !== "",
          o = r.seriesLastValueMode === 0,
          u = s.Yr(!1);
      if (u.Zr) return;
      a && (e.Kt = this.bh(u, a, o), e.yt = e.Kt.length !== 0), (l || o) && (t.Kt = this.wh(u, a, l, o), t.yt = t.Kt.length > 0);
      const c = s.ph(u.V),
          h = _a(c);
      n.t = h.t, n.ki = u.ki, t.Ot = s.$t().Bt(u.ki / s.Dt().At()), e.Ot = c, e.V = h.i, t.V = h.i
  }
  wh(e, t, n, s) {
      let r = "";
      const a = this.jt.mh();
      return n && a.length !== 0 && (r += `${a} `), t && s && (r += this.jt.Dt().gh() ? e.Mh : e.xh), r.trim()
  }
  bh(e, t, n) {
      return t ? n ? this.jt.Dt().gh() ? e.xh : e.Mh : e.Kt : ""
  }
}

function Ch(i, e, t, n) {
  const s = Number.isFinite(e),
      r = Number.isFinite(t);
  return s && r ? i(e, t) : s || r ? s ? e : t : n
}
class Tt {
  constructor(e, t) {
      this.Sh = e, this.kh = t
  }
  yh(e) {
      return e !== null && this.Sh === e.Sh && this.kh === e.kh
  }
  Ch() {
      return new Tt(this.Sh, this.kh)
  }
  Th() {
      return this.Sh
  }
  Ph() {
      return this.kh
  }
  Rh() {
      return this.kh - this.Sh
  }
  Ni() {
      return this.kh === this.Sh || Number.isNaN(this.kh) || Number.isNaN(this.Sh)
  }
  ts(e) {
      return e === null ? this : new Tt(Ch(Math.min, this.Th(), e.Th(), -1 / 0), Ch(Math.max, this.Ph(), e.Ph(), 1 / 0))
  }
  Dh(e) {
      if (!fi(e) || this.kh - this.Sh === 0) return;
      const t = .5 * (this.kh + this.Sh);
      let n = this.kh - t,
          s = this.Sh - t;
      n *= e, s *= e, this.kh = t + n, this.Sh = t + s
  }
  Vh(e) {
      fi(e) && (this.kh += e, this.Sh += e)
  }
  Oh() {
      return {
          minValue: this.Sh,
          maxValue: this.kh
      }
  }
  static Bh(e) {
      return e === null ? null : new Tt(e.minValue, e.maxValue)
  }
}
class Qr {
  constructor(e, t) {
      this.Ah = e, this.Ih = t || null
  }
  zh() {
      return this.Ah
  }
  Lh() {
      return this.Ih
  }
  Oh() {
      return this.Ah === null ? null : {
          priceRange: this.Ah.Oh(),
          margins: this.Ih || void 0
      }
  }
  static Bh(e) {
      return e === null ? null : new Qr(Tt.Bh(e.priceRange), e.margins)
  }
}
class E2 extends Eu {
  constructor(e, t) {
      super(e), this.Eh = t
  }
  kr() {
      const e = this.Mr;
      e.yt = !1;
      const t = this.Eh.W();
      if (!this.Ls.yt() || !t.lineVisible) return;
      const n = this.Eh.Nh();
      n !== null && (e.yt = !0, e.st = n, e.V = t.color, e.et = t.lineWidth, e.Nt = t.lineStyle, e.wr = this.Eh.W().id)
  }
}
class C2 extends Ta {
  constructor(e, t) {
      super(), this.Wr = e, this.Eh = t
  }
  zi(e, t, n) {
      e.yt = !1, t.yt = !1;
      const s = this.Eh.W(),
          r = s.axisLabelVisible,
          a = s.title !== "",
          l = this.Wr;
      if (!r || !l.yt()) return;
      const o = this.Eh.Nh();
      if (o === null) return;
      a && (t.Kt = s.title, t.yt = !0), t.Ot = l.$t().Bt(o / l.Dt().At()), e.Kt = this.Fh(s.price), e.yt = !0;
      const u = _a(s.axisLabelColor || s.color);
      n.t = u.t;
      const c = s.axisLabelTextColor || u.i;
      e.V = c, t.V = c, n.ki = o
  }
  Fh(e) {
      const t = this.Wr.Ct();
      return t === null ? "" : this.Wr.Dt().Fi(e, t.Vt)
  }
}
class $2 {
  constructor(e, t) {
      this.Wr = e, this.cn = t, this.Wh = new E2(e, this), this._r = new C2(e, this), this.jh = new Qp(this._r, e, e.$t())
  }
  Hh(e) {
      ni(this.cn, e), this.bt(), this.Wr.$t().$h()
  }
  W() {
      return this.cn
  }
  Uh() {
      return this.Wh
  }
  qh() {
      return this.jh
  }
  Yh() {
      return this._r
  }
  bt() {
      this.Wh.bt(), this._r.bt()
  }
  Nh() {
      const e = this.Wr,
          t = e.Dt();
      if (e.$t().St().Ni() || t.Ni()) return null;
      const n = e.Ct();
      return n === null ? null : t.Rt(this.cn.price, n.Vt)
  }
}
class L2 extends xu {
  constructor(e) {
      super(), this.$i = e
  }
  $t() {
      return this.$i
  }
}
const P2 = {
  Bar: (i, e, t, n) => {
      var s;
      const r = e.upColor,
          a = e.downColor,
          l = Q(i(t, n)),
          o = En(l.Vt[0]) <= En(l.Vt[3]);
      return {
          ue: (s = l.V) !== null && s !== void 0 ? s : o ? r : a
      }
  },
  Candlestick: (i, e, t, n) => {
      var s, r, a;
      const l = e.upColor,
          o = e.downColor,
          u = e.borderUpColor,
          c = e.borderDownColor,
          h = e.wickUpColor,
          d = e.wickDownColor,
          f = Q(i(t, n)),
          p = En(f.Vt[0]) <= En(f.Vt[3]);
      return {
          ue: (s = f.V) !== null && s !== void 0 ? s : p ? l : o,
          Ee: (r = f.Ot) !== null && r !== void 0 ? r : p ? u : c,
          Le: (a = f.Zh) !== null && a !== void 0 ? a : p ? h : d
      }
  },
  Custom: (i, e, t, n) => {
      var s;
      return {
          ue: (s = Q(i(t, n)).V) !== null && s !== void 0 ? s : e.color
      }
  },
  Area: (i, e, t, n) => {
      var s, r, a, l;
      const o = Q(i(t, n));
      return {
          ue: (s = o.lt) !== null && s !== void 0 ? s : e.lineColor,
          lt: (r = o.lt) !== null && r !== void 0 ? r : e.lineColor,
          Ts: (a = o.Ts) !== null && a !== void 0 ? a : e.topColor,
          Ps: (l = o.Ps) !== null && l !== void 0 ? l : e.bottomColor
      }
  },
  Baseline: (i, e, t, n) => {
      var s, r, a, l, o, u;
      const c = Q(i(t, n));
      return {
          ue: c.Vt[3] >= e.baseValue.price ? e.topLineColor : e.bottomLineColor,
          Pe: (s = c.Pe) !== null && s !== void 0 ? s : e.topLineColor,
          Re: (r = c.Re) !== null && r !== void 0 ? r : e.bottomLineColor,
          Se: (a = c.Se) !== null && a !== void 0 ? a : e.topFillColor1,
          ke: (l = c.ke) !== null && l !== void 0 ? l : e.topFillColor2,
          ye: (o = c.ye) !== null && o !== void 0 ? o : e.bottomFillColor1,
          Ce: (u = c.Ce) !== null && u !== void 0 ? u : e.bottomFillColor2
      }
  },
  Line: (i, e, t, n) => {
      var s, r;
      const a = Q(i(t, n));
      return {
          ue: (s = a.V) !== null && s !== void 0 ? s : e.color,
          lt: (r = a.V) !== null && r !== void 0 ? r : e.color
      }
  },
  Histogram: (i, e, t, n) => {
      var s;
      return {
          ue: (s = Q(i(t, n)).V) !== null && s !== void 0 ? s : e.color
      }
  }
};
class I2 {
  constructor(e) {
      this.Xh = (t, n) => n !== void 0 ? n.Vt : this.Wr.In().Kh(t), this.Wr = e, this.Gh = P2[e.Jh()]
  }
  Hs(e, t) {
      return this.Gh(this.Xh, this.Wr.W(), e, t)
  }
}
var $h;
(function(i) {
  i[i.NearestLeft = -1] = "NearestLeft", i[i.None = 0] = "None", i[i.NearestRight = 1] = "NearestRight"
})($h || ($h = {}));
const Ii = 30;
class N2 {
  constructor() {
      this.Qh = [], this.tl = new Map, this.il = new Map
  }
  nl() {
      return this.Xs() > 0 ? this.Qh[this.Qh.length - 1] : null
  }
  sl() {
      return this.Xs() > 0 ? this.el(0) : null
  }
  An() {
      return this.Xs() > 0 ? this.el(this.Qh.length - 1) : null
  }
  Xs() {
      return this.Qh.length
  }
  Ni() {
      return this.Xs() === 0
  }
  Xr(e) {
      return this.rl(e, 0) !== null
  }
  Kh(e) {
      return this.hl(e)
  }
  hl(e, t = 0) {
      const n = this.rl(e, t);
      return n === null ? null : Object.assign(Object.assign({}, this.ll(n)), {
          se: this.el(n)
      })
  }
  ie() {
      return this.Qh
  }
  al(e, t, n) {
      if (this.Ni()) return null;
      let s = null;
      for (const r of n) s = dr(s, this.ol(e, t, r));
      return s
  }
  J(e) {
      this.il.clear(), this.tl.clear(), this.Qh = e
  }
  el(e) {
      return this.Qh[e].se
  }
  ll(e) {
      return this.Qh[e]
  }
  rl(e, t) {
      const n = this._l(e);
      if (n === null && t !== 0) switch (t) {
          case -1:
              return this.ul(e);
          case 1:
              return this.cl(e);
          default:
              throw new TypeError("Unknown search mode")
      }
      return n
  }
  ul(e) {
      let t = this.dl(e);
      return t > 0 && (t -= 1), t !== this.Qh.length && this.el(t) < e ? t : null
  }
  cl(e) {
      const t = this.fl(e);
      return t !== this.Qh.length && e < this.el(t) ? t : null
  }
  _l(e) {
      const t = this.dl(e);
      return t === this.Qh.length || e < this.Qh[t].se ? null : t
  }
  dl(e) {
      return Xs(this.Qh, e, (t, n) => t.se < n)
  }
  fl(e) {
      return Xp(this.Qh, e, (t, n) => t.se > n)
  }
  vl(e, t, n) {
      let s = null;
      for (let r = e; r < t; r++) {
          const a = this.Qh[r].Vt[n];
          Number.isNaN(a) || (s === null ? s = {
              pl: a,
              ml: a
          } : (a < s.pl && (s.pl = a), a > s.ml && (s.ml = a)))
      }
      return s
  }
  ol(e, t, n) {
      if (this.Ni()) return null;
      let s = null;
      const r = Q(this.sl()),
          a = Q(this.An()),
          l = Math.max(e, r),
          o = Math.min(t, a),
          u = Math.ceil(l / Ii) * Ii,
          c = Math.max(u, Math.floor(o / Ii) * Ii);
      {
          const d = this.dl(l),
              f = this.fl(Math.min(o, u, t));
          s = dr(s, this.vl(d, f, n))
      }
      let h = this.tl.get(n);
      h === void 0 && (h = new Map, this.tl.set(n, h));
      for (let d = Math.max(u + 1, l); d < c; d += Ii) {
          const f = Math.floor(d / Ii);
          let p = h.get(f);
          if (p === void 0) {
              const g = this.dl(f * Ii),
                  w = this.fl((f + 1) * Ii - 1);
              p = this.vl(g, w, n), h.set(f, p)
          }
          s = dr(s, p)
      } {
          const d = this.dl(c),
              f = this.fl(o);
          s = dr(s, this.vl(d, f, n))
      }
      return s
  }
}

function dr(i, e) {
  return i === null ? e : e === null ? i : {
      pl: Math.min(i.pl, e.pl),
      ml: Math.max(i.ml, e.ml)
  }
}
class M2 {
  constructor(e) {
      this.bl = e
  }
  X(e, t, n) {
      this.bl.draw(e)
  }
  wl(e, t, n) {
      var s, r;
      (r = (s = this.bl).drawBackground) === null || r === void 0 || r.call(s, e)
  }
}
class El {
  constructor(e) {
      this.Qe = null, this.wn = e
  }
  gt() {
      var e;
      const t = this.wn.renderer();
      if (t === null) return null;
      if (((e = this.Qe) === null || e === void 0 ? void 0 : e.gl) === t) return this.Qe.Ml;
      const n = new M2(t);
      return this.Qe = {
          gl: t,
          Ml: n
      }, n
  }
  xl() {
      var e, t, n;
      return (n = (t = (e = this.wn).zOrder) === null || t === void 0 ? void 0 : t.call(e)) !== null && n !== void 0 ? n : "normal"
  }
}

function tm(i) {
  var e, t, n, s, r;
  return {
      Kt: i.text(),
      ki: i.coordinate(),
      Si: (e = i.fixedCoordinate) === null || e === void 0 ? void 0 : e.call(i),
      V: i.textColor(),
      t: i.backColor(),
      yt: (n = (t = i.visible) === null || t === void 0 ? void 0 : t.call(i)) === null || n === void 0 || n,
      hi: (r = (s = i.tickVisible) === null || s === void 0 ? void 0 : s.call(i)) === null || r === void 0 || r
  }
}
class R2 {
  constructor(e, t) {
      this.Wt = new zp, this.Sl = e, this.kl = t
  }
  gt() {
      return this.Wt.J(Object.assign({
          Hi: this.kl.Hi()
      }, tm(this.Sl))), this.Wt
  }
}
class B2 extends Ta {
  constructor(e, t) {
      super(), this.Sl = e, this.Li = t
  }
  zi(e, t, n) {
      const s = tm(this.Sl);
      n.t = s.t, e.V = s.V;
      const r = 2 / 12 * this.Li.P();
      n.wi = r, n.gi = r, n.ki = s.ki, n.Si = s.Si, e.Kt = s.Kt, e.yt = s.yt, e.hi = s.hi
  }
}
class O2 {
  constructor(e, t) {
      this.yl = null, this.Cl = null, this.Tl = null, this.Pl = null, this.Rl = null, this.Dl = e, this.Wr = t
  }
  Vl() {
      return this.Dl
  }
  Vn() {
      var e, t;
      (t = (e = this.Dl).updateAllViews) === null || t === void 0 || t.call(e)
  }
  Pn() {
      var e, t, n, s;
      const r = (n = (t = (e = this.Dl).paneViews) === null || t === void 0 ? void 0 : t.call(e)) !== null && n !== void 0 ? n : [];
      if (((s = this.yl) === null || s === void 0 ? void 0 : s.gl) === r) return this.yl.Ml;
      const a = r.map(l => new El(l));
      return this.yl = {
          gl: r,
          Ml: a
      }, a
  }
  Qi() {
      var e, t, n, s;
      const r = (n = (t = (e = this.Dl).timeAxisViews) === null || t === void 0 ? void 0 : t.call(e)) !== null && n !== void 0 ? n : [];
      if (((s = this.Cl) === null || s === void 0 ? void 0 : s.gl) === r) return this.Cl.Ml;
      const a = this.Wr.$t().St(),
          l = r.map(o => new R2(o, a));
      return this.Cl = {
          gl: r,
          Ml: l
      }, l
  }
  Rn() {
      var e, t, n, s;
      const r = (n = (t = (e = this.Dl).priceAxisViews) === null || t === void 0 ? void 0 : t.call(e)) !== null && n !== void 0 ? n : [];
      if (((s = this.Tl) === null || s === void 0 ? void 0 : s.gl) === r) return this.Tl.Ml;
      const a = this.Wr.Dt(),
          l = r.map(o => new B2(o, a));
      return this.Tl = {
          gl: r,
          Ml: l
      }, l
  }
  Ol() {
      var e, t, n, s;
      const r = (n = (t = (e = this.Dl).priceAxisPaneViews) === null || t === void 0 ? void 0 : t.call(e)) !== null && n !== void 0 ? n : [];
      if (((s = this.Pl) === null || s === void 0 ? void 0 : s.gl) === r) return this.Pl.Ml;
      const a = r.map(l => new El(l));
      return this.Pl = {
          gl: r,
          Ml: a
      }, a
  }
  Bl() {
      var e, t, n, s;
      const r = (n = (t = (e = this.Dl).timeAxisPaneViews) === null || t === void 0 ? void 0 : t.call(e)) !== null && n !== void 0 ? n : [];
      if (((s = this.Rl) === null || s === void 0 ? void 0 : s.gl) === r) return this.Rl.Ml;
      const a = r.map(l => new El(l));
      return this.Rl = {
          gl: r,
          Ml: a
      }, a
  }
  Al(e, t) {
      var n, s, r;
      return (r = (s = (n = this.Dl).autoscaleInfo) === null || s === void 0 ? void 0 : s.call(n, e, t)) !== null && r !== void 0 ? r : null
  }
  br(e, t) {
      var n, s, r;
      return (r = (s = (n = this.Dl).hitTest) === null || s === void 0 ? void 0 : s.call(n, e, t)) !== null && r !== void 0 ? r : null
  }
}

function Cl(i, e, t, n) {
  i.forEach(s => {
      e(s).forEach(r => {
          r.xl() === t && n.push(r)
      })
  })
}

function $l(i) {
  return i.Pn()
}

function D2(i) {
  return i.Ol()
}

function F2(i) {
  return i.Bl()
}
class Cu extends L2 {
  constructor(e, t, n, s, r) {
      super(e), this.zt = new N2, this.Wh = new T2(this), this.Il = [], this.zl = new p2(this), this.Ll = null, this.El = null, this.Nl = [], this.Fl = [], this.Wl = null, this.jl = [], this.cn = t, this.Hl = n;
      const a = new S2(this);
      this.rn = [a], this.jh = new Qp(a, this, e), n !== "Area" && n !== "Line" && n !== "Baseline" || (this.Ll = new y2(this)), this.$l(), this.Ul(r)
  }
  S() {
      this.Wl !== null && clearTimeout(this.Wl)
  }
  ph(e) {
      return this.cn.priceLineColor || e
  }
  Yr(e) {
      const t = {
              Zr: !0
          },
          n = this.Dt();
      if (this.$t().St().Ni() || n.Ni() || this.zt.Ni()) return t;
      const s = this.$t().St().Zs(),
          r = this.Ct();
      if (s === null || r === null) return t;
      let a, l;
      if (e) {
          const h = this.zt.nl();
          if (h === null) return t;
          a = h, l = h.se
      } else {
          const h = this.zt.hl(s.ui(), -1);
          if (h === null || (a = this.zt.Kh(h.se), a === null)) return t;
          l = h.se
      }
      const o = a.Vt[3],
          u = this.$s().Hs(l, {
              Vt: a
          }),
          c = n.Rt(o, r.Vt);
      return {
          Zr: !1,
          _t: o,
          Kt: n.Fi(o, r.Vt),
          Mh: n.ql(o),
          xh: n.Yl(o, r.Vt),
          V: u.ue,
          ki: c,
          se: l
      }
  }
  $s() {
      return this.El !== null || (this.El = new I2(this)), this.El
  }
  W() {
      return this.cn
  }
  Hh(e) {
      const t = e.priceScaleId;
      t !== void 0 && t !== this.cn.priceScaleId && this.$t().Zl(this, t), ni(this.cn, e), e.priceFormat !== void 0 && (this.$l(), this.$t().Xl()), this.$t().Kl(this), this.$t().Gl(), this.wn.bt("options")
  }
  J(e, t) {
      this.zt.J(e), this.Jl(), this.wn.bt("data"), this.dn.bt("data"), this.Ll !== null && (t && t.Ql ? this.Ll.Hr() : e.length === 0 && this.Ll.jr());
      const n = this.$t().cr(this);
      this.$t().ta(n), this.$t().Kl(this), this.$t().Gl(), this.$t().$h()
  }
  ia(e) {
      this.Nl = e, this.Jl();
      const t = this.$t().cr(this);
      this.dn.bt("data"), this.$t().ta(t), this.$t().Kl(this), this.$t().Gl(), this.$t().$h()
  }
  na() {
      return this.Nl
  }
  uh() {
      return this.Fl
  }
  sa(e) {
      const t = new $2(this, e);
      return this.Il.push(t), this.$t().Kl(this), t
  }
  ea(e) {
      const t = this.Il.indexOf(e);
      t !== -1 && this.Il.splice(t, 1), this.$t().Kl(this)
  }
  Jh() {
      return this.Hl
  }
  Ct() {
      const e = this.ra();
      return e === null ? null : {
          Vt: e.Vt[3],
          ha: e.ot
      }
  }
  ra() {
      const e = this.$t().St().Zs();
      if (e === null) return null;
      const t = e.Vs();
      return this.zt.hl(t, 1)
  }
  In() {
      return this.zt
  }
  fh(e) {
      const t = this.zt.Kh(e);
      return t === null ? null : this.Hl === "Bar" || this.Hl === "Candlestick" || this.Hl === "Custom" ? {
          we: t.Vt[0],
          ge: t.Vt[1],
          Me: t.Vt[2],
          xe: t.Vt[3]
      } : t.Vt[3]
  }
  la(e) {
      const t = [];
      Cl(this.jl, $l, "top", t);
      const n = this.Ll;
      return n !== null && n.yt() && (this.Wl === null && n.Ur() && (this.Wl = setTimeout(() => {
          this.Wl = null, this.$t().aa()
      }, 0)), n.$r(), t.unshift(n)), t
  }
  Pn() {
      const e = [];
      this.oa() || e.push(this.zl), e.push(this.wn, this.Wh, this.dn);
      const t = this.Il.map(n => n.Uh());
      return e.push(...t), Cl(this.jl, $l, "normal", e), e
  }
  _a() {
      return this.ua($l, "bottom")
  }
  ca(e) {
      return this.ua(D2, e)
  }
  da(e) {
      return this.ua(F2, e)
  }
  fa(e, t) {
      return this.jl.map(n => n.br(e, t)).filter(n => n !== null)
  }
  Ji(e) {
      return [this.jh, ...this.Il.map(t => t.qh())]
  }
  Rn(e, t) {
      if (t !== this.Yi && !this.oa()) return [];
      const n = [...this.rn];
      for (const s of this.Il) n.push(s.Yh());
      return this.jl.forEach(s => {
          n.push(...s.Rn())
      }), n
  }
  Qi() {
      const e = [];
      return this.jl.forEach(t => {
          e.push(...t.Qi())
      }), e
  }
  Al(e, t) {
      if (this.cn.autoscaleInfoProvider !== void 0) {
          const n = this.cn.autoscaleInfoProvider(() => {
              const s = this.va(e, t);
              return s === null ? null : s.Oh()
          });
          return Qr.Bh(n)
      }
      return this.va(e, t)
  }
  pa() {
      return this.cn.priceFormat.minMove
  }
  ma() {
      return this.ba
  }
  Vn() {
      var e;
      this.wn.bt(), this.dn.bt();
      for (const t of this.rn) t.bt();
      for (const t of this.Il) t.bt();
      this.Wh.bt(), this.zl.bt(), (e = this.Ll) === null || e === void 0 || e.bt(), this.jl.forEach(t => t.Vn())
  }
  Dt() {
      return Q(super.Dt())
  }
  kt(e) {
      if (!((this.Hl === "Line" || this.Hl === "Area" || this.Hl === "Baseline") && this.cn.crosshairMarkerVisible)) return null;
      const t = this.zt.Kh(e);
      return t === null ? null : {
          _t: t.Vt[3],
          ht: this.wa(),
          Ot: this.ga(),
          Pt: this.Ma(),
          Tt: this.xa(e)
      }
  }
  mh() {
      return this.cn.title
  }
  yt() {
      return this.cn.visible
  }
  Sa(e) {
      this.jl.push(new O2(e, this))
  }
  ka(e) {
      this.jl = this.jl.filter(t => t.Vl() !== e)
  }
  ya() {
      if (this.wn instanceof Sl) return e => this.wn.Fe(e)
  }
  Ca() {
      if (this.wn instanceof Sl) return e => this.wn.We(e)
  }
  oa() {
      return !Sa(this.Dt().Ta())
  }
  va(e, t) {
      if (!Bs(e) || !Bs(t) || this.zt.Ni()) return null;
      const n = this.Hl === "Line" || this.Hl === "Area" || this.Hl === "Baseline" || this.Hl === "Histogram" ? [3] : [2, 1],
          s = this.zt.al(e, t, n);
      let r = s !== null ? new Tt(s.pl, s.ml) : null;
      if (this.Jh() === "Histogram") {
          const l = this.cn.base,
              o = new Tt(l, l);
          r = r !== null ? r.ts(o) : o
      }
      let a = this.dn._h();
      return this.jl.forEach(l => {
          const o = l.Al(e, t);
          if (o?.priceRange) {
              const f = new Tt(o.priceRange.minValue, o.priceRange.maxValue);
              r = r !== null ? r.ts(f) : f
          }
          var u, c, h, d;
          o?.margins && (u = a, c = o.margins, a = {
              above: Math.max((h = u?.above) !== null && h !== void 0 ? h : 0, c.above),
              below: Math.max((d = u?.below) !== null && d !== void 0 ? d : 0, c.below)
          })
      }), new Qr(r, a)
  }
  wa() {
      switch (this.Hl) {
          case "Line":
          case "Area":
          case "Baseline":
              return this.cn.crosshairMarkerRadius
      }
      return 0
  }
  ga() {
      switch (this.Hl) {
          case "Line":
          case "Area":
          case "Baseline": {
              const e = this.cn.crosshairMarkerBorderColor;
              if (e.length !== 0) return e
          }
      }
      return null
  }
  Ma() {
      switch (this.Hl) {
          case "Line":
          case "Area":
          case "Baseline":
              return this.cn.crosshairMarkerBorderWidth
      }
      return 0
  }
  xa(e) {
      switch (this.Hl) {
          case "Line":
          case "Area":
          case "Baseline": {
              const t = this.cn.crosshairMarkerBackgroundColor;
              if (t.length !== 0) return t
          }
      }
      return this.$s().Hs(e).ue
  }
  $l() {
      switch (this.cn.priceFormat.type) {
          case "custom":
              this.ba = {
                  format: this.cn.priceFormat.formatter
              };
              break;
          case "volume":
              this.ba = new HS(this.cn.priceFormat.precision);
              break;
          case "percent":
              this.ba = new Wp(this.cn.priceFormat.precision);
              break;
          default: {
              const e = Math.pow(10, this.cn.priceFormat.precision);
              this.ba = new Ea(e, this.cn.priceFormat.minMove * e)
          }
      }
      this.Yi !== null && this.Yi.Pa()
  }
  Jl() {
      const e = this.$t().St();
      if (!e.Ra() || this.zt.Ni()) return void(this.Fl = []);
      const t = Q(this.zt.sl());
      this.Fl = this.Nl.map((n, s) => {
          const r = Q(e.Da(n.time, !0)),
              a = r < t ? 1 : -1;
          return {
              time: Q(this.zt.hl(r, a)).se,
              position: n.position,
              shape: n.shape,
              color: n.color,
              id: n.id,
              Qr: s,
              text: n.text,
              size: n.size,
              originalTime: n.originalTime
          }
      })
  }
  Ul(e) {
      switch (this.dn = new x2(this, this.$t()), this.Hl) {
          case "Bar":
              this.wn = new e2(this, this.$t());
              break;
          case "Candlestick":
              this.wn = new r2(this, this.$t());
              break;
          case "Line":
              this.wn = new c2(this, this.$t());
              break;
          case "Custom":
              this.wn = new Sl(this, this.$t(), xt(e));
              break;
          case "Area":
              this.wn = new QS(this, this.$t());
              break;
          case "Baseline":
              this.wn = new n2(this, this.$t());
              break;
          case "Histogram":
              this.wn = new u2(this, this.$t());
              break;
          default:
              throw Error("Unknown chart style assigned: " + this.Hl)
      }
  }
  ua(e, t) {
      const n = [];
      return Cl(this.jl, e, t, n), n
  }
}
class A2 {
  constructor(e) {
      this.cn = e
  }
  Va(e, t, n) {
      let s = e;
      if (this.cn.mode === 0) return s;
      const r = n.vn(),
          a = r.Ct();
      if (a === null) return s;
      const l = r.Rt(e, a),
          o = n.Oa().filter(c => c instanceof Cu).reduce((c, h) => {
              if (n.dr(h) || !h.yt()) return c;
              const d = h.Dt(),
                  f = h.In();
              if (d.Ni() || !f.Xr(t)) return c;
              const p = f.Kh(t);
              if (p === null) return c;
              const g = En(h.Ct());
              return c.concat([d.Rt(p.Vt[3], g.Vt)])
          }, []);
      if (o.length === 0) return s;
      o.sort((c, h) => Math.abs(c - l) - Math.abs(h - l));
      const u = o[0];
      return s = r.pn(u, a), s
  }
}
class V2 extends ri {
  constructor() {
      super(...arguments), this.zt = null
  }
  J(e) {
      this.zt = e
  }
  K({
      context: e,
      bitmapSize: t,
      horizontalPixelRatio: n,
      verticalPixelRatio: s
  }) {
      if (this.zt === null) return;
      const r = Math.max(1, Math.floor(n));
      e.lineWidth = r,
          function(a, l) {
              a.save(), a.lineWidth % 2 && a.translate(.5, .5), l(), a.restore()
          }(e, () => {
              const a = Q(this.zt);
              if (a.Ba) {
                  e.strokeStyle = a.Aa, dn(e, a.Ia), e.beginPath();
                  for (const l of a.za) {
                      const o = Math.round(l.La * n);
                      e.moveTo(o, -r), e.lineTo(o, t.height + r)
                  }
                  e.stroke()
              }
              if (a.Ea) {
                  e.strokeStyle = a.Na, dn(e, a.Fa), e.beginPath();
                  for (const l of a.Wa) {
                      const o = Math.round(l.La * s);
                      e.moveTo(-r, o), e.lineTo(t.width + r, o)
                  }
                  e.stroke()
              }
          })
  }
}
class z2 {
  constructor(e) {
      this.Wt = new V2, this.ft = !0, this.tn = e
  }
  bt() {
      this.ft = !0
  }
  gt() {
      if (this.ft) {
          const e = this.tn.$t().W().grid,
              t = {
                  Ea: e.horzLines.visible,
                  Ba: e.vertLines.visible,
                  Na: e.horzLines.color,
                  Aa: e.vertLines.color,
                  Fa: e.horzLines.style,
                  Ia: e.vertLines.style,
                  Wa: this.tn.vn().ja(),
                  za: (this.tn.$t().St().ja() || []).map(n => ({
                      La: n.coord
                  }))
              };
          this.Wt.J(t), this.ft = !1
      }
      return this.Wt
  }
}
class W2 {
  constructor(e) {
      this.wn = new z2(e)
  }
  Uh() {
      return this.wn
  }
}
const Ll = {
  Ha: 4,
  $a: 1e-4
};

function Cn(i, e) {
  const t = 100 * (i - e) / e;
  return e < 0 ? -t : t
}

function U2(i, e) {
  const t = Cn(i.Th(), e),
      n = Cn(i.Ph(), e);
  return new Tt(t, n)
}

function bs(i, e) {
  const t = 100 * (i - e) / e + 100;
  return e < 0 ? -t : t
}

function j2(i, e) {
  const t = bs(i.Th(), e),
      n = bs(i.Ph(), e);
  return new Tt(t, n)
}

function Zr(i, e) {
  const t = Math.abs(i);
  if (t < 1e-15) return 0;
  const n = Math.log10(t + e.$a) + e.Ha;
  return i < 0 ? -n : n
}

function ws(i, e) {
  const t = Math.abs(i);
  if (t < 1e-15) return 0;
  const n = Math.pow(10, t - e.Ha) - e.$a;
  return i < 0 ? -n : n
}

function ls(i, e) {
  if (i === null) return null;
  const t = Zr(i.Th(), e),
      n = Zr(i.Ph(), e);
  return new Tt(t, n)
}

function fr(i, e) {
  if (i === null) return null;
  const t = ws(i.Th(), e),
      n = ws(i.Ph(), e);
  return new Tt(t, n)
}

function Pl(i) {
  if (i === null) return Ll;
  const e = Math.abs(i.Ph() - i.Th());
  if (e >= 1 || e < 1e-15) return Ll;
  const t = Math.ceil(Math.abs(Math.log10(e))),
      n = Ll.Ha + t;
  return {
      Ha: n,
      $a: 1 / Math.pow(10, n)
  }
}
class Il {
  constructor(e, t) {
      if (this.Ua = e, this.qa = t, function(n) {
              if (n < 0) return !1;
              for (let s = n; s > 1; s /= 10)
                  if (s % 10 != 0) return !1;
              return !0
          }(this.Ua)) this.Ya = [2, 2.5, 2];
      else {
          this.Ya = [];
          for (let n = this.Ua; n !== 1;) {
              if (n % 2 == 0) this.Ya.push(2), n /= 2;
              else {
                  if (n % 5 != 0) throw new Error("unexpected base");
                  this.Ya.push(2, 2.5), n /= 5
              }
              if (this.Ya.length > 100) throw new Error("something wrong with base")
          }
      }
  }
  Za(e, t, n) {
      const s = this.Ua === 0 ? 0 : 1 / this.Ua;
      let r = Math.pow(10, Math.max(0, Math.ceil(Math.log10(e - t)))),
          a = 0,
          l = this.qa[0];
      for (;;) {
          const h = hr(r, s, 1e-14) && r > s + 1e-14,
              d = hr(r, n * l, 1e-14),
              f = hr(r, 1, 1e-14);
          if (!(h && d && f)) break;
          r /= l, l = this.qa[++a % this.qa.length]
      }
      if (r <= s + 1e-14 && (r = s), r = Math.max(1, r), this.Ya.length > 0 && (o = r, u = 1, c = 1e-14, Math.abs(o - u) < c))
          for (a = 0, l = this.Ya[0]; hr(r, n * l, 1e-14) && r > s + 1e-14;) r /= l, l = this.Ya[++a % this.Ya.length];
      var o, u, c;
      return r
  }
}
class Lh {
  constructor(e, t, n, s) {
      this.Xa = [], this.Li = e, this.Ua = t, this.Ka = n, this.Ga = s
  }
  Za(e, t) {
      if (e < t) throw new Error("high < low");
      const n = this.Li.At(),
          s = (e - t) * this.Ja() / n,
          r = new Il(this.Ua, [2, 2.5, 2]),
          a = new Il(this.Ua, [2, 2, 2.5]),
          l = new Il(this.Ua, [2.5, 2, 2]),
          o = [];
      return o.push(r.Za(e, t, s), a.Za(e, t, s), l.Za(e, t, s)),
          function(u) {
              if (u.length < 1) throw Error("array is empty");
              let c = u[0];
              for (let h = 1; h < u.length; ++h) u[h] < c && (c = u[h]);
              return c
          }(o)
  }
  Qa() {
      const e = this.Li,
          t = e.Ct();
      if (t === null) return void(this.Xa = []);
      const n = e.At(),
          s = this.Ka(n - 1, t),
          r = this.Ka(0, t),
          a = this.Li.W().entireTextOnly ? this.io() / 2 : 0,
          l = a,
          o = n - 1 - a,
          u = Math.max(s, r),
          c = Math.min(s, r);
      if (u === c) return void(this.Xa = []);
      let h = this.Za(u, c),
          d = u % h;
      d += d < 0 ? h : 0;
      const f = u >= c ? 1 : -1;
      let p = null,
          g = 0;
      for (let w = u - d; w > c; w -= h) {
          const y = this.Ga(w, t, !0);
          p !== null && Math.abs(y - p) < this.Ja() || y < l || y > o || (g < this.Xa.length ? (this.Xa[g].La = y, this.Xa[g].no = e.so(w)) : this.Xa.push({
              La: y,
              no: e.so(w)
          }), g++, p = y, e.eo() && (h = this.Za(w * f, c)))
      }
      this.Xa.length = g
  }
  ja() {
      return this.Xa
  }
  io() {
      return this.Li.P()
  }
  Ja() {
      return Math.ceil(2.5 * this.io())
  }
}

function im(i) {
  return i.slice().sort((e, t) => Q(e.Xi()) - Q(t.Xi()))
}
var Ph;
(function(i) {
  i[i.Normal = 0] = "Normal", i[i.Logarithmic = 1] = "Logarithmic", i[i.Percentage = 2] = "Percentage", i[i.IndexedTo100 = 3] = "IndexedTo100"
})(Ph || (Ph = {}));
const Ih = new Wp,
  Nh = new Ea(100, 1);
class H2 {
  constructor(e, t, n, s) {
      this.ro = 0, this.ho = null, this.Ah = null, this.lo = null, this.ao = {
          oo: !1,
          _o: null
      }, this.uo = 0, this.co = 0, this.do = new Ze, this.fo = new Ze, this.vo = [], this.po = null, this.mo = null, this.bo = null, this.wo = null, this.ba = Nh, this.Mo = Pl(null), this.xo = e, this.cn = t, this.So = n, this.ko = s, this.yo = new Lh(this, 100, this.Co.bind(this), this.To.bind(this))
  }
  Ta() {
      return this.xo
  }
  W() {
      return this.cn
  }
  Hh(e) {
      if (ni(this.cn, e), this.Pa(), e.mode !== void 0 && this.Po({
              yr: e.mode
          }), e.scaleMargins !== void 0) {
          const t = xt(e.scaleMargins.top),
              n = xt(e.scaleMargins.bottom);
          if (t < 0 || t > 1) throw new Error(`Invalid top margin - expect value between 0 and 1, given=${t}`);
          if (n < 0 || n > 1) throw new Error(`Invalid bottom margin - expect value between 0 and 1, given=${n}`);
          if (t + n > 1) throw new Error(`Invalid margins - sum of margins must be less than 1, given=${t+n}`);
          this.Ro(), this.mo = null
      }
  }
  Do() {
      return this.cn.autoScale
  }
  eo() {
      return this.cn.mode === 1
  }
  gh() {
      return this.cn.mode === 2
  }
  Vo() {
      return this.cn.mode === 3
  }
  yr() {
      return {
          Wn: this.cn.autoScale,
          Oo: this.cn.invertScale,
          yr: this.cn.mode
      }
  }
  Po(e) {
      const t = this.yr();
      let n = null;
      e.Wn !== void 0 && (this.cn.autoScale = e.Wn), e.yr !== void 0 && (this.cn.mode = e.yr, e.yr !== 2 && e.yr !== 3 || (this.cn.autoScale = !0), this.ao.oo = !1), t.yr === 1 && e.yr !== t.yr && (function(r, a) {
          if (r === null) return !1;
          const l = ws(r.Th(), a),
              o = ws(r.Ph(), a);
          return isFinite(l) && isFinite(o)
      }(this.Ah, this.Mo) ? (n = fr(this.Ah, this.Mo), n !== null && this.Bo(n)) : this.cn.autoScale = !0), e.yr === 1 && e.yr !== t.yr && (n = ls(this.Ah, this.Mo), n !== null && this.Bo(n));
      const s = t.yr !== this.cn.mode;
      s && (t.yr === 2 || this.gh()) && this.Pa(), s && (t.yr === 3 || this.Vo()) && this.Pa(), e.Oo !== void 0 && t.Oo !== e.Oo && (this.cn.invertScale = e.Oo, this.Ao()), this.fo.m(t, this.yr())
  }
  Io() {
      return this.fo
  }
  P() {
      return this.So.fontSize
  }
  At() {
      return this.ro
  }
  zo(e) {
      this.ro !== e && (this.ro = e, this.Ro(), this.mo = null)
  }
  Lo() {
      if (this.ho) return this.ho;
      const e = this.At() - this.Eo() - this.No();
      return this.ho = e, e
  }
  zh() {
      return this.Fo(), this.Ah
  }
  Bo(e, t) {
      const n = this.Ah;
      (t || n === null && e !== null || n !== null && !n.yh(e)) && (this.mo = null, this.Ah = e)
  }
  Ni() {
      return this.Fo(), this.ro === 0 || !this.Ah || this.Ah.Ni()
  }
  Wo(e) {
      return this.Oo() ? e : this.At() - 1 - e
  }
  Rt(e, t) {
      return this.gh() ? e = Cn(e, t) : this.Vo() && (e = bs(e, t)), this.To(e, t)
  }
  Qs(e, t, n) {
      this.Fo();
      const s = this.No(),
          r = Q(this.zh()),
          a = r.Th(),
          l = r.Ph(),
          o = this.Lo() - 1,
          u = this.Oo(),
          c = o / (l - a),
          h = n === void 0 ? 0 : n.from,
          d = n === void 0 ? e.length : n.to,
          f = this.jo();
      for (let p = h; p < d; p++) {
          const g = e[p],
              w = g._t;
          if (isNaN(w)) continue;
          let y = w;
          f !== null && (y = f(g._t, t));
          const b = s + c * (y - a),
              x = u ? b : this.ro - 1 - b;
          g.st = x
      }
  }
  me(e, t, n) {
      this.Fo();
      const s = this.No(),
          r = Q(this.zh()),
          a = r.Th(),
          l = r.Ph(),
          o = this.Lo() - 1,
          u = this.Oo(),
          c = o / (l - a),
          h = n === void 0 ? 0 : n.from,
          d = n === void 0 ? e.length : n.to,
          f = this.jo();
      for (let p = h; p < d; p++) {
          const g = e[p];
          let w = g.we,
              y = g.ge,
              b = g.Me,
              x = g.xe;
          f !== null && (w = f(g.we, t), y = f(g.ge, t), b = f(g.Me, t), x = f(g.xe, t));
          let k = s + c * (w - a),
              S = u ? k : this.ro - 1 - k;
          g.ve = S, k = s + c * (y - a), S = u ? k : this.ro - 1 - k, g.ce = S, k = s + c * (b - a), S = u ? k : this.ro - 1 - k, g.de = S, k = s + c * (x - a), S = u ? k : this.ro - 1 - k, g.pe = S
      }
  }
  pn(e, t) {
      const n = this.Co(e, t);
      return this.Ho(n, t)
  }
  Ho(e, t) {
      let n = e;
      return this.gh() ? n = function(s, r) {
          return r < 0 && (s = -s), s / 100 * r + r
      }(n, t) : this.Vo() && (n = function(s, r) {
          return s -= 100, r < 0 && (s = -s), s / 100 * r + r
      }(n, t)), n
  }
  Oa() {
      return this.vo
  }
  $o() {
      if (this.po) return this.po;
      let e = [];
      for (let t = 0; t < this.vo.length; t++) {
          const n = this.vo[t];
          n.Xi() === null && n.Ki(t + 1), e.push(n)
      }
      return e = im(e), this.po = e, this.po
  }
  Uo(e) {
      this.vo.indexOf(e) === -1 && (this.vo.push(e), this.Pa(), this.qo())
  }
  Yo(e) {
      const t = this.vo.indexOf(e);
      if (t === -1) throw new Error("source is not attached to scale");
      this.vo.splice(t, 1), this.vo.length === 0 && (this.Po({
          Wn: !0
      }), this.Bo(null)), this.Pa(), this.qo()
  }
  Ct() {
      let e = null;
      for (const t of this.vo) {
          const n = t.Ct();
          n !== null && (e === null || n.ha < e.ha) && (e = n)
      }
      return e === null ? null : e.Vt
  }
  Oo() {
      return this.cn.invertScale
  }
  ja() {
      const e = this.Ct() === null;
      if (this.mo !== null && (e || this.mo.Zo === e)) return this.mo.ja;
      this.yo.Qa();
      const t = this.yo.ja();
      return this.mo = {
          ja: t,
          Zo: e
      }, this.do.m(), t
  }
  Xo() {
      return this.do
  }
  Ko(e) {
      this.gh() || this.Vo() || this.bo === null && this.lo === null && (this.Ni() || (this.bo = this.ro - e, this.lo = Q(this.zh()).Ch()))
  }
  Go(e) {
      if (this.gh() || this.Vo() || this.bo === null) return;
      this.Po({
          Wn: !1
      }), (e = this.ro - e) < 0 && (e = 0);
      let t = (this.bo + .2 * (this.ro - 1)) / (e + .2 * (this.ro - 1));
      const n = Q(this.lo).Ch();
      t = Math.max(t, .1), n.Dh(t), this.Bo(n)
  }
  Jo() {
      this.gh() || this.Vo() || (this.bo = null, this.lo = null)
  }
  Qo(e) {
      this.Do() || this.wo === null && this.lo === null && (this.Ni() || (this.wo = e, this.lo = Q(this.zh()).Ch()))
  }
  t_(e) {
      if (this.Do() || this.wo === null) return;
      const t = Q(this.zh()).Rh() / (this.Lo() - 1);
      let n = e - this.wo;
      this.Oo() && (n *= -1);
      const s = n * t,
          r = Q(this.lo).Ch();
      r.Vh(s), this.Bo(r, !0), this.mo = null
  }
  i_() {
      this.Do() || this.wo !== null && (this.wo = null, this.lo = null)
  }
  ma() {
      return this.ba || this.Pa(), this.ba
  }
  Fi(e, t) {
      switch (this.cn.mode) {
          case 2:
              return this.n_(Cn(e, t));
          case 3:
              return this.ma().format(bs(e, t));
          default:
              return this.Fh(e)
      }
  }
  so(e) {
      switch (this.cn.mode) {
          case 2:
              return this.n_(e);
          case 3:
              return this.ma().format(e);
          default:
              return this.Fh(e)
      }
  }
  ql(e) {
      return this.Fh(e, Q(this.s_()).ma())
  }
  Yl(e, t) {
      return e = Cn(e, t), this.n_(e, Ih)
  }
  e_() {
      return this.vo
  }
  r_(e) {
      this.ao = {
          _o: e,
          oo: !1
      }
  }
  Vn() {
      this.vo.forEach(e => e.Vn())
  }
  Pa() {
      this.mo = null;
      const e = this.s_();
      let t = 100;
      e !== null && (t = Math.round(1 / e.pa())), this.ba = Nh, this.gh() ? (this.ba = Ih, t = 100) : this.Vo() ? (this.ba = new Ea(100, 1), t = 100) : e !== null && (this.ba = e.ma()), this.yo = new Lh(this, t, this.Co.bind(this), this.To.bind(this)), this.yo.Qa()
  }
  qo() {
      this.po = null
  }
  s_() {
      return this.vo[0] || null
  }
  Eo() {
      return this.Oo() ? this.cn.scaleMargins.bottom * this.At() + this.co : this.cn.scaleMargins.top * this.At() + this.uo
  }
  No() {
      return this.Oo() ? this.cn.scaleMargins.top * this.At() + this.uo : this.cn.scaleMargins.bottom * this.At() + this.co
  }
  Fo() {
      this.ao.oo || (this.ao.oo = !0, this.h_())
  }
  Ro() {
      this.ho = null
  }
  To(e, t) {
      if (this.Fo(), this.Ni()) return 0;
      e = this.eo() && e ? Zr(e, this.Mo) : e;
      const n = Q(this.zh()),
          s = this.No() + (this.Lo() - 1) * (e - n.Th()) / n.Rh();
      return this.Wo(s)
  }
  Co(e, t) {
      if (this.Fo(), this.Ni()) return 0;
      const n = this.Wo(e),
          s = Q(this.zh()),
          r = s.Th() + s.Rh() * ((n - this.No()) / (this.Lo() - 1));
      return this.eo() ? ws(r, this.Mo) : r
  }
  Ao() {
      this.mo = null, this.yo.Qa()
  }
  h_() {
      const e = this.ao._o;
      if (e === null) return;
      let t = null;
      const n = this.e_();
      let s = 0,
          r = 0;
      for (const o of n) {
          if (!o.yt()) continue;
          const u = o.Ct();
          if (u === null) continue;
          const c = o.Al(e.Vs(), e.ui());
          let h = c && c.zh();
          if (h !== null) {
              switch (this.cn.mode) {
                  case 1:
                      h = ls(h, this.Mo);
                      break;
                  case 2:
                      h = U2(h, u.Vt);
                      break;
                  case 3:
                      h = j2(h, u.Vt)
              }
              if (t = t === null ? h : t.ts(Q(h)), c !== null) {
                  const d = c.Lh();
                  d !== null && (s = Math.max(s, d.above), r = Math.max(r, d.below))
              }
          }
      }
      if (s === this.uo && r === this.co || (this.uo = s, this.co = r, this.mo = null, this.Ro()), t !== null) {
          if (t.Th() === t.Ph()) {
              const o = this.s_(),
                  u = 5 * (o === null || this.gh() || this.Vo() ? 1 : o.pa());
              this.eo() && (t = fr(t, this.Mo)), t = new Tt(t.Th() - u, t.Ph() + u), this.eo() && (t = ls(t, this.Mo))
          }
          if (this.eo()) {
              const o = fr(t, this.Mo),
                  u = Pl(o);
              if (a = u, l = this.Mo, a.Ha !== l.Ha || a.$a !== l.$a) {
                  const c = this.lo !== null ? fr(this.lo, this.Mo) : null;
                  this.Mo = u, t = ls(o, u), c !== null && (this.lo = ls(c, u))
              }
          }
          this.Bo(t)
      } else this.Ah === null && (this.Bo(new Tt(-.5, .5)), this.Mo = Pl(null));
      var a, l;
      this.ao.oo = !0
  }
  jo() {
      return this.gh() ? Cn : this.Vo() ? bs : this.eo() ? e => Zr(e, this.Mo) : null
  }
  l_(e, t, n) {
      return t === void 0 ? (n === void 0 && (n = this.ma()), n.format(e)) : t(e)
  }
  Fh(e, t) {
      return this.l_(e, this.ko.priceFormatter, t)
  }
  n_(e, t) {
      return this.l_(e, this.ko.percentageFormatter, t)
  }
}
class q2 {
  constructor(e, t) {
      this.vo = [], this.a_ = new Map, this.ro = 0, this.o_ = 0, this.__ = 1e3, this.po = null, this.u_ = new Ze, this.kl = e, this.$i = t, this.c_ = new W2(this);
      const n = t.W();
      this.d_ = this.f_("left", n.leftPriceScale), this.v_ = this.f_("right", n.rightPriceScale), this.d_.Io().l(this.p_.bind(this, this.d_), this), this.v_.Io().l(this.p_.bind(this, this.v_), this), this.m_(n)
  }
  m_(e) {
      if (e.leftPriceScale && this.d_.Hh(e.leftPriceScale), e.rightPriceScale && this.v_.Hh(e.rightPriceScale), e.localization && (this.d_.Pa(), this.v_.Pa()), e.overlayPriceScales) {
          const t = Array.from(this.a_.values());
          for (const n of t) {
              const s = Q(n[0].Dt());
              s.Hh(e.overlayPriceScales), e.localization && s.Pa()
          }
      }
  }
  b_(e) {
      switch (e) {
          case "left":
              return this.d_;
          case "right":
              return this.v_
      }
      return this.a_.has(e) ? xt(this.a_.get(e))[0].Dt() : null
  }
  S() {
      this.$t().w_().p(this), this.d_.Io().p(this), this.v_.Io().p(this), this.vo.forEach(e => {
          e.S && e.S()
      }), this.u_.m()
  }
  g_() {
      return this.__
  }
  M_(e) {
      this.__ = e
  }
  $t() {
      return this.$i
  }
  Hi() {
      return this.o_
  }
  At() {
      return this.ro
  }
  x_(e) {
      this.o_ = e, this.S_()
  }
  zo(e) {
      this.ro = e, this.d_.zo(e), this.v_.zo(e), this.vo.forEach(t => {
          if (this.dr(t)) {
              const n = t.Dt();
              n !== null && n.zo(e)
          }
      }), this.S_()
  }
  Oa() {
      return this.vo
  }
  dr(e) {
      const t = e.Dt();
      return t === null || this.d_ !== t && this.v_ !== t
  }
  Uo(e, t, n) {
      const s = n !== void 0 ? n : this.y_().k_ + 1;
      this.C_(e, t, s)
  }
  Yo(e) {
      const t = this.vo.indexOf(e);
      Hi(t !== -1, "removeDataSource: invalid data source"), this.vo.splice(t, 1);
      const n = Q(e.Dt()).Ta();
      if (this.a_.has(n)) {
          const r = xt(this.a_.get(n)),
              a = r.indexOf(e);
          a !== -1 && (r.splice(a, 1), r.length === 0 && this.a_.delete(n))
      }
      const s = e.Dt();
      s && s.Oa().indexOf(e) >= 0 && s.Yo(e), s !== null && (s.qo(), this.T_(s)), this.po = null
  }
  pr(e) {
      return e === this.d_ ? "left" : e === this.v_ ? "right" : "overlay"
  }
  P_() {
      return this.d_
  }
  R_() {
      return this.v_
  }
  D_(e, t) {
      e.Ko(t)
  }
  V_(e, t) {
      e.Go(t), this.S_()
  }
  O_(e) {
      e.Jo()
  }
  B_(e, t) {
      e.Qo(t)
  }
  A_(e, t) {
      e.t_(t), this.S_()
  }
  I_(e) {
      e.i_()
  }
  S_() {
      this.vo.forEach(e => {
          e.Vn()
      })
  }
  vn() {
      let e = null;
      return this.$i.W().rightPriceScale.visible && this.v_.Oa().length !== 0 ? e = this.v_ : this.$i.W().leftPriceScale.visible && this.d_.Oa().length !== 0 ? e = this.d_ : this.vo.length !== 0 && (e = this.vo[0].Dt()), e === null && (e = this.v_), e
  }
  vr() {
      let e = null;
      return this.$i.W().rightPriceScale.visible ? e = this.v_ : this.$i.W().leftPriceScale.visible && (e = this.d_), e
  }
  T_(e) {
      e !== null && e.Do() && this.z_(e)
  }
  L_(e) {
      const t = this.kl.Zs();
      e.Po({
          Wn: !0
      }), t !== null && e.r_(t), this.S_()
  }
  E_() {
      this.z_(this.d_), this.z_(this.v_)
  }
  N_() {
      this.T_(this.d_), this.T_(this.v_), this.vo.forEach(e => {
          this.dr(e) && this.T_(e.Dt())
      }), this.S_(), this.$i.$h()
  }
  $o() {
      return this.po === null && (this.po = im(this.vo)), this.po
  }
  F_() {
      return this.u_
  }
  W_() {
      return this.c_
  }
  z_(e) {
      const t = e.e_();
      if (t && t.length > 0 && !this.kl.Ni()) {
          const n = this.kl.Zs();
          n !== null && e.r_(n)
      }
      e.Vn()
  }
  y_() {
      const e = this.$o();
      if (e.length === 0) return {
          j_: 0,
          k_: 0
      };
      let t = 0,
          n = 0;
      for (let s = 0; s < e.length; s++) {
          const r = e[s].Xi();
          r !== null && (r < t && (t = r), r > n && (n = r))
      }
      return {
          j_: t,
          k_: n
      }
  }
  C_(e, t, n) {
      let s = this.b_(t);
      if (s === null && (s = this.f_(t, this.$i.W().overlayPriceScales)), this.vo.push(e), !Sa(t)) {
          const r = this.a_.get(t) || [];
          r.push(e), this.a_.set(t, r)
      }
      s.Uo(e), e.Gi(s), e.Ki(n), this.T_(s), this.po = null
  }
  p_(e, t, n) {
      t.yr !== n.yr && this.z_(e)
  }
  f_(e, t) {
      const n = Object.assign({
              visible: !0,
              autoScale: !0
          }, xi(t)),
          s = new H2(e, n, this.$i.W().layout, this.$i.W().localization);
      return s.zo(this.At()), s
  }
}
class G2 {
  constructor(e, t, n = 50) {
      this.Xe = 0, this.Ke = 1, this.Ge = 1, this.Qe = new Map, this.Je = new Map, this.H_ = e, this.U_ = t, this.tr = n
  }
  q_(e) {
      const t = e.time,
          n = this.U_.cacheKey(t),
          s = this.Qe.get(n);
      if (s !== void 0) return s.Y_;
      if (this.Xe === this.tr) {
          const a = this.Je.get(this.Ge);
          this.Je.delete(this.Ge), this.Qe.delete(xt(a)), this.Ge++, this.Xe--
      }
      const r = this.H_(e);
      return this.Qe.set(n, {
          Y_: r,
          er: this.Ke
      }), this.Je.set(this.Ke, n), this.Xe++, this.Ke++, r
  }
}
class ks {
  constructor(e, t) {
      Hi(e <= t, "right should be >= left"), this.Z_ = e, this.X_ = t
  }
  Vs() {
      return this.Z_
  }
  ui() {
      return this.X_
  }
  K_() {
      return this.X_ - this.Z_ + 1
  }
  Xr(e) {
      return this.Z_ <= e && e <= this.X_
  }
  yh(e) {
      return this.Z_ === e.Vs() && this.X_ === e.ui()
  }
}

function Mh(i, e) {
  return i === null || e === null ? i === e : i.yh(e)
}
class K2 {
  constructor() {
      this.G_ = new Map, this.Qe = null, this.J_ = !1
  }
  Q_(e) {
      this.J_ = e, this.Qe = null
  }
  tu(e, t) {
      this.iu(t), this.Qe = null;
      for (let n = t; n < e.length; ++n) {
          const s = e[n];
          let r = this.G_.get(s.timeWeight);
          r === void 0 && (r = [], this.G_.set(s.timeWeight, r)), r.push({
              index: n,
              time: s.time,
              weight: s.timeWeight,
              originalTime: s.originalTime
          })
      }
  }
  nu(e, t) {
      const n = Math.ceil(t / e);
      return this.Qe !== null && this.Qe.su === n || (this.Qe = {
          ja: this.eu(n),
          su: n
      }), this.Qe.ja
  }
  iu(e) {
      if (e === 0) return void this.G_.clear();
      const t = [];
      this.G_.forEach((n, s) => {
          e <= n[0].index ? t.push(s) : n.splice(Xs(n, e, r => r.index < e), 1 / 0)
      });
      for (const n of t) this.G_.delete(n)
  }
  eu(e) {
      let t = [];
      for (const n of Array.from(this.G_.keys()).sort((s, r) => r - s)) {
          if (!this.G_.get(n)) continue;
          const s = t;
          t = [];
          const r = s.length;
          let a = 0;
          const l = xt(this.G_.get(n)),
              o = l.length;
          let u = 1 / 0,
              c = -1 / 0;
          for (let h = 0; h < o; h++) {
              const d = l[h],
                  f = d.index;
              for (; a < r;) {
                  const p = s[a],
                      g = p.index;
                  if (!(g < f)) {
                      u = g;
                      break
                  }
                  a++, t.push(p), c = g, u = 1 / 0
              }
              if (u - f >= e && f - c >= e) t.push(d), c = f;
              else if (this.J_) return s
          }
          for (; a < r; a++) t.push(s[a])
      }
      return t
  }
}
class An {
  constructor(e) {
      this.ru = e
  }
  hu() {
      return this.ru === null ? null : new ks(Math.floor(this.ru.Vs()), Math.ceil(this.ru.ui()))
  }
  lu() {
      return this.ru
  }
  static au() {
      return new An(null)
  }
}

function X2(i, e) {
  return i.weight > e.weight ? i : e
}
class J2 {
  constructor(e, t, n, s) {
      this.o_ = 0, this.ou = null, this._u = [], this.wo = null, this.bo = null, this.uu = new K2, this.cu = new Map, this.du = An.au(), this.fu = !0, this.vu = new Ze, this.pu = new Ze, this.mu = new Ze, this.bu = null, this.wu = null, this.gu = [], this.cn = t, this.ko = n, this.Mu = t.rightOffset, this.xu = t.barSpacing, this.$i = e, this.U_ = s, this.Su(), this.uu.Q_(t.uniformDistribution)
  }
  W() {
      return this.cn
  }
  ku(e) {
      ni(this.ko, e), this.yu(), this.Su()
  }
  Hh(e, t) {
      var n;
      ni(this.cn, e), this.cn.fixLeftEdge && this.Cu(), this.cn.fixRightEdge && this.Tu(), e.barSpacing !== void 0 && this.$i.Gn(e.barSpacing), e.rightOffset !== void 0 && this.$i.Jn(e.rightOffset), e.minBarSpacing !== void 0 && this.$i.Gn((n = e.barSpacing) !== null && n !== void 0 ? n : this.xu), this.yu(), this.Su(), this.mu.m()
  }
  mn(e) {
      var t, n;
      return (n = (t = this._u[e]) === null || t === void 0 ? void 0 : t.time) !== null && n !== void 0 ? n : null
  }
  Ui(e) {
      var t;
      return (t = this._u[e]) !== null && t !== void 0 ? t : null
  }
  Da(e, t) {
      if (this._u.length < 1) return null;
      if (this.U_.key(e) > this.U_.key(this._u[this._u.length - 1].time)) return t ? this._u.length - 1 : null;
      const n = Xs(this._u, this.U_.key(e), (s, r) => this.U_.key(s.time) < r);
      return this.U_.key(e) < this.U_.key(this._u[n].time) ? t ? n : null : n
  }
  Ni() {
      return this.o_ === 0 || this._u.length === 0 || this.ou === null
  }
  Ra() {
      return this._u.length > 0
  }
  Zs() {
      return this.Pu(), this.du.hu()
  }
  Ru() {
      return this.Pu(), this.du.lu()
  }
  Du() {
      const e = this.Zs();
      if (e === null) return null;
      const t = {
          from: e.Vs(),
          to: e.ui()
      };
      return this.Vu(t)
  }
  Vu(e) {
      const t = Math.round(e.from),
          n = Math.round(e.to),
          s = Q(this.Ou()),
          r = Q(this.Bu());
      return {
          from: Q(this.Ui(Math.max(s, t))),
          to: Q(this.Ui(Math.min(r, n)))
      }
  }
  Au(e) {
      return {
          from: Q(this.Da(e.from, !0)),
          to: Q(this.Da(e.to, !0))
      }
  }
  Hi() {
      return this.o_
  }
  x_(e) {
      if (!isFinite(e) || e <= 0 || this.o_ === e) return;
      const t = this.Ru(),
          n = this.o_;
      if (this.o_ = e, this.fu = !0, this.cn.lockVisibleTimeRangeOnResize && n !== 0) {
          const s = this.xu * e / n;
          this.xu = s
      }
      if (this.cn.fixLeftEdge && t !== null && t.Vs() <= 0) {
          const s = n - e;
          this.Mu -= Math.round(s / this.xu) + 1, this.fu = !0
      }
      this.Iu(), this.zu()
  }
  It(e) {
      if (this.Ni() || !Bs(e)) return 0;
      const t = this.Lu() + this.Mu - e;
      return this.o_ - (t + .5) * this.xu - 1
  }
  Js(e, t) {
      const n = this.Lu(),
          s = t === void 0 ? 0 : t.from,
          r = t === void 0 ? e.length : t.to;
      for (let a = s; a < r; a++) {
          const l = e[a].ot,
              o = n + this.Mu - l,
              u = this.o_ - (o + .5) * this.xu - 1;
          e[a].nt = u
      }
  }
  Eu(e) {
      return Math.ceil(this.Nu(e))
  }
  Jn(e) {
      this.fu = !0, this.Mu = e, this.zu(), this.$i.Fu(), this.$i.$h()
  }
  he() {
      return this.xu
  }
  Gn(e) {
      this.Wu(e), this.zu(), this.$i.Fu(), this.$i.$h()
  }
  ju() {
      return this.Mu
  }
  ja() {
      if (this.Ni()) return null;
      if (this.wu !== null) return this.wu;
      const e = this.xu,
          t = 5 * (this.$i.W().layout.fontSize + 4) / 8 * (this.cn.tickMarkMaxCharacterLength || 8),
          n = Math.round(t / e),
          s = Q(this.Zs()),
          r = Math.max(s.Vs(), s.Vs() - n),
          a = Math.max(s.ui(), s.ui() - n),
          l = this.uu.nu(e, t),
          o = this.Ou() + n,
          u = this.Bu() - n,
          c = this.Hu(),
          h = this.cn.fixLeftEdge || c,
          d = this.cn.fixRightEdge || c;
      let f = 0;
      for (const p of l) {
          if (!(r <= p.index && p.index <= a)) continue;
          let g;
          f < this.gu.length ? (g = this.gu[f], g.coord = this.It(p.index), g.label = this.$u(p), g.weight = p.weight) : (g = {
              needAlignCoordinate: !1,
              coord: this.It(p.index),
              label: this.$u(p),
              weight: p.weight
          }, this.gu.push(g)), this.xu > t / 2 && !c ? g.needAlignCoordinate = !1 : g.needAlignCoordinate = h && p.index <= o || d && p.index >= u, f++
      }
      return this.gu.length = f, this.wu = this.gu, this.gu
  }
  Uu() {
      this.fu = !0, this.Gn(this.cn.barSpacing), this.Jn(this.cn.rightOffset)
  }
  qu(e) {
      this.fu = !0, this.ou = e, this.zu(), this.Cu()
  }
  Yu(e, t) {
      const n = this.Nu(e),
          s = this.he(),
          r = s + t * (s / 10);
      this.Gn(r), this.cn.rightBarStaysOnScroll || this.Jn(this.ju() + (n - this.Nu(e)))
  }
  Ko(e) {
      this.wo && this.i_(), this.bo === null && this.bu === null && (this.Ni() || (this.bo = e, this.Zu()))
  }
  Go(e) {
      if (this.bu === null) return;
      const t = bo(this.o_ - e, 0, this.o_),
          n = bo(this.o_ - Q(this.bo), 0, this.o_);
      t !== 0 && n !== 0 && this.Gn(this.bu.he * t / n)
  }
  Jo() {
      this.bo !== null && (this.bo = null, this.Xu())
  }
  Qo(e) {
      this.wo === null && this.bu === null && (this.Ni() || (this.wo = e, this.Zu()))
  }
  t_(e) {
      if (this.wo === null) return;
      const t = (this.wo - e) / this.he();
      this.Mu = Q(this.bu).ju + t, this.fu = !0, this.zu()
  }
  i_() {
      this.wo !== null && (this.wo = null, this.Xu())
  }
  Ku() {
      this.Gu(this.cn.rightOffset)
  }
  Gu(e, t = 400) {
      if (!isFinite(e)) throw new RangeError("offset is required and must be finite number");
      if (!isFinite(t) || t <= 0) throw new RangeError("animationDuration (optional) must be finite positive number");
      const n = this.Mu,
          s = performance.now();
      this.$i.Zn({
          Ju: r => (r - s) / t >= 1,
          Qu: r => {
              const a = (r - s) / t;
              return a >= 1 ? e : n + (e - n) * a
          }
      })
  }
  bt(e, t) {
      this.fu = !0, this._u = e, this.uu.tu(e, t), this.zu()
  }
  tc() {
      return this.vu
  }
  nc() {
      return this.pu
  }
  sc() {
      return this.mu
  }
  Lu() {
      return this.ou || 0
  }
  ec(e) {
      const t = e.K_();
      this.Wu(this.o_ / t), this.Mu = e.ui() - this.Lu(), this.zu(), this.fu = !0, this.$i.Fu(), this.$i.$h()
  }
  rc() {
      const e = this.Ou(),
          t = this.Bu();
      e !== null && t !== null && this.ec(new ks(e, t + this.cn.rightOffset))
  }
  hc(e) {
      const t = new ks(e.from, e.to);
      this.ec(t)
  }
  qi(e) {
      return this.ko.timeFormatter !== void 0 ? this.ko.timeFormatter(e.originalTime) : this.U_.formatHorzItem(e.time)
  }
  Hu() {
      const {
          handleScroll: e,
          handleScale: t
      } = this.$i.W();
      return !(e.horzTouchDrag || e.mouseWheel || e.pressedMouseMove || e.vertTouchDrag || t.axisDoubleClickReset.time || t.axisPressedMouseMove.time || t.mouseWheel || t.pinch)
  }
  Ou() {
      return this._u.length === 0 ? null : 0
  }
  Bu() {
      return this._u.length === 0 ? null : this._u.length - 1
  }
  lc(e) {
      return (this.o_ - 1 - e) / this.xu
  }
  Nu(e) {
      const t = this.lc(e),
          n = this.Lu() + this.Mu - t;
      return Math.round(1e6 * n) / 1e6
  }
  Wu(e) {
      const t = this.xu;
      this.xu = e, this.Iu(), t !== this.xu && (this.fu = !0, this.ac())
  }
  Pu() {
      if (!this.fu) return;
      if (this.fu = !1, this.Ni()) return void this.oc(An.au());
      const e = this.Lu(),
          t = this.o_ / this.xu,
          n = this.Mu + e,
          s = new ks(n - t + 1, n);
      this.oc(new An(s))
  }
  Iu() {
      const e = this._c();
      if (this.xu < e && (this.xu = e, this.fu = !0), this.o_ !== 0) {
          const t = .5 * this.o_;
          this.xu > t && (this.xu = t, this.fu = !0)
      }
  }
  _c() {
      return this.cn.fixLeftEdge && this.cn.fixRightEdge && this._u.length !== 0 ? this.o_ / this._u.length : this.cn.minBarSpacing
  }
  zu() {
      const e = this.uc();
      this.Mu > e && (this.Mu = e, this.fu = !0);
      const t = this.cc();
      t !== null && this.Mu < t && (this.Mu = t, this.fu = !0)
  }
  cc() {
      const e = this.Ou(),
          t = this.ou;
      return e === null || t === null ? null : e - t - 1 + (this.cn.fixLeftEdge ? this.o_ / this.xu : Math.min(2, this._u.length))
  }
  uc() {
      return this.cn.fixRightEdge ? 0 : this.o_ / this.xu - Math.min(2, this._u.length)
  }
  Zu() {
      this.bu = {
          he: this.he(),
          ju: this.ju()
      }
  }
  Xu() {
      this.bu = null
  }
  $u(e) {
      let t = this.cu.get(e.weight);
      return t === void 0 && (t = new G2(n => this.dc(n), this.U_), this.cu.set(e.weight, t)), t.q_(e)
  }
  dc(e) {
      return this.U_.formatTickmark(e, this.ko)
  }
  oc(e) {
      const t = this.du;
      this.du = e, Mh(t.hu(), this.du.hu()) || this.vu.m(), Mh(t.lu(), this.du.lu()) || this.pu.m(), this.ac()
  }
  ac() {
      this.wu = null
  }
  yu() {
      this.ac(), this.cu.clear()
  }
  Su() {
      this.U_.updateFormatter(this.ko)
  }
  Cu() {
      if (!this.cn.fixLeftEdge) return;
      const e = this.Ou();
      if (e === null) return;
      const t = this.Zs();
      if (t === null) return;
      const n = t.Vs() - e;
      if (n < 0) {
          const s = this.Mu - n - 1;
          this.Jn(s)
      }
      this.Iu()
  }
  Tu() {
      this.zu(), this.Iu()
  }
}
class Y2 {
  X(e, t, n) {
      e.useMediaCoordinateSpace(s => this.K(s, t, n))
  }
  wl(e, t, n) {
      e.useMediaCoordinateSpace(s => this.fc(s, t, n))
  }
  fc(e, t, n) {}
}
class Q2 extends Y2 {
  constructor(e) {
      super(), this.vc = new Map, this.zt = e
  }
  K(e) {}
  fc(e) {
      if (!this.zt.yt) return;
      const {
          context: t,
          mediaSize: n
      } = e;
      let s = 0;
      for (const a of this.zt.mc) {
          if (a.Kt.length === 0) continue;
          t.font = a.R;
          const l = this.bc(t, a.Kt);
          l > n.width ? a.Yu = n.width / l : a.Yu = 1, s += a.wc * a.Yu
      }
      let r = 0;
      switch (this.zt.gc) {
          case "top":
              r = 0;
              break;
          case "center":
              r = Math.max((n.height - s) / 2, 0);
              break;
          case "bottom":
              r = Math.max(n.height - s, 0)
      }
      t.fillStyle = this.zt.V;
      for (const a of this.zt.mc) {
          t.save();
          let l = 0;
          switch (this.zt.Mc) {
              case "left":
                  t.textAlign = "left", l = a.wc / 2;
                  break;
              case "center":
                  t.textAlign = "center", l = n.width / 2;
                  break;
              case "right":
                  t.textAlign = "right", l = n.width - 1 - a.wc / 2
          }
          t.translate(l, r), t.textBaseline = "top", t.font = a.R, t.scale(a.Yu, a.Yu), t.fillText(a.Kt, 0, a.xc), t.restore(), r += a.wc * a.Yu
      }
  }
  bc(e, t) {
      const n = this.Sc(e.font);
      let s = n.get(t);
      return s === void 0 && (s = e.measureText(t).width, n.set(t, s)), s
  }
  Sc(e) {
      let t = this.vc.get(e);
      return t === void 0 && (t = new Map, this.vc.set(e, t)), t
  }
}
class Z2 {
  constructor(e) {
      this.ft = !0, this.Ft = {
          yt: !1,
          V: "",
          mc: [],
          gc: "center",
          Mc: "center"
      }, this.Wt = new Q2(this.Ft), this.jt = e
  }
  bt() {
      this.ft = !0
  }
  gt() {
      return this.ft && (this.Mt(), this.ft = !1), this.Wt
  }
  Mt() {
      const e = this.jt.W(),
          t = this.Ft;
      t.yt = e.visible, t.yt && (t.V = e.color, t.Mc = e.horzAlign, t.gc = e.vertAlign, t.mc = [{
          Kt: e.text,
          R: qn(e.fontSize, e.fontFamily, e.fontStyle),
          wc: 1.2 * e.fontSize,
          xc: 0,
          Yu: 0
      }])
  }
}
class eE extends xu {
  constructor(e, t) {
      super(), this.cn = t, this.wn = new Z2(this)
  }
  Rn() {
      return []
  }
  Pn() {
      return [this.wn]
  }
  W() {
      return this.cn
  }
  Vn() {
      this.wn.bt()
  }
}
var Rh, Bh, Oh, As, Dh;
(function(i) {
  i[i.OnTouchEnd = 0] = "OnTouchEnd", i[i.OnNextTap = 1] = "OnNextTap"
})(Rh || (Rh = {}));
class tE {
  constructor(e, t, n) {
      this.kc = [], this.yc = [], this.o_ = 0, this.Cc = null, this.Tc = new Ze, this.Pc = new Ze, this.Rc = null, this.Dc = e, this.cn = t, this.U_ = n, this.Vc = new MS(this), this.kl = new J2(this, t.timeScale, this.cn.localization, n), this.vt = new jS(this, t.crosshair), this.Oc = new A2(t.crosshair), this.Bc = new eE(this, t.watermark), this.Ac(), this.kc[0].M_(2e3), this.Ic = this.zc(0), this.Lc = this.zc(1)
  }
  Xl() {
      this.Ec(ht.es())
  }
  $h() {
      this.Ec(ht.ss())
  }
  aa() {
      this.Ec(new ht(1))
  }
  Kl(e) {
      const t = this.Nc(e);
      this.Ec(t)
  }
  Fc() {
      return this.Cc
  }
  Wc(e) {
      const t = this.Cc;
      this.Cc = e, t !== null && this.Kl(t.jc), e !== null && this.Kl(e.jc)
  }
  W() {
      return this.cn
  }
  Hh(e) {
      ni(this.cn, e), this.kc.forEach(t => t.m_(e)), e.timeScale !== void 0 && this.kl.Hh(e.timeScale), e.localization !== void 0 && this.kl.ku(e.localization), (e.leftPriceScale || e.rightPriceScale) && this.Tc.m(), this.Ic = this.zc(0), this.Lc = this.zc(1), this.Xl()
  }
  Hc(e, t) {
      if (e === "left") return void this.Hh({
          leftPriceScale: t
      });
      if (e === "right") return void this.Hh({
          rightPriceScale: t
      });
      const n = this.$c(e);
      n !== null && (n.Dt.Hh(t), this.Tc.m())
  }
  $c(e) {
      for (const t of this.kc) {
          const n = t.b_(e);
          if (n !== null) return {
              Ht: t,
              Dt: n
          }
      }
      return null
  }
  St() {
      return this.kl
  }
  Uc() {
      return this.kc
  }
  qc() {
      return this.Bc
  }
  Yc() {
      return this.vt
  }
  Zc() {
      return this.Pc
  }
  Xc(e, t) {
      e.zo(t), this.Fu()
  }
  x_(e) {
      this.o_ = e, this.kl.x_(this.o_), this.kc.forEach(t => t.x_(e)), this.Fu()
  }
  Ac(e) {
      const t = new q2(this.kl, this);
      e !== void 0 ? this.kc.splice(e, 0, t) : this.kc.push(t);
      const n = e === void 0 ? this.kc.length - 1 : e,
          s = ht.es();
      return s.Nn(n, {
          Fn: 0,
          Wn: !0
      }), this.Ec(s), t
  }
  D_(e, t, n) {
      e.D_(t, n)
  }
  V_(e, t, n) {
      e.V_(t, n), this.Gl(), this.Ec(this.Kc(e, 2))
  }
  O_(e, t) {
      e.O_(t), this.Ec(this.Kc(e, 2))
  }
  B_(e, t, n) {
      t.Do() || e.B_(t, n)
  }
  A_(e, t, n) {
      t.Do() || (e.A_(t, n), this.Gl(), this.Ec(this.Kc(e, 2)))
  }
  I_(e, t) {
      t.Do() || (e.I_(t), this.Ec(this.Kc(e, 2)))
  }
  L_(e, t) {
      e.L_(t), this.Ec(this.Kc(e, 2))
  }
  Gc(e) {
      this.kl.Ko(e)
  }
  Jc(e, t) {
      const n = this.St();
      if (n.Ni() || t === 0) return;
      const s = n.Hi();
      e = Math.max(1, Math.min(e, s)), n.Yu(e, t), this.Fu()
  }
  Qc(e) {
      this.td(0), this.nd(e), this.sd()
  }
  ed(e) {
      this.kl.Go(e), this.Fu()
  }
  rd() {
      this.kl.Jo(), this.$h()
  }
  td(e) {
      this.kl.Qo(e)
  }
  nd(e) {
      this.kl.t_(e), this.Fu()
  }
  sd() {
      this.kl.i_(), this.$h()
  }
  wt() {
      return this.yc
  }
  hd(e, t, n, s, r) {
      this.vt.gn(e, t);
      let a = NaN,
          l = this.kl.Eu(e);
      const o = this.kl.Zs();
      o !== null && (l = Math.min(Math.max(o.Vs(), l), o.ui()));
      const u = s.vn(),
          c = u.Ct();
      c !== null && (a = u.pn(t, c)), a = this.Oc.Va(a, l, s), this.vt.kn(l, a, s), this.aa(), r || this.Pc.m(this.vt.xt(), {
          x: e,
          y: t
      }, n)
  }
  ld(e, t, n) {
      const s = n.vn(),
          r = s.Ct(),
          a = s.Rt(e, Q(r)),
          l = this.kl.Da(t, !0),
          o = this.kl.It(Q(l));
      this.hd(o, a, null, n, !0)
  }
  ad(e) {
      this.Yc().Cn(), this.aa(), e || this.Pc.m(null, null, null)
  }
  Gl() {
      const e = this.vt.Ht();
      if (e !== null) {
          const t = this.vt.xn(),
              n = this.vt.Sn();
          this.hd(t, n, null, e)
      }
      this.vt.Vn()
  }
  od(e, t, n) {
      const s = this.kl.mn(0);
      t !== void 0 && n !== void 0 && this.kl.bt(t, n);
      const r = this.kl.mn(0),
          a = this.kl.Lu(),
          l = this.kl.Zs();
      if (l !== null && s !== null && r !== null) {
          const o = l.Xr(a),
              u = this.U_.key(s) > this.U_.key(r),
              c = e !== null && e > a && !u,
              h = this.kl.W().allowShiftVisibleRangeOnWhitespaceReplacement,
              d = o && (n !== void 0 || h) && this.kl.W().shiftVisibleRangeOnNewBar;
          if (c && !d) {
              const f = e - a;
              this.kl.Jn(this.kl.ju() - f)
          }
      }
      this.kl.qu(e)
  }
  ta(e) {
      e !== null && e.N_()
  }
  cr(e) {
      const t = this.kc.find(n => n.$o().includes(e));
      return t === void 0 ? null : t
  }
  Fu() {
      this.Bc.Vn(), this.kc.forEach(e => e.N_()), this.Gl()
  }
  S() {
      this.kc.forEach(e => e.S()), this.kc.length = 0, this.cn.localization.priceFormatter = void 0, this.cn.localization.percentageFormatter = void 0, this.cn.localization.timeFormatter = void 0
  }
  _d() {
      return this.Vc
  }
  mr() {
      return this.Vc.W()
  }
  w_() {
      return this.Tc
  }
  ud(e, t, n) {
      const s = this.kc[0],
          r = this.dd(t, e, s, n);
      return this.yc.push(r), this.yc.length === 1 ? this.Xl() : this.$h(), r
  }
  fd(e) {
      const t = this.cr(e),
          n = this.yc.indexOf(e);
      Hi(n !== -1, "Series not found"), this.yc.splice(n, 1), Q(t).Yo(e), e.S && e.S()
  }
  Zl(e, t) {
      const n = Q(this.cr(e));
      n.Yo(e);
      const s = this.$c(t);
      if (s === null) {
          const r = e.Xi();
          n.Uo(e, t, r)
      } else {
          const r = s.Ht === n ? e.Xi() : void 0;
          s.Ht.Uo(e, t, r)
      }
  }
  rc() {
      const e = ht.ss();
      e.$n(), this.Ec(e)
  }
  vd(e) {
      const t = ht.ss();
      t.Yn(e), this.Ec(t)
  }
  Kn() {
      const e = ht.ss();
      e.Kn(), this.Ec(e)
  }
  Gn(e) {
      const t = ht.ss();
      t.Gn(e), this.Ec(t)
  }
  Jn(e) {
      const t = ht.ss();
      t.Jn(e), this.Ec(t)
  }
  Zn(e) {
      const t = ht.ss();
      t.Zn(e), this.Ec(t)
  }
  Un() {
      const e = ht.ss();
      e.Un(), this.Ec(e)
  }
  pd() {
      return this.cn.rightPriceScale.visible ? "right" : "left"
  }
  md() {
      return this.Lc
  }
  q() {
      return this.Ic
  }
  Bt(e) {
      const t = this.Lc,
          n = this.Ic;
      if (t === n) return t;
      if (e = Math.max(0, Math.min(100, Math.round(100 * e))), this.Rc === null || this.Rc.Ts !== n || this.Rc.Ps !== t) this.Rc = {
          Ts: n,
          Ps: t,
          bd: new Map
      };
      else {
          const r = this.Rc.bd.get(e);
          if (r !== void 0) return r
      }
      const s = function(r, a, l) {
          const [o, u, c, h] = Rs(r), [d, f, p, g] = Rs(a), w = [Ft(o + l * (d - o)), Ft(u + l * (f - u)), Ft(c + l * (p - c)), Fp(h + l * (g - h))];
          return `rgba(${w[0]}, ${w[1]}, ${w[2]}, ${w[3]})`
      }(n, t, e / 100);
      return this.Rc.bd.set(e, s), s
  }
  Kc(e, t) {
      const n = new ht(t);
      if (e !== null) {
          const s = this.kc.indexOf(e);
          n.Nn(s, {
              Fn: t
          })
      }
      return n
  }
  Nc(e, t) {
      return t === void 0 && (t = 2), this.Kc(this.cr(e), t)
  }
  Ec(e) {
      this.Dc && this.Dc(e), this.kc.forEach(t => t.W_().Uh().bt())
  }
  dd(e, t, n, s) {
      const r = new Cu(this, e, t, n, s),
          a = e.priceScaleId !== void 0 ? e.priceScaleId : this.pd();
      return n.Uo(r, a), Sa(a) || r.Hh(e), r
  }
  zc(e) {
      const t = this.cn.layout;
      return t.background.type === "gradient" ? e === 0 ? t.background.topColor : t.background.bottomColor : t.background.color
  }
}

function wo(i) {
  return !fi(i) && !Ks(i)
}

function nm(i) {
  return fi(i)
}(function(i) {
  i[i.Disabled = 0] = "Disabled", i[i.Continuous = 1] = "Continuous", i[i.OnDataUpdate = 2] = "OnDataUpdate"
})(Bh || (Bh = {})),
function(i) {
  i[i.LastBar = 0] = "LastBar", i[i.LastVisible = 1] = "LastVisible"
}(Oh || (Oh = {})),
function(i) {
  i.Solid = "solid", i.VerticalGradient = "gradient"
}(As || (As = {})),
function(i) {
  i[i.Year = 0] = "Year", i[i.Month = 1] = "Month", i[i.DayOfMonth = 2] = "DayOfMonth", i[i.Time = 3] = "Time", i[i.TimeWithSeconds = 4] = "TimeWithSeconds"
}(Dh || (Dh = {}));
const Fh = i => i.getUTCFullYear();

function iE(i, e, t) {
  return e.replace(/yyyy/g, (n => Ti(Fh(n), 4))(i)).replace(/yy/g, (n => Ti(Fh(n) % 100, 2))(i)).replace(/MMMM/g, ((n, s) => new Date(n.getUTCFullYear(), n.getUTCMonth(), 1).toLocaleString(s, {
      month: "long"
  }))(i, t)).replace(/MMM/g, ((n, s) => new Date(n.getUTCFullYear(), n.getUTCMonth(), 1).toLocaleString(s, {
      month: "short"
  }))(i, t)).replace(/MM/g, (n => Ti((s => s.getUTCMonth() + 1)(n), 2))(i)).replace(/dd/g, (n => Ti((s => s.getUTCDate())(n), 2))(i))
}
class sm {
  constructor(e = "yyyy-MM-dd", t = "default") {
      this.wd = e, this.gd = t
  }
  q_(e) {
      return iE(e, this.wd, this.gd)
  }
}
class nE {
  constructor(e) {
      this.Md = e || "%h:%m:%s"
  }
  q_(e) {
      return this.Md.replace("%h", Ti(e.getUTCHours(), 2)).replace("%m", Ti(e.getUTCMinutes(), 2)).replace("%s", Ti(e.getUTCSeconds(), 2))
  }
}
const sE = {
  xd: "yyyy-MM-dd",
  Sd: "%h:%m:%s",
  kd: " ",
  yd: "default"
};
class rE {
  constructor(e = {}) {
      const t = Object.assign(Object.assign({}, sE), e);
      this.Cd = new sm(t.xd, t.yd), this.Td = new nE(t.Sd), this.Pd = t.kd
  }
  q_(e) {
      return `${this.Cd.q_(e)}${this.Pd}${this.Td.q_(e)}`
  }
}

function pr(i) {
  return 60 * i * 60 * 1e3
}

function Nl(i) {
  return 60 * i * 1e3
}
const mr = [{
  Rd: (Ah = 1, 1e3 * Ah),
  Dd: 10
}, {
  Rd: Nl(1),
  Dd: 20
}, {
  Rd: Nl(5),
  Dd: 21
}, {
  Rd: Nl(30),
  Dd: 22
}, {
  Rd: pr(1),
  Dd: 30
}, {
  Rd: pr(3),
  Dd: 31
}, {
  Rd: pr(6),
  Dd: 32
}, {
  Rd: pr(12),
  Dd: 33
}];
var Ah;

function Vh(i, e) {
  if (i.getUTCFullYear() !== e.getUTCFullYear()) return 70;
  if (i.getUTCMonth() !== e.getUTCMonth()) return 60;
  if (i.getUTCDate() !== e.getUTCDate()) return 50;
  for (let t = mr.length - 1; t >= 0; --t)
      if (Math.floor(e.getTime() / mr[t].Rd) !== Math.floor(i.getTime() / mr[t].Rd)) return mr[t].Dd;
  return 0
}

function Ml(i) {
  let e = i;
  if (Ks(i) && (e = $u(i)), !wo(e)) throw new Error("time must be of type BusinessDay");
  const t = new Date(Date.UTC(e.year, e.month - 1, e.day, 0, 0, 0, 0));
  return {
      Vd: Math.round(t.getTime() / 1e3),
      Od: e
  }
}

function zh(i) {
  if (!nm(i)) throw new Error("time must be of type isUTCTimestamp");
  return {
      Vd: i
  }
}

function $u(i) {
  const e = new Date(i);
  if (isNaN(e.getTime())) throw new Error(`Invalid date string=${i}, expected format=yyyy-mm-dd`);
  return {
      day: e.getUTCDate(),
      month: e.getUTCMonth() + 1,
      year: e.getUTCFullYear()
  }
}

function Wh(i) {
  Ks(i.time) && (i.time = $u(i.time))
}
class Uh {
  options() {
      return this.cn
  }
  setOptions(e) {
      this.cn = e, this.updateFormatter(e.localization)
  }
  preprocessData(e) {
      Array.isArray(e) ? function(t) {
          t.forEach(Wh)
      }(e) : Wh(e)
  }
  createConverterToInternalObj(e) {
      return Q(function(t) {
          return t.length === 0 ? null : wo(t[0].time) || Ks(t[0].time) ? Ml : zh
      }(e))
  }
  key(e) {
      return typeof e == "object" && "Vd" in e ? e.Vd : this.key(this.convertHorzItemToInternal(e))
  }
  cacheKey(e) {
      const t = e;
      return t.Od === void 0 ? new Date(1e3 * t.Vd).getTime() : new Date(Date.UTC(t.Od.year, t.Od.month - 1, t.Od.day)).getTime()
  }
  convertHorzItemToInternal(e) {
      return nm(t = e) ? zh(t) : wo(t) ? Ml(t) : Ml($u(t));
      var t
  }
  updateFormatter(e) {
      if (!this.cn) return;
      const t = e.dateFormat;
      this.cn.timeScale.timeVisible ? this.Bd = new rE({
          xd: t,
          Sd: this.cn.timeScale.secondsVisible ? "%h:%m:%s" : "%h:%m",
          kd: "   ",
          yd: e.locale
      }) : this.Bd = new sm(t, e.locale)
  }
  formatHorzItem(e) {
      const t = e;
      return this.Bd.q_(new Date(1e3 * t.Vd))
  }
  formatTickmark(e, t) {
      const n = function(r, a, l) {
              switch (r) {
                  case 0:
                  case 10:
                      return a ? l ? 4 : 3 : 2;
                  case 20:
                  case 21:
                  case 22:
                  case 30:
                  case 31:
                  case 32:
                  case 33:
                      return a ? 3 : 2;
                  case 50:
                      return 2;
                  case 60:
                      return 1;
                  case 70:
                      return 0
              }
          }(e.weight, this.cn.timeScale.timeVisible, this.cn.timeScale.secondsVisible),
          s = this.cn.timeScale;
      if (s.tickMarkFormatter !== void 0) {
          const r = s.tickMarkFormatter(e.originalTime, n, t.locale);
          if (r !== null) return r
      }
      return function(r, a, l) {
          const o = {};
          switch (a) {
              case 0:
                  o.year = "numeric";
                  break;
              case 1:
                  o.month = "short";
                  break;
              case 2:
                  o.day = "numeric";
                  break;
              case 3:
                  o.hour12 = !1, o.hour = "2-digit", o.minute = "2-digit";
                  break;
              case 4:
                  o.hour12 = !1, o.hour = "2-digit", o.minute = "2-digit", o.second = "2-digit"
          }
          const u = r.Od === void 0 ? new Date(1e3 * r.Vd) : new Date(Date.UTC(r.Od.year, r.Od.month - 1, r.Od.day));
          return new Date(u.getUTCFullYear(), u.getUTCMonth(), u.getUTCDate(), u.getUTCHours(), u.getUTCMinutes(), u.getUTCSeconds(), u.getUTCMilliseconds()).toLocaleString(l, o)
      }(e.time, n, t.locale)
  }
  maxTickMarkWeight(e) {
      let t = e.reduce(X2, e[0]).weight;
      return t > 30 && t < 50 && (t = 30), t
  }
  fillWeightsForPoints(e, t) {
      (function(n, s = 0) {
          if (n.length === 0) return;
          let r = s === 0 ? null : n[s - 1].time.Vd,
              a = r !== null ? new Date(1e3 * r) : null,
              l = 0;
          for (let o = s; o < n.length; ++o) {
              const u = n[o],
                  c = new Date(1e3 * u.time.Vd);
              a !== null && (u.timeWeight = Vh(c, a)), l += u.time.Vd - (r || u.time.Vd), r = u.time.Vd, a = c
          }
          if (s === 0 && n.length > 1) {
              const o = Math.ceil(l / (n.length - 1)),
                  u = new Date(1e3 * (n[0].time.Vd - o));
              n[0].timeWeight = Vh(new Date(1e3 * n[0].time.Vd), u)
          }
      })(e, t)
  }
  static Ad(e) {
      return ni({
          localization: {
              dateFormat: "dd MMM 'yy"
          }
      }, e ?? {})
  }
}
const Gn = typeof window < "u";

function jh() {
  return !!Gn && window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1
}

function Rl() {
  return !!Gn && /iPhone|iPad|iPod/.test(window.navigator.platform)
}

function ko(i) {
  return i + i % 2
}

function Bl(i, e) {
  return i.Id - e.Id
}

function Ol(i, e, t) {
  const n = (i.Id - e.Id) / (i.ot - e.ot);
  return Math.sign(n) * Math.min(Math.abs(n), t)
}
class aE {
  constructor(e, t, n, s) {
      this.zd = null, this.Ld = null, this.Ed = null, this.Nd = null, this.Fd = null, this.Wd = 0, this.jd = 0, this.Hd = e, this.$d = t, this.Ud = n, this.rs = s
  }
  qd(e, t) {
      if (this.zd !== null) {
          if (this.zd.ot === t) return void(this.zd.Id = e);
          if (Math.abs(this.zd.Id - e) < this.rs) return
      }
      this.Nd = this.Ed, this.Ed = this.Ld, this.Ld = this.zd, this.zd = {
          ot: t,
          Id: e
      }
  }
  Dr(e, t) {
      if (this.zd === null || this.Ld === null || t - this.zd.ot > 50) return;
      let n = 0;
      const s = Ol(this.zd, this.Ld, this.$d),
          r = Bl(this.zd, this.Ld),
          a = [s],
          l = [r];
      if (n += r, this.Ed !== null) {
          const u = Ol(this.Ld, this.Ed, this.$d);
          if (Math.sign(u) === Math.sign(s)) {
              const c = Bl(this.Ld, this.Ed);
              if (a.push(u), l.push(c), n += c, this.Nd !== null) {
                  const h = Ol(this.Ed, this.Nd, this.$d);
                  if (Math.sign(h) === Math.sign(s)) {
                      const d = Bl(this.Ed, this.Nd);
                      a.push(h), l.push(d), n += d
                  }
              }
          }
      }
      let o = 0;
      for (let u = 0; u < a.length; ++u) o += l[u] / n * a[u];
      Math.abs(o) < this.Hd || (this.Fd = {
          Id: e,
          ot: t
      }, this.jd = o, this.Wd = function(u, c) {
          const h = Math.log(c);
          return Math.log(1 * h / -u) / h
      }(Math.abs(o), this.Ud))
  }
  Qu(e) {
      const t = Q(this.Fd),
          n = e - t.ot;
      return t.Id + this.jd * (Math.pow(this.Ud, n) - 1) / Math.log(this.Ud)
  }
  Ju(e) {
      return this.Fd === null || this.Yd(e) === this.Wd
  }
  Yd(e) {
      const t = e - Q(this.Fd).ot;
      return Math.min(t, this.Wd)
  }
}
class lE {
  constructor(e, t) {
      this.Zd = void 0, this.Xd = void 0, this.Kd = void 0, this.en = !1, this.Gd = e, this.Jd = t, this.Qd()
  }
  bt() {
      this.Qd()
  }
  tf() {
      this.Zd && this.Gd.removeChild(this.Zd), this.Xd && this.Gd.removeChild(this.Xd), this.Zd = void 0, this.Xd = void 0
  }
  if () {
      return this.en !== this.nf() || this.Kd !== this.sf()
  }
  sf() {
      return Ap(Rs(this.Jd.W().layout.textColor)) > 160 ? "dark" : "light"
  }
  nf() {
      return this.Jd.W().layout.attributionLogo
  }
  ef() {
      const e = new URL(location.href);
      return e.hostname ? "&utm_source=" + e.hostname + e.pathname : ""
  }
  Qd() {
      this.if() && (this.tf(), this.en = this.nf(), this.en && (this.Kd = this.sf(), this.Xd = document.createElement("style"), this.Xd.innerText = "a#tv-attr-logo{--fill:#131722;--stroke:#fff;position:absolute;left:10px;bottom:10px;height:19px;width:35px;margin:0;padding:0;border:0;z-index:3;}a#tv-attr-logo[data-dark]{--fill:#D1D4DC;--stroke:#131722;}", this.Zd = document.createElement("a"), this.Zd.href = `https://www.tradingview.com/?utm_medium=lwc-link&utm_campaign=lwc-chart${this.ef()}`, this.Zd.title = "Charting by TradingView", this.Zd.id = "tv-attr-logo", this.Zd.target = "_blank", this.Zd.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 35 19" width="35" height="19" fill="none"><g fill-rule="evenodd" clip-path="url(#a)" clip-rule="evenodd"><path fill="var(--stroke)" d="M2 0H0v10h6v9h21.4l.5-1.3 6-15 1-2.7H23.7l-.5 1.3-.2.6a5 5 0 0 0-7-.9V0H2Zm20 17h4l5.2-13 .8-2h-7l-1 2.5-.2.5-1.5 3.8-.3.7V17Zm-.8-10a3 3 0 0 0 .7-2.7A3 3 0 1 0 16.8 7h4.4ZM14 7V2H2v6h6v9h4V7h2Z"/><path fill="var(--fill)" d="M14 2H2v6h6v9h6V2Zm12 15h-7l6-15h7l-6 15Zm-7-9a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z"/></g><defs><clipPath id="a"><path fill="var(--stroke)" d="M0 0h35v19H0z"/></clipPath></defs></svg>', this.Zd.toggleAttribute("data-dark", this.Kd === "dark"), this.Gd.appendChild(this.Xd), this.Gd.appendChild(this.Zd)))
  }
}

function fn(i, e) {
  const t = Q(i.ownerDocument).createElement("canvas");
  i.appendChild(t);
  const n = vS(t, {
      type: "device-pixel-content-box",
      options: {
          allowResizeObserver: !1
      },
      transform: (s, r) => ({
          width: Math.max(s.width, r.width),
          height: Math.max(s.height, r.height)
      })
  });
  return n.resizeCanvasElement(e), n
}

function pn(i) {
  var e;
  i.width = 1, i.height = 1, (e = i.getContext("2d")) === null || e === void 0 || e.clearRect(0, 0, 1, 1)
}

function _o(i, e, t, n) {
  i.wl && i.wl(e, t, n)
}

function $r(i, e, t, n) {
  i.X(e, t, n)
}

function xo(i, e, t, n) {
  const s = i(t, n);
  for (const r of s) {
      const a = r.gt();
      a !== null && e(a)
  }
}

function oE(i) {
  Gn && window.chrome !== void 0 && i.addEventListener("mousedown", e => {
      if (e.button === 1) return e.preventDefault(), !1
  })
}
class Lu {
  constructor(e, t, n) {
      this.rf = 0, this.hf = null, this.lf = {
          nt: Number.NEGATIVE_INFINITY,
          st: Number.POSITIVE_INFINITY
      }, this.af = 0, this._f = null, this.uf = {
          nt: Number.NEGATIVE_INFINITY,
          st: Number.POSITIVE_INFINITY
      }, this.cf = null, this.df = !1, this.ff = null, this.vf = null, this.pf = !1, this.mf = !1, this.bf = !1, this.wf = null, this.gf = null, this.Mf = null, this.xf = null, this.Sf = null, this.kf = null, this.yf = null, this.Cf = 0, this.Tf = !1, this.Pf = !1, this.Rf = !1, this.Df = 0, this.Vf = null, this.Of = !Rl(), this.Bf = s => {
          this.Af(s)
      }, this.If = s => {
          if (this.zf(s)) {
              const r = this.Lf(s);
              if (++this.af, this._f && this.af > 1) {
                  const {
                      Ef: a
                  } = this.Nf(oi(s), this.uf);
                  a < 30 && !this.bf && this.Ff(r, this.jf.Wf), this.Hf()
              }
          } else {
              const r = this.Lf(s);
              if (++this.rf, this.hf && this.rf > 1) {
                  const {
                      Ef: a
                  } = this.Nf(oi(s), this.lf);
                  a < 5 && !this.mf && this.$f(r, this.jf.Uf), this.qf()
              }
          }
      }, this.Yf = e, this.jf = t, this.cn = n, this.Zf()
  }
  S() {
      this.wf !== null && (this.wf(), this.wf = null), this.gf !== null && (this.gf(), this.gf = null), this.xf !== null && (this.xf(), this.xf = null), this.Sf !== null && (this.Sf(), this.Sf = null), this.kf !== null && (this.kf(), this.kf = null), this.Mf !== null && (this.Mf(), this.Mf = null), this.Xf(), this.qf()
  }
  Kf(e) {
      this.xf && this.xf();
      const t = this.Gf.bind(this);
      if (this.xf = () => {
              this.Yf.removeEventListener("mousemove", t)
          }, this.Yf.addEventListener("mousemove", t), this.zf(e)) return;
      const n = this.Lf(e);
      this.$f(n, this.jf.Jf), this.Of = !0
  }
  qf() {
      this.hf !== null && clearTimeout(this.hf), this.rf = 0, this.hf = null, this.lf = {
          nt: Number.NEGATIVE_INFINITY,
          st: Number.POSITIVE_INFINITY
      }
  }
  Hf() {
      this._f !== null && clearTimeout(this._f), this.af = 0, this._f = null, this.uf = {
          nt: Number.NEGATIVE_INFINITY,
          st: Number.POSITIVE_INFINITY
      }
  }
  Gf(e) {
      if (this.Rf || this.vf !== null || this.zf(e)) return;
      const t = this.Lf(e);
      this.$f(t, this.jf.Qf), this.Of = !0
  }
  tv(e) {
      const t = Dl(e.changedTouches, Q(this.Vf));
      if (t === null || (this.Df = gr(e), this.yf !== null) || this.Pf) return;
      this.Tf = !0;
      const n = this.Nf(oi(t), Q(this.vf)),
          {
              iv: s,
              nv: r,
              Ef: a
          } = n;
      if (this.pf || !(a < 5)) {
          if (!this.pf) {
              const l = .5 * s,
                  o = r >= l && !this.cn.sv(),
                  u = l > r && !this.cn.ev();
              o || u || (this.Pf = !0), this.pf = !0, this.bf = !0, this.Xf(), this.Hf()
          }
          if (!this.Pf) {
              const l = this.Lf(e, t);
              this.Ff(l, this.jf.rv), kn(e)
          }
      }
  }
  hv(e) {
      if (e.button !== 0) return;
      const t = this.Nf(oi(e), Q(this.ff)),
          {
              Ef: n
          } = t;
      if (n >= 5 && (this.mf = !0, this.qf()), this.mf) {
          const s = this.Lf(e);
          this.$f(s, this.jf.lv)
      }
  }
  Nf(e, t) {
      const n = Math.abs(t.nt - e.nt),
          s = Math.abs(t.st - e.st);
      return {
          iv: n,
          nv: s,
          Ef: n + s
      }
  }
  av(e) {
      let t = Dl(e.changedTouches, Q(this.Vf));
      if (t === null && e.touches.length === 0 && (t = e.changedTouches[0]), t === null) return;
      this.Vf = null, this.Df = gr(e), this.Xf(), this.vf = null, this.kf && (this.kf(), this.kf = null);
      const n = this.Lf(e, t);
      if (this.Ff(n, this.jf.ov), ++this.af, this._f && this.af > 1) {
          const {
              Ef: s
          } = this.Nf(oi(t), this.uf);
          s < 30 && !this.bf && this.Ff(n, this.jf.Wf), this.Hf()
      } else this.bf || (this.Ff(n, this.jf._v), this.jf._v && kn(e));
      this.af === 0 && kn(e), e.touches.length === 0 && this.df && (this.df = !1, kn(e))
  }
  Af(e) {
      if (e.button !== 0) return;
      const t = this.Lf(e);
      if (this.ff = null, this.Rf = !1, this.Sf && (this.Sf(), this.Sf = null), jh() && this.Yf.ownerDocument.documentElement.removeEventListener("mouseleave", this.Bf), !this.zf(e))
          if (this.$f(t, this.jf.uv), ++this.rf, this.hf && this.rf > 1) {
              const {
                  Ef: n
              } = this.Nf(oi(e), this.lf);
              n < 5 && !this.mf && this.$f(t, this.jf.Uf), this.qf()
          } else this.mf || this.$f(t, this.jf.cv)
  }
  Xf() {
      this.cf !== null && (clearTimeout(this.cf), this.cf = null)
  }
  dv(e) {
      if (this.Vf !== null) return;
      const t = e.changedTouches[0];
      this.Vf = t.identifier, this.Df = gr(e);
      const n = this.Yf.ownerDocument.documentElement;
      this.bf = !1, this.pf = !1, this.Pf = !1, this.vf = oi(t), this.kf && (this.kf(), this.kf = null);
      {
          const r = this.tv.bind(this),
              a = this.av.bind(this);
          this.kf = () => {
              n.removeEventListener("touchmove", r), n.removeEventListener("touchend", a)
          }, n.addEventListener("touchmove", r, {
              passive: !1
          }), n.addEventListener("touchend", a, {
              passive: !1
          }), this.Xf(), this.cf = setTimeout(this.fv.bind(this, e), 240)
      }
      const s = this.Lf(e, t);
      this.Ff(s, this.jf.vv), this._f || (this.af = 0, this._f = setTimeout(this.Hf.bind(this), 500), this.uf = oi(t))
  }
  pv(e) {
      if (e.button !== 0) return;
      const t = this.Yf.ownerDocument.documentElement;
      jh() && t.addEventListener("mouseleave", this.Bf), this.mf = !1, this.ff = oi(e), this.Sf && (this.Sf(), this.Sf = null);
      {
          const s = this.hv.bind(this),
              r = this.Af.bind(this);
          this.Sf = () => {
              t.removeEventListener("mousemove", s), t.removeEventListener("mouseup", r)
          }, t.addEventListener("mousemove", s), t.addEventListener("mouseup", r)
      }
      if (this.Rf = !0, this.zf(e)) return;
      const n = this.Lf(e);
      this.$f(n, this.jf.mv), this.hf || (this.rf = 0, this.hf = setTimeout(this.qf.bind(this), 500), this.lf = oi(e))
  }
  Zf() {
      this.Yf.addEventListener("mouseenter", this.Kf.bind(this)), this.Yf.addEventListener("touchcancel", this.Xf.bind(this));
      {
          const e = this.Yf.ownerDocument,
              t = n => {
                  this.jf.bv && (n.composed && this.Yf.contains(n.composedPath()[0]) || n.target && this.Yf.contains(n.target) || this.jf.bv())
              };
          this.gf = () => {
              e.removeEventListener("touchstart", t)
          }, this.wf = () => {
              e.removeEventListener("mousedown", t)
          }, e.addEventListener("mousedown", t), e.addEventListener("touchstart", t, {
              passive: !0
          })
      }
      Rl() && (this.Mf = () => {
          this.Yf.removeEventListener("dblclick", this.If)
      }, this.Yf.addEventListener("dblclick", this.If)), this.Yf.addEventListener("mouseleave", this.wv.bind(this)), this.Yf.addEventListener("touchstart", this.dv.bind(this), {
          passive: !0
      }), oE(this.Yf), this.Yf.addEventListener("mousedown", this.pv.bind(this)), this.gv(), this.Yf.addEventListener("touchmove", () => {}, {
          passive: !1
      })
  }
  gv() {
      this.jf.Mv === void 0 && this.jf.xv === void 0 && this.jf.Sv === void 0 || (this.Yf.addEventListener("touchstart", e => this.kv(e.touches), {
          passive: !0
      }), this.Yf.addEventListener("touchmove", e => {
          if (e.touches.length === 2 && this.yf !== null && this.jf.xv !== void 0) {
              const t = Hh(e.touches[0], e.touches[1]) / this.Cf;
              this.jf.xv(this.yf, t), kn(e)
          }
      }, {
          passive: !1
      }), this.Yf.addEventListener("touchend", e => {
          this.kv(e.touches)
      }))
  }
  kv(e) {
      e.length === 1 && (this.Tf = !1), e.length !== 2 || this.Tf || this.df ? this.yv() : this.Cv(e)
  }
  Cv(e) {
      const t = this.Yf.getBoundingClientRect() || {
          left: 0,
          top: 0
      };
      this.yf = {
          nt: (e[0].clientX - t.left + (e[1].clientX - t.left)) / 2,
          st: (e[0].clientY - t.top + (e[1].clientY - t.top)) / 2
      }, this.Cf = Hh(e[0], e[1]), this.jf.Mv !== void 0 && this.jf.Mv(), this.Xf()
  }
  yv() {
      this.yf !== null && (this.yf = null, this.jf.Sv !== void 0 && this.jf.Sv())
  }
  wv(e) {
      if (this.xf && this.xf(), this.zf(e) || !this.Of) return;
      const t = this.Lf(e);
      this.$f(t, this.jf.Tv), this.Of = !Rl()
  }
  fv(e) {
      const t = Dl(e.touches, Q(this.Vf));
      if (t === null) return;
      const n = this.Lf(e, t);
      this.Ff(n, this.jf.Pv), this.bf = !0, this.df = !0
  }
  zf(e) {
      return e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents !== void 0 ? e.sourceCapabilities.firesTouchEvents : gr(e) < this.Df + 500
  }
  Ff(e, t) {
      t && t.call(this.jf, e)
  }
  $f(e, t) {
      t && t.call(this.jf, e)
  }
  Lf(e, t) {
      const n = t || e,
          s = this.Yf.getBoundingClientRect() || {
              left: 0,
              top: 0
          };
      return {
          clientX: n.clientX,
          clientY: n.clientY,
          pageX: n.pageX,
          pageY: n.pageY,
          screenX: n.screenX,
          screenY: n.screenY,
          localX: n.clientX - s.left,
          localY: n.clientY - s.top,
          ctrlKey: e.ctrlKey,
          altKey: e.altKey,
          shiftKey: e.shiftKey,
          metaKey: e.metaKey,
          Rv: !e.type.startsWith("mouse") && e.type !== "contextmenu" && e.type !== "click",
          Dv: e.type,
          Vv: n.target,
          Ov: e.view,
          Bv: () => {
              e.type !== "touchstart" && kn(e)
          }
      }
  }
}

function Hh(i, e) {
  const t = i.clientX - e.clientX,
      n = i.clientY - e.clientY;
  return Math.sqrt(t * t + n * n)
}

function kn(i) {
  i.cancelable && i.preventDefault()
}

function oi(i) {
  return {
      nt: i.pageX,
      st: i.pageY
  }
}

function gr(i) {
  return i.timeStamp || performance.now()
}

function Dl(i, e) {
  for (let t = 0; t < i.length; ++t)
      if (i[t].identifier === e) return i[t];
  return null
}

function yr(i) {
  return {
      jc: i.jc,
      Av: {
          wr: i.Iv.externalId
      },
      zv: i.Iv.cursorStyle
  }
}

function uE(i, e, t) {
  for (const n of i) {
      const s = n.gt();
      if (s !== null && s.br) {
          const r = s.br(e, t);
          if (r !== null) return {
              Ov: n,
              Av: r
          }
      }
  }
  return null
}

function Fl(i, e) {
  return t => {
      var n, s, r, a;
      return ((s = (n = t.Dt()) === null || n === void 0 ? void 0 : n.Ta()) !== null && s !== void 0 ? s : "") !== e ? [] : (a = (r = t.ca) === null || r === void 0 ? void 0 : r.call(t, i)) !== null && a !== void 0 ? a : []
  }
}

function qh(i, e, t, n) {
  if (!i.length) return;
  let s = 0;
  const r = t / 2,
      a = i[0].At(n, !0);
  let l = e === 1 ? r - (i[0].Vi() - a / 2) : i[0].Vi() - a / 2 - r;
  l = Math.max(0, l);
  for (let o = 1; o < i.length; o++) {
      const u = i[o],
          c = i[o - 1],
          h = c.At(n, !1),
          d = u.Vi(),
          f = c.Vi();
      if (e === 1 ? d > f - h : d < f + h) {
          const p = f - h * e;
          u.Oi(p);
          const g = p - e * h / 2;
          if ((e === 1 ? g < 0 : g > t) && l > 0) {
              const w = e === 1 ? -1 - g : g - t,
                  y = Math.min(w, l);
              for (let b = s; b < i.length; b++) i[b].Oi(i[b].Vi() + e * y);
              l -= y
          }
      } else s = o, l = e === 1 ? f - h - d : d - (f + h)
  }
}
class Gh {
  constructor(e, t, n, s) {
      this.Li = null, this.Lv = null, this.Ev = !1, this.Nv = new Ds(200), this.Jr = null, this.Fv = 0, this.Wv = !1, this.jv = () => {
          this.Wv || this.tn.Hv().$t().$h()
      }, this.$v = () => {
          this.Wv || this.tn.Hv().$t().$h()
      }, this.tn = e, this.cn = t, this.So = t.layout, this.Vc = n, this.Uv = s === "left", this.qv = Fl("normal", s), this.Yv = Fl("top", s), this.Zv = Fl("bottom", s), this.Xv = document.createElement("div"), this.Xv.style.height = "100%", this.Xv.style.overflow = "hidden", this.Xv.style.width = "25px", this.Xv.style.left = "0", this.Xv.style.position = "relative", this.Kv = fn(this.Xv, Ge({
          width: 16,
          height: 16
      })), this.Kv.subscribeSuggestedBitmapSizeChanged(this.jv);
      const r = this.Kv.canvasElement;
      r.style.position = "absolute", r.style.zIndex = "1", r.style.left = "0", r.style.top = "0", this.Gv = fn(this.Xv, Ge({
          width: 16,
          height: 16
      })), this.Gv.subscribeSuggestedBitmapSizeChanged(this.$v);
      const a = this.Gv.canvasElement;
      a.style.position = "absolute", a.style.zIndex = "2", a.style.left = "0", a.style.top = "0";
      const l = {
          mv: this.Jv.bind(this),
          vv: this.Jv.bind(this),
          lv: this.Qv.bind(this),
          rv: this.Qv.bind(this),
          bv: this.tp.bind(this),
          uv: this.ip.bind(this),
          ov: this.ip.bind(this),
          Uf: this.np.bind(this),
          Wf: this.np.bind(this),
          Jf: this.sp.bind(this),
          Tv: this.ep.bind(this)
      };
      this.rp = new Lu(this.Gv.canvasElement, l, {
          sv: () => !this.cn.handleScroll.vertTouchDrag,
          ev: () => !0
      })
  }
  S() {
      this.rp.S(), this.Gv.unsubscribeSuggestedBitmapSizeChanged(this.$v), pn(this.Gv.canvasElement), this.Gv.dispose(), this.Kv.unsubscribeSuggestedBitmapSizeChanged(this.jv), pn(this.Kv.canvasElement), this.Kv.dispose(), this.Li !== null && this.Li.Xo().p(this), this.Li = null
  }
  hp() {
      return this.Xv
  }
  P() {
      return this.So.fontSize
  }
  lp() {
      const e = this.Vc.W();
      return this.Jr !== e.R && (this.Nv.ir(), this.Jr = e.R), e
  }
  ap() {
      if (this.Li === null) return 0;
      let e = 0;
      const t = this.lp(),
          n = Q(this.Kv.canvasElement.getContext("2d"));
      n.save();
      const s = this.Li.ja();
      n.font = this.op(), s.length > 0 && (e = Math.max(this.Nv.xi(n, s[0].no), this.Nv.xi(n, s[s.length - 1].no)));
      const r = this._p();
      for (let o = r.length; o--;) {
          const u = this.Nv.xi(n, r[o].Kt());
          u > e && (e = u)
      }
      const a = this.Li.Ct();
      if (a !== null && this.Lv !== null) {
          const o = this.Li.pn(1, a),
              u = this.Li.pn(this.Lv.height - 2, a);
          e = Math.max(e, this.Nv.xi(n, this.Li.Fi(Math.floor(Math.min(o, u)) + .11111111111111, a)), this.Nv.xi(n, this.Li.Fi(Math.ceil(Math.max(o, u)) - .11111111111111, a)))
      }
      n.restore();
      const l = e || 34;
      return ko(Math.ceil(t.C + t.T + t.A + t.I + 5 + l))
  }
  up(e) {
      this.Lv !== null && an(this.Lv, e) || (this.Lv = e, this.Wv = !0, this.Kv.resizeCanvasElement(e), this.Gv.resizeCanvasElement(e), this.Wv = !1, this.Xv.style.width = `${e.width}px`, this.Xv.style.height = `${e.height}px`)
  }
  cp() {
      return Q(this.Lv).width
  }
  Gi(e) {
      this.Li !== e && (this.Li !== null && this.Li.Xo().p(this), this.Li = e, e.Xo().l(this.do.bind(this), this))
  }
  Dt() {
      return this.Li
  }
  ir() {
      const e = this.tn.dp();
      this.tn.Hv().$t().L_(e, Q(this.Dt()))
  }
  fp(e) {
      if (this.Lv === null) return;
      if (e !== 1) {
          this.vp(), this.Kv.applySuggestedBitmapSize();
          const n = hn(this.Kv);
          n !== null && (n.useBitmapCoordinateSpace(s => {
              this.pp(s), this.Ae(s)
          }), this.tn.mp(n, this.Zv), this.bp(n), this.tn.mp(n, this.qv), this.wp(n))
      }
      this.Gv.applySuggestedBitmapSize();
      const t = hn(this.Gv);
      t !== null && (t.useBitmapCoordinateSpace(({
          context: n,
          bitmapSize: s
      }) => {
          n.clearRect(0, 0, s.width, s.height)
      }), this.gp(t), this.tn.mp(t, this.Yv))
  }
  Mp() {
      return this.Kv.bitmapSize
  }
  xp(e, t, n) {
      const s = this.Mp();
      s.width > 0 && s.height > 0 && e.drawImage(this.Kv.canvasElement, t, n)
  }
  bt() {
      var e;
      (e = this.Li) === null || e === void 0 || e.ja()
  }
  Jv(e) {
      if (this.Li === null || this.Li.Ni() || !this.cn.handleScale.axisPressedMouseMove.price) return;
      const t = this.tn.Hv().$t(),
          n = this.tn.dp();
      this.Ev = !0, t.D_(n, this.Li, e.localY)
  }
  Qv(e) {
      if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price) return;
      const t = this.tn.Hv().$t(),
          n = this.tn.dp(),
          s = this.Li;
      t.V_(n, s, e.localY)
  }
  tp() {
      if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price) return;
      const e = this.tn.Hv().$t(),
          t = this.tn.dp(),
          n = this.Li;
      this.Ev && (this.Ev = !1, e.O_(t, n))
  }
  ip(e) {
      if (this.Li === null || !this.cn.handleScale.axisPressedMouseMove.price) return;
      const t = this.tn.Hv().$t(),
          n = this.tn.dp();
      this.Ev = !1, t.O_(n, this.Li)
  }
  np(e) {
      this.cn.handleScale.axisDoubleClickReset.price && this.ir()
  }
  sp(e) {
      this.Li !== null && (!this.tn.Hv().$t().W().handleScale.axisPressedMouseMove.price || this.Li.gh() || this.Li.Vo() || this.Sp(1))
  }
  ep(e) {
      this.Sp(0)
  }
  _p() {
      const e = [],
          t = this.Li === null ? void 0 : this.Li;
      return (n => {
          for (let s = 0; s < n.length; ++s) {
              const r = n[s].Rn(this.tn.dp(), t);
              for (let a = 0; a < r.length; a++) e.push(r[a])
          }
      })(this.tn.dp().$o()), e
  }
  pp({
      context: e,
      bitmapSize: t
  }) {
      const {
          width: n,
          height: s
      } = t, r = this.tn.dp().$t(), a = r.q(), l = r.md();
      a === l ? xa(e, 0, 0, n, s, a) : Vp(e, 0, 0, n, s, a, l)
  }
  Ae({
      context: e,
      bitmapSize: t,
      horizontalPixelRatio: n
  }) {
      if (this.Lv === null || this.Li === null || !this.Li.W().borderVisible) return;
      e.fillStyle = this.Li.W().borderColor;
      const s = Math.max(1, Math.floor(this.lp().C * n));
      let r;
      r = this.Uv ? t.width - s : 0, e.fillRect(r, 0, s, t.height)
  }
  bp(e) {
      if (this.Lv === null || this.Li === null) return;
      const t = this.Li.ja(),
          n = this.Li.W(),
          s = this.lp(),
          r = this.Uv ? this.Lv.width - s.T : 0;
      n.borderVisible && n.ticksVisible && e.useBitmapCoordinateSpace(({
          context: a,
          horizontalPixelRatio: l,
          verticalPixelRatio: o
      }) => {
          a.fillStyle = n.borderColor;
          const u = Math.max(1, Math.floor(o)),
              c = Math.floor(.5 * o),
              h = Math.round(s.T * l);
          a.beginPath();
          for (const d of t) a.rect(Math.floor(r * l), Math.round(d.La * o) - c, h, u);
          a.fill()
      }), e.useMediaCoordinateSpace(({
          context: a
      }) => {
          var l;
          a.font = this.op(), a.fillStyle = (l = n.textColor) !== null && l !== void 0 ? l : this.So.textColor, a.textAlign = this.Uv ? "right" : "left", a.textBaseline = "middle";
          const o = this.Uv ? Math.round(r - s.A) : Math.round(r + s.T + s.A),
              u = t.map(c => this.Nv.Mi(a, c.no));
          for (let c = t.length; c--;) {
              const h = t[c];
              a.fillText(h.no, o, h.La + u[c])
          }
      })
  }
  vp() {
      if (this.Lv === null || this.Li === null) return;
      const e = [],
          t = this.Li.$o().slice(),
          n = this.tn.dp(),
          s = this.lp();
      this.Li === n.vr() && this.tn.dp().$o().forEach(a => {
          n.dr(a) && t.push(a)
      });
      const r = this.Li;
      t.forEach(a => {
          a.Rn(n, r).forEach(l => {
              l.Oi(null), l.Bi() && e.push(l)
          })
      }), e.forEach(a => a.Oi(a.ki())), this.Li.W().alignLabels && this.kp(e, s)
  }
  kp(e, t) {
      if (this.Lv === null) return;
      const n = this.Lv.height / 2,
          s = e.filter(a => a.ki() <= n),
          r = e.filter(a => a.ki() > n);
      s.sort((a, l) => l.ki() - a.ki()), r.sort((a, l) => a.ki() - l.ki());
      for (const a of e) {
          const l = Math.floor(a.At(t) / 2),
              o = a.ki();
          o > -l && o < l && a.Oi(l), o > this.Lv.height - l && o < this.Lv.height + l && a.Oi(this.Lv.height - l)
      }
      qh(s, 1, this.Lv.height, t), qh(r, -1, this.Lv.height, t)
  }
  wp(e) {
      if (this.Lv === null) return;
      const t = this._p(),
          n = this.lp(),
          s = this.Uv ? "right" : "left";
      t.forEach(r => {
          r.Ai() && r.gt(Q(this.Li)).X(e, n, this.Nv, s)
      })
  }
  gp(e) {
      if (this.Lv === null || this.Li === null) return;
      const t = this.tn.Hv().$t(),
          n = [],
          s = this.tn.dp(),
          r = t.Yc().Rn(s, this.Li);
      r.length && n.push(r);
      const a = this.lp(),
          l = this.Uv ? "right" : "left";
      n.forEach(o => {
          o.forEach(u => {
              u.gt(Q(this.Li)).X(e, a, this.Nv, l)
          })
      })
  }
  Sp(e) {
      this.Xv.style.cursor = e === 1 ? "ns-resize" : "default"
  }
  do() {
      const e = this.ap();
      this.Fv < e && this.tn.Hv().$t().Xl(), this.Fv = e
  }
  op() {
      return qn(this.So.fontSize, this.So.fontFamily)
  }
}

function cE(i, e) {
  var t, n;
  return (n = (t = i._a) === null || t === void 0 ? void 0 : t.call(i, e)) !== null && n !== void 0 ? n : []
}

function vr(i, e) {
  var t, n;
  return (n = (t = i.Pn) === null || t === void 0 ? void 0 : t.call(i, e)) !== null && n !== void 0 ? n : []
}

function hE(i, e) {
  var t, n;
  return (n = (t = i.Ji) === null || t === void 0 ? void 0 : t.call(i, e)) !== null && n !== void 0 ? n : []
}

function dE(i, e) {
  var t, n;
  return (n = (t = i.la) === null || t === void 0 ? void 0 : t.call(i, e)) !== null && n !== void 0 ? n : []
}
class Pu {
  constructor(e, t) {
      this.Lv = Ge({
          width: 0,
          height: 0
      }), this.yp = null, this.Cp = null, this.Tp = null, this.Pp = null, this.Rp = !1, this.Dp = new Ze, this.Vp = new Ze, this.Op = 0, this.Bp = !1, this.Ap = null, this.Ip = !1, this.zp = null, this.Lp = null, this.Wv = !1, this.jv = () => {
          this.Wv || this.Ep === null || this.$i().$h()
      }, this.$v = () => {
          this.Wv || this.Ep === null || this.$i().$h()
      }, this.Jd = e, this.Ep = t, this.Ep.F_().l(this.Np.bind(this), this, !0), this.Fp = document.createElement("td"), this.Fp.style.padding = "0", this.Fp.style.position = "relative";
      const n = document.createElement("div");
      n.style.width = "100%", n.style.height = "100%", n.style.position = "relative", n.style.overflow = "hidden", this.Wp = document.createElement("td"), this.Wp.style.padding = "0", this.jp = document.createElement("td"), this.jp.style.padding = "0", this.Fp.appendChild(n), this.Kv = fn(n, Ge({
          width: 16,
          height: 16
      })), this.Kv.subscribeSuggestedBitmapSizeChanged(this.jv);
      const s = this.Kv.canvasElement;
      s.style.position = "absolute", s.style.zIndex = "1", s.style.left = "0", s.style.top = "0", this.Gv = fn(n, Ge({
          width: 16,
          height: 16
      })), this.Gv.subscribeSuggestedBitmapSizeChanged(this.$v);
      const r = this.Gv.canvasElement;
      r.style.position = "absolute", r.style.zIndex = "2", r.style.left = "0", r.style.top = "0", this.Hp = document.createElement("tr"), this.Hp.appendChild(this.Wp), this.Hp.appendChild(this.Fp), this.Hp.appendChild(this.jp), this.$p(), this.rp = new Lu(this.Gv.canvasElement, this, {
          sv: () => this.Ap === null && !this.Jd.W().handleScroll.vertTouchDrag,
          ev: () => this.Ap === null && !this.Jd.W().handleScroll.horzTouchDrag
      })
  }
  S() {
      this.yp !== null && this.yp.S(), this.Cp !== null && this.Cp.S(), this.Tp = null, this.Gv.unsubscribeSuggestedBitmapSizeChanged(this.$v), pn(this.Gv.canvasElement), this.Gv.dispose(), this.Kv.unsubscribeSuggestedBitmapSizeChanged(this.jv), pn(this.Kv.canvasElement), this.Kv.dispose(), this.Ep !== null && this.Ep.F_().p(this), this.rp.S()
  }
  dp() {
      return Q(this.Ep)
  }
  Up(e) {
      var t, n;
      this.Ep !== null && this.Ep.F_().p(this), this.Ep = e, this.Ep !== null && this.Ep.F_().l(Pu.prototype.Np.bind(this), this, !0), this.$p(), this.Jd.qp().indexOf(this) === this.Jd.qp().length - 1 ? (this.Tp = (t = this.Tp) !== null && t !== void 0 ? t : new lE(this.Fp, this.Jd), this.Tp.bt()) : ((n = this.Tp) === null || n === void 0 || n.tf(), this.Tp = null)
  }
  Hv() {
      return this.Jd
  }
  hp() {
      return this.Hp
  }
  $p() {
      if (this.Ep !== null && (this.Yp(), this.$i().wt().length !== 0)) {
          if (this.yp !== null) {
              const e = this.Ep.P_();
              this.yp.Gi(Q(e))
          }
          if (this.Cp !== null) {
              const e = this.Ep.R_();
              this.Cp.Gi(Q(e))
          }
      }
  }
  Zp() {
      this.yp !== null && this.yp.bt(), this.Cp !== null && this.Cp.bt()
  }
  g_() {
      return this.Ep !== null ? this.Ep.g_() : 0
  }
  M_(e) {
      this.Ep && this.Ep.M_(e)
  }
  Jf(e) {
      if (!this.Ep) return;
      this.Xp();
      const t = e.localX,
          n = e.localY;
      this.Kp(t, n, e)
  }
  mv(e) {
      this.Xp(), this.Gp(), this.Kp(e.localX, e.localY, e)
  }
  Qf(e) {
      var t;
      if (!this.Ep) return;
      this.Xp();
      const n = e.localX,
          s = e.localY;
      this.Kp(n, s, e);
      const r = this.br(n, s);
      this.Jd.Jp((t = r?.zv) !== null && t !== void 0 ? t : null), this.$i().Wc(r && {
          jc: r.jc,
          Av: r.Av
      })
  }
  cv(e) {
      this.Ep !== null && (this.Xp(), this.Qp(e))
  }
  Uf(e) {
      this.Ep !== null && this.tm(this.Vp, e)
  }
  Wf(e) {
      this.Uf(e)
  }
  lv(e) {
      this.Xp(), this.im(e), this.Kp(e.localX, e.localY, e)
  }
  uv(e) {
      this.Ep !== null && (this.Xp(), this.Bp = !1, this.nm(e))
  }
  _v(e) {
      this.Ep !== null && this.Qp(e)
  }
  Pv(e) {
      if (this.Bp = !0, this.Ap === null) {
          const t = {
              x: e.localX,
              y: e.localY
          };
          this.sm(t, t, e)
      }
  }
  Tv(e) {
      this.Ep !== null && (this.Xp(), this.Ep.$t().Wc(null), this.rm())
  }
  hm() {
      return this.Dp
  }
  lm() {
      return this.Vp
  }
  Mv() {
      this.Op = 1, this.$i().Un()
  }
  xv(e, t) {
      if (!this.Jd.W().handleScale.pinch) return;
      const n = 5 * (t - this.Op);
      this.Op = t, this.$i().Jc(e.nt, n)
  }
  vv(e) {
      this.Bp = !1, this.Ip = this.Ap !== null, this.Gp();
      const t = this.$i().Yc();
      this.Ap !== null && t.yt() && (this.zp = {
          x: t.Yt(),
          y: t.Zt()
      }, this.Ap = {
          x: e.localX,
          y: e.localY
      })
  }
  rv(e) {
      if (this.Ep === null) return;
      const t = e.localX,
          n = e.localY;
      if (this.Ap === null) this.im(e);
      else {
          this.Ip = !1;
          const s = Q(this.zp),
              r = s.x + (t - this.Ap.x),
              a = s.y + (n - this.Ap.y);
          this.Kp(r, a, e)
      }
  }
  ov(e) {
      this.Hv().W().trackingMode.exitMode === 0 && (this.Ip = !0), this.am(), this.nm(e)
  }
  br(e, t) {
      const n = this.Ep;
      return n === null ? null : function(s, r, a) {
          const l = s.$o(),
              o = function(u, c, h) {
                  var d, f;
                  let p, g;
                  for (const b of u) {
                      const x = (f = (d = b.fa) === null || d === void 0 ? void 0 : d.call(b, c, h)) !== null && f !== void 0 ? f : [];
                      for (const k of x) w = k.zOrder, (!(y = p?.zOrder) || w === "top" && y !== "top" || w === "normal" && y === "bottom") && (p = k, g = b)
                  }
                  var w, y;
                  return p && g ? {
                      Iv: p,
                      jc: g
                  } : null
              }(l, r, a);
          if (o?.Iv.zOrder === "top") return yr(o);
          for (const u of l) {
              if (o && o.jc === u && o.Iv.zOrder !== "bottom" && !o.Iv.isBackground) return yr(o);
              const c = uE(u.Pn(s), r, a);
              if (c !== null) return {
                  jc: u,
                  Ov: c.Ov,
                  Av: c.Av
              };
              if (o && o.jc === u && o.Iv.zOrder !== "bottom" && o.Iv.isBackground) return yr(o)
          }
          return o?.Iv ? yr(o) : null
      }(n, e, t)
  }
  om(e, t) {
      Q(t === "left" ? this.yp : this.Cp).up(Ge({
          width: e,
          height: this.Lv.height
      }))
  }
  _m() {
      return this.Lv
  }
  up(e) {
      an(this.Lv, e) || (this.Lv = e, this.Wv = !0, this.Kv.resizeCanvasElement(e), this.Gv.resizeCanvasElement(e), this.Wv = !1, this.Fp.style.width = e.width + "px", this.Fp.style.height = e.height + "px")
  }
  um() {
      const e = Q(this.Ep);
      e.T_(e.P_()), e.T_(e.R_());
      for (const t of e.Oa())
          if (e.dr(t)) {
              const n = t.Dt();
              n !== null && e.T_(n), t.Vn()
          }
  }
  Mp() {
      return this.Kv.bitmapSize
  }
  xp(e, t, n) {
      const s = this.Mp();
      s.width > 0 && s.height > 0 && e.drawImage(this.Kv.canvasElement, t, n)
  }
  fp(e) {
      if (e === 0 || this.Ep === null) return;
      if (e > 1 && this.um(), this.yp !== null && this.yp.fp(e), this.Cp !== null && this.Cp.fp(e), e !== 1) {
          this.Kv.applySuggestedBitmapSize();
          const n = hn(this.Kv);
          n !== null && (n.useBitmapCoordinateSpace(s => {
              this.pp(s)
          }), this.Ep && (this.dm(n, cE), this.fm(n), this.vm(n), this.dm(n, vr), this.dm(n, hE)))
      }
      this.Gv.applySuggestedBitmapSize();
      const t = hn(this.Gv);
      t !== null && (t.useBitmapCoordinateSpace(({
          context: n,
          bitmapSize: s
      }) => {
          n.clearRect(0, 0, s.width, s.height)
      }), this.pm(t), this.dm(t, dE))
  }
  bm() {
      return this.yp
  }
  wm() {
      return this.Cp
  }
  mp(e, t) {
      this.dm(e, t)
  }
  Np() {
      this.Ep !== null && this.Ep.F_().p(this), this.Ep = null
  }
  Qp(e) {
      this.tm(this.Dp, e)
  }
  tm(e, t) {
      const n = t.localX,
          s = t.localY;
      e.M() && e.m(this.$i().St().Eu(n), {
          x: n,
          y: s
      }, t)
  }
  pp({
      context: e,
      bitmapSize: t
  }) {
      const {
          width: n,
          height: s
      } = t, r = this.$i(), a = r.q(), l = r.md();
      a === l ? xa(e, 0, 0, n, s, l) : Vp(e, 0, 0, n, s, a, l)
  }
  fm(e) {
      const t = Q(this.Ep).W_().Uh().gt();
      t !== null && t.X(e, !1)
  }
  vm(e) {
      const t = this.$i().qc();
      this.gm(e, vr, _o, t), this.gm(e, vr, $r, t)
  }
  pm(e) {
      this.gm(e, vr, $r, this.$i().Yc())
  }
  dm(e, t) {
      const n = Q(this.Ep).$o();
      for (const s of n) this.gm(e, t, _o, s);
      for (const s of n) this.gm(e, t, $r, s)
  }
  gm(e, t, n, s) {
      const r = Q(this.Ep),
          a = r.$t().Fc(),
          l = a !== null && a.jc === s,
          o = a !== null && l && a.Av !== void 0 ? a.Av.gr : void 0;
      xo(t, u => n(u, e, l, o), s, r)
  }
  Yp() {
      if (this.Ep === null) return;
      const e = this.Jd,
          t = this.Ep.P_().W().visible,
          n = this.Ep.R_().W().visible;
      t || this.yp === null || (this.Wp.removeChild(this.yp.hp()), this.yp.S(), this.yp = null), n || this.Cp === null || (this.jp.removeChild(this.Cp.hp()), this.Cp.S(), this.Cp = null);
      const s = e.$t()._d();
      t && this.yp === null && (this.yp = new Gh(this, e.W(), s, "left"), this.Wp.appendChild(this.yp.hp())), n && this.Cp === null && (this.Cp = new Gh(this, e.W(), s, "right"), this.jp.appendChild(this.Cp.hp()))
  }
  Mm(e) {
      return e.Rv && this.Bp || this.Ap !== null
  }
  xm(e) {
      return Math.max(0, Math.min(e, this.Lv.width - 1))
  }
  Sm(e) {
      return Math.max(0, Math.min(e, this.Lv.height - 1))
  }
  Kp(e, t, n) {
      this.$i().hd(this.xm(e), this.Sm(t), n, Q(this.Ep))
  }
  rm() {
      this.$i().ad()
  }
  am() {
      this.Ip && (this.Ap = null, this.rm())
  }
  sm(e, t, n) {
      this.Ap = e, this.Ip = !1, this.Kp(t.x, t.y, n);
      const s = this.$i().Yc();
      this.zp = {
          x: s.Yt(),
          y: s.Zt()
      }
  }
  $i() {
      return this.Jd.$t()
  }
  nm(e) {
      if (!this.Rp) return;
      const t = this.$i(),
          n = this.dp();
      if (t.I_(n, n.vn()), this.Pp = null, this.Rp = !1, t.sd(), this.Lp !== null) {
          const s = performance.now(),
              r = t.St();
          this.Lp.Dr(r.ju(), s), this.Lp.Ju(s) || t.Zn(this.Lp)
      }
  }
  Xp() {
      this.Ap = null
  }
  Gp() {
      if (!!this.Ep) {
          if (this.$i().Un(), document.activeElement !== document.body && document.activeElement !== document.documentElement) Q(document.activeElement).blur();
          else {
              const e = document.getSelection();
              e !== null && e.removeAllRanges()
          }!this.Ep.vn().Ni() && this.$i().St().Ni()
      }
  }
  im(e) {
      if (this.Ep === null) return;
      const t = this.$i(),
          n = t.St();
      if (n.Ni()) return;
      const s = this.Jd.W(),
          r = s.handleScroll,
          a = s.kineticScroll;
      if ((!r.pressedMouseMove || e.Rv) && (!r.horzTouchDrag && !r.vertTouchDrag || !e.Rv)) return;
      const l = this.Ep.vn(),
          o = performance.now();
      if (this.Pp !== null || this.Mm(e) || (this.Pp = {
              x: e.clientX,
              y: e.clientY,
              Vd: o,
              km: e.localX,
              ym: e.localY
          }), this.Pp !== null && !this.Rp && (this.Pp.x !== e.clientX || this.Pp.y !== e.clientY)) {
          if (e.Rv && a.touch || !e.Rv && a.mouse) {
              const u = n.he();
              this.Lp = new aE(.2 / u, 7 / u, .997, 15 / u), this.Lp.qd(n.ju(), this.Pp.Vd)
          } else this.Lp = null;
          l.Ni() || t.B_(this.Ep, l, e.localY), t.td(e.localX), this.Rp = !0
      }
      this.Rp && (l.Ni() || t.A_(this.Ep, l, e.localY), t.nd(e.localX), this.Lp !== null && this.Lp.qd(n.ju(), o))
  }
}
class Kh {
  constructor(e, t, n, s, r) {
      this.ft = !0, this.Lv = Ge({
          width: 0,
          height: 0
      }), this.jv = () => this.fp(3), this.Uv = e === "left", this.Vc = n._d, this.cn = t, this.Cm = s, this.Tm = r, this.Xv = document.createElement("div"), this.Xv.style.width = "25px", this.Xv.style.height = "100%", this.Xv.style.overflow = "hidden", this.Kv = fn(this.Xv, Ge({
          width: 16,
          height: 16
      })), this.Kv.subscribeSuggestedBitmapSizeChanged(this.jv)
  }
  S() {
      this.Kv.unsubscribeSuggestedBitmapSizeChanged(this.jv), pn(this.Kv.canvasElement), this.Kv.dispose()
  }
  hp() {
      return this.Xv
  }
  _m() {
      return this.Lv
  }
  up(e) {
      an(this.Lv, e) || (this.Lv = e, this.Kv.resizeCanvasElement(e), this.Xv.style.width = `${e.width}px`, this.Xv.style.height = `${e.height}px`, this.ft = !0)
  }
  fp(e) {
      if (e < 3 && !this.ft || this.Lv.width === 0 || this.Lv.height === 0) return;
      this.ft = !1, this.Kv.applySuggestedBitmapSize();
      const t = hn(this.Kv);
      t !== null && t.useBitmapCoordinateSpace(n => {
          this.pp(n), this.Ae(n)
      })
  }
  Mp() {
      return this.Kv.bitmapSize
  }
  xp(e, t, n) {
      const s = this.Mp();
      s.width > 0 && s.height > 0 && e.drawImage(this.Kv.canvasElement, t, n)
  }
  Ae({
      context: e,
      bitmapSize: t,
      horizontalPixelRatio: n,
      verticalPixelRatio: s
  }) {
      if (!this.Cm()) return;
      e.fillStyle = this.cn.timeScale.borderColor;
      const r = Math.floor(this.Vc.W().C * n),
          a = Math.floor(this.Vc.W().C * s),
          l = this.Uv ? t.width - r : 0;
      e.fillRect(l, 0, r, a)
  }
  pp({
      context: e,
      bitmapSize: t
  }) {
      xa(e, 0, 0, t.width, t.height, this.Tm())
  }
}

function Iu(i) {
  return e => {
      var t, n;
      return (n = (t = e.da) === null || t === void 0 ? void 0 : t.call(e, i)) !== null && n !== void 0 ? n : []
  }
}
const fE = Iu("normal"),
  pE = Iu("top"),
  mE = Iu("bottom");
class gE {
  constructor(e, t) {
      this.Pm = null, this.Rm = null, this.k = null, this.Dm = !1, this.Lv = Ge({
          width: 0,
          height: 0
      }), this.Vm = new Ze, this.Nv = new Ds(5), this.Wv = !1, this.jv = () => {
          this.Wv || this.Jd.$t().$h()
      }, this.$v = () => {
          this.Wv || this.Jd.$t().$h()
      }, this.Jd = e, this.U_ = t, this.cn = e.W().layout, this.Zd = document.createElement("tr"), this.Om = document.createElement("td"), this.Om.style.padding = "0", this.Bm = document.createElement("td"), this.Bm.style.padding = "0", this.Xv = document.createElement("td"), this.Xv.style.height = "25px", this.Xv.style.padding = "0", this.Am = document.createElement("div"), this.Am.style.width = "100%", this.Am.style.height = "100%", this.Am.style.position = "relative", this.Am.style.overflow = "hidden", this.Xv.appendChild(this.Am), this.Kv = fn(this.Am, Ge({
          width: 16,
          height: 16
      })), this.Kv.subscribeSuggestedBitmapSizeChanged(this.jv);
      const n = this.Kv.canvasElement;
      n.style.position = "absolute", n.style.zIndex = "1", n.style.left = "0", n.style.top = "0", this.Gv = fn(this.Am, Ge({
          width: 16,
          height: 16
      })), this.Gv.subscribeSuggestedBitmapSizeChanged(this.$v);
      const s = this.Gv.canvasElement;
      s.style.position = "absolute", s.style.zIndex = "2", s.style.left = "0", s.style.top = "0", this.Zd.appendChild(this.Om), this.Zd.appendChild(this.Xv), this.Zd.appendChild(this.Bm), this.Im(), this.Jd.$t().w_().l(this.Im.bind(this), this), this.rp = new Lu(this.Gv.canvasElement, this, {
          sv: () => !0,
          ev: () => !this.Jd.W().handleScroll.horzTouchDrag
      })
  }
  S() {
      this.rp.S(), this.Pm !== null && this.Pm.S(), this.Rm !== null && this.Rm.S(), this.Gv.unsubscribeSuggestedBitmapSizeChanged(this.$v), pn(this.Gv.canvasElement), this.Gv.dispose(), this.Kv.unsubscribeSuggestedBitmapSizeChanged(this.jv), pn(this.Kv.canvasElement), this.Kv.dispose()
  }
  hp() {
      return this.Zd
  }
  zm() {
      return this.Pm
  }
  Lm() {
      return this.Rm
  }
  mv(e) {
      if (this.Dm) return;
      this.Dm = !0;
      const t = this.Jd.$t();
      !t.St().Ni() && this.Jd.W().handleScale.axisPressedMouseMove.time && t.Gc(e.localX)
  }
  vv(e) {
      this.mv(e)
  }
  bv() {
      const e = this.Jd.$t();
      !e.St().Ni() && this.Dm && (this.Dm = !1, this.Jd.W().handleScale.axisPressedMouseMove.time && e.rd())
  }
  lv(e) {
      const t = this.Jd.$t();
      !t.St().Ni() && this.Jd.W().handleScale.axisPressedMouseMove.time && t.ed(e.localX)
  }
  rv(e) {
      this.lv(e)
  }
  uv() {
      this.Dm = !1;
      const e = this.Jd.$t();
      e.St().Ni() && !this.Jd.W().handleScale.axisPressedMouseMove.time || e.rd()
  }
  ov() {
      this.uv()
  }
  Uf() {
      this.Jd.W().handleScale.axisDoubleClickReset.time && this.Jd.$t().Kn()
  }
  Wf() {
      this.Uf()
  }
  Jf() {
      this.Jd.$t().W().handleScale.axisPressedMouseMove.time && this.Sp(1)
  }
  Tv() {
      this.Sp(0)
  }
  _m() {
      return this.Lv
  }
  Em() {
      return this.Vm
  }
  Nm(e, t, n) {
      an(this.Lv, e) || (this.Lv = e, this.Wv = !0, this.Kv.resizeCanvasElement(e), this.Gv.resizeCanvasElement(e), this.Wv = !1, this.Xv.style.width = `${e.width}px`, this.Xv.style.height = `${e.height}px`, this.Vm.m(e)), this.Pm !== null && this.Pm.up(Ge({
          width: t,
          height: e.height
      })), this.Rm !== null && this.Rm.up(Ge({
          width: n,
          height: e.height
      }))
  }
  Fm() {
      const e = this.Wm();
      return Math.ceil(e.C + e.T + e.P + e.L + e.B + e.jm)
  }
  bt() {
      this.Jd.$t().St().ja()
  }
  Mp() {
      return this.Kv.bitmapSize
  }
  xp(e, t, n) {
      const s = this.Mp();
      s.width > 0 && s.height > 0 && e.drawImage(this.Kv.canvasElement, t, n)
  }
  fp(e) {
      if (e === 0) return;
      if (e !== 1) {
          this.Kv.applySuggestedBitmapSize();
          const n = hn(this.Kv);
          n !== null && (n.useBitmapCoordinateSpace(s => {
              this.pp(s), this.Ae(s), this.Hm(n, mE)
          }), this.bp(n), this.Hm(n, fE)), this.Pm !== null && this.Pm.fp(e), this.Rm !== null && this.Rm.fp(e)
      }
      this.Gv.applySuggestedBitmapSize();
      const t = hn(this.Gv);
      t !== null && (t.useBitmapCoordinateSpace(({
          context: n,
          bitmapSize: s
      }) => {
          n.clearRect(0, 0, s.width, s.height)
      }), this.$m([...this.Jd.$t().wt(), this.Jd.$t().Yc()], t), this.Hm(t, pE))
  }
  Hm(e, t) {
      const n = this.Jd.$t().wt();
      for (const s of n) xo(t, r => _o(r, e, !1, void 0), s, void 0);
      for (const s of n) xo(t, r => $r(r, e, !1, void 0), s, void 0)
  }
  pp({
      context: e,
      bitmapSize: t
  }) {
      xa(e, 0, 0, t.width, t.height, this.Jd.$t().md())
  }
  Ae({
      context: e,
      bitmapSize: t,
      verticalPixelRatio: n
  }) {
      if (this.Jd.W().timeScale.borderVisible) {
          e.fillStyle = this.Um();
          const s = Math.max(1, Math.floor(this.Wm().C * n));
          e.fillRect(0, 0, t.width, s)
      }
  }
  bp(e) {
      const t = this.Jd.$t().St(),
          n = t.ja();
      if (!n || n.length === 0) return;
      const s = this.U_.maxTickMarkWeight(n),
          r = this.Wm(),
          a = t.W();
      a.borderVisible && a.ticksVisible && e.useBitmapCoordinateSpace(({
          context: l,
          horizontalPixelRatio: o,
          verticalPixelRatio: u
      }) => {
          l.strokeStyle = this.Um(), l.fillStyle = this.Um();
          const c = Math.max(1, Math.floor(o)),
              h = Math.floor(.5 * o);
          l.beginPath();
          const d = Math.round(r.T * u);
          for (let f = n.length; f--;) {
              const p = Math.round(n[f].coord * o);
              l.rect(p - h, 0, c, d)
          }
          l.fill()
      }), e.useMediaCoordinateSpace(({
          context: l
      }) => {
          const o = r.C + r.T + r.L + r.P / 2;
          l.textAlign = "center", l.textBaseline = "middle", l.fillStyle = this.$(), l.font = this.op();
          for (const u of n)
              if (u.weight < s) {
                  const c = u.needAlignCoordinate ? this.qm(l, u.coord, u.label) : u.coord;
                  l.fillText(u.label, c, o)
              } this.Jd.W().timeScale.allowBoldLabels && (l.font = this.Ym());
          for (const u of n)
              if (u.weight >= s) {
                  const c = u.needAlignCoordinate ? this.qm(l, u.coord, u.label) : u.coord;
                  l.fillText(u.label, c, o)
              }
      })
  }
  qm(e, t, n) {
      const s = this.Nv.xi(e, n),
          r = s / 2,
          a = Math.floor(t - r) + .5;
      return a < 0 ? t += Math.abs(0 - a) : a + s > this.Lv.width && (t -= Math.abs(this.Lv.width - (a + s))), t
  }
  $m(e, t) {
      const n = this.Wm();
      for (const s of e)
          for (const r of s.Qi()) r.gt().X(t, n)
  }
  Um() {
      return this.Jd.W().timeScale.borderColor
  }
  $() {
      return this.cn.textColor
  }
  j() {
      return this.cn.fontSize
  }
  op() {
      return qn(this.j(), this.cn.fontFamily)
  }
  Ym() {
      return qn(this.j(), this.cn.fontFamily, "bold")
  }
  Wm() {
      this.k === null && (this.k = {
          C: 1,
          N: NaN,
          L: NaN,
          B: NaN,
          ji: NaN,
          T: 5,
          P: NaN,
          R: "",
          Wi: new Ds,
          jm: 0
      });
      const e = this.k,
          t = this.op();
      if (e.R !== t) {
          const n = this.j();
          e.P = n, e.R = t, e.L = 3 * n / 12, e.B = 3 * n / 12, e.ji = 9 * n / 12, e.N = 0, e.jm = 4 * n / 12, e.Wi.ir()
      }
      return this.k
  }
  Sp(e) {
      this.Xv.style.cursor = e === 1 ? "ew-resize" : "default"
  }
  Im() {
      const e = this.Jd.$t(),
          t = e.W();
      t.leftPriceScale.visible || this.Pm === null || (this.Om.removeChild(this.Pm.hp()), this.Pm.S(), this.Pm = null), t.rightPriceScale.visible || this.Rm === null || (this.Bm.removeChild(this.Rm.hp()), this.Rm.S(), this.Rm = null);
      const n = {
              _d: this.Jd.$t()._d()
          },
          s = () => t.leftPriceScale.borderVisible && e.St().W().borderVisible,
          r = () => e.md();
      t.leftPriceScale.visible && this.Pm === null && (this.Pm = new Kh("left", t, n, s, r), this.Om.appendChild(this.Pm.hp())), t.rightPriceScale.visible && this.Rm === null && (this.Rm = new Kh("right", t, n, s, r), this.Bm.appendChild(this.Rm.hp()))
  }
}
const yE = !!Gn && !!navigator.userAgentData && navigator.userAgentData.brands.some(i => i.brand.includes("Chromium")) && !!Gn && (!((Al = navigator?.userAgentData) === null || Al === void 0) && Al.platform ? navigator.userAgentData.platform === "Windows" : navigator.userAgent.toLowerCase().indexOf("win") >= 0);
var Al;
class vE {
  constructor(e, t, n) {
      var s;
      this.Zm = [], this.Xm = 0, this.ro = 0, this.o_ = 0, this.Km = 0, this.Gm = 0, this.Jm = null, this.Qm = !1, this.Dp = new Ze, this.Vp = new Ze, this.Pc = new Ze, this.tb = null, this.ib = null, this.Gd = e, this.cn = t, this.U_ = n, this.Zd = document.createElement("div"), this.Zd.classList.add("tv-lightweight-charts"), this.Zd.style.overflow = "hidden", this.Zd.style.direction = "ltr", this.Zd.style.width = "100%", this.Zd.style.height = "100%", (s = this.Zd).style.userSelect = "none", s.style.webkitUserSelect = "none", s.style.msUserSelect = "none", s.style.MozUserSelect = "none", s.style.webkitTapHighlightColor = "transparent", this.nb = document.createElement("table"), this.nb.setAttribute("cellspacing", "0"), this.Zd.appendChild(this.nb), this.sb = this.eb.bind(this), Vl(this.cn) && this.rb(!0), this.$i = new tE(this.Dc.bind(this), this.cn, n), this.$t().Zc().l(this.hb.bind(this), this), this.lb = new gE(this, this.U_), this.nb.appendChild(this.lb.hp());
      const r = t.autoSize && this.ab();
      let a = this.cn.width,
          l = this.cn.height;
      if (r || a === 0 || l === 0) {
          const o = e.getBoundingClientRect();
          a = a || o.width, l = l || o.height
      }
      this.ob(a, l), this._b(), e.appendChild(this.Zd), this.ub(), this.$i.St().sc().l(this.$i.Xl.bind(this.$i), this), this.$i.w_().l(this.$i.Xl.bind(this.$i), this)
  }
  $t() {
      return this.$i
  }
  W() {
      return this.cn
  }
  qp() {
      return this.Zm
  }
  cb() {
      return this.lb
  }
  S() {
      this.rb(!1), this.Xm !== 0 && window.cancelAnimationFrame(this.Xm), this.$i.Zc().p(this), this.$i.St().sc().p(this), this.$i.w_().p(this), this.$i.S();
      for (const e of this.Zm) this.nb.removeChild(e.hp()), e.hm().p(this), e.lm().p(this), e.S();
      this.Zm = [], Q(this.lb).S(), this.Zd.parentElement !== null && this.Zd.parentElement.removeChild(this.Zd), this.Pc.S(), this.Dp.S(), this.Vp.S(), this.fb()
  }
  ob(e, t, n = !1) {
      if (this.ro === t && this.o_ === e) return;
      const s = function(l) {
          const o = Math.floor(l.width),
              u = Math.floor(l.height);
          return Ge({
              width: o - o % 2,
              height: u - u % 2
          })
      }(Ge({
          width: e,
          height: t
      }));
      this.ro = s.height, this.o_ = s.width;
      const r = this.ro + "px",
          a = this.o_ + "px";
      Q(this.Zd).style.height = r, Q(this.Zd).style.width = a, this.nb.style.height = r, this.nb.style.width = a, n ? this.pb(ht.es(), performance.now()) : this.$i.Xl()
  }
  fp(e) {
      e === void 0 && (e = ht.es());
      for (let t = 0; t < this.Zm.length; t++) this.Zm[t].fp(e.Hn(t).Fn);
      this.cn.timeScale.visible && this.lb.fp(e.jn())
  }
  Hh(e) {
      const t = Vl(this.cn);
      this.$i.Hh(e);
      const n = Vl(this.cn);
      n !== t && this.rb(n), this.ub(), this.mb(e)
  }
  hm() {
      return this.Dp
  }
  lm() {
      return this.Vp
  }
  Zc() {
      return this.Pc
  }
  bb() {
      this.Jm !== null && (this.pb(this.Jm, performance.now()), this.Jm = null);
      const e = this.wb(null),
          t = document.createElement("canvas");
      t.width = e.width, t.height = e.height;
      const n = Q(t.getContext("2d"));
      return this.wb(n), t
  }
  gb(e) {
      return e === "left" && !this.Mb() || e === "right" && !this.xb() || this.Zm.length === 0 ? 0 : Q(e === "left" ? this.Zm[0].bm() : this.Zm[0].wm()).cp()
  }
  Sb() {
      return this.cn.autoSize && this.tb !== null
  }
  kb() {
      return this.Zd
  }
  Jp(e) {
      this.ib = e, this.ib ? this.kb().style.setProperty("cursor", e) : this.kb().style.removeProperty("cursor")
  }
  yb() {
      return this.ib
  }
  Cb() {
      return xt(this.Zm[0])._m()
  }
  mb(e) {
      (e.autoSize !== void 0 || !this.tb || e.width === void 0 && e.height === void 0) && (e.autoSize && !this.tb && this.ab(), e.autoSize === !1 && this.tb !== null && this.fb(), e.autoSize || e.width === void 0 && e.height === void 0 || this.ob(e.width || this.o_, e.height || this.ro))
  }
  wb(e) {
      let t = 0,
          n = 0;
      const s = this.Zm[0],
          r = (l, o) => {
              let u = 0;
              for (let c = 0; c < this.Zm.length; c++) {
                  const h = this.Zm[c],
                      d = Q(l === "left" ? h.bm() : h.wm()),
                      f = d.Mp();
                  e !== null && d.xp(e, o, u), u += f.height
              }
          };
      this.Mb() && (r("left", 0), t += Q(s.bm()).Mp().width);
      for (let l = 0; l < this.Zm.length; l++) {
          const o = this.Zm[l],
              u = o.Mp();
          e !== null && o.xp(e, t, n), n += u.height
      }
      t += s.Mp().width, this.xb() && (r("right", t), t += Q(s.wm()).Mp().width);
      const a = (l, o, u) => {
          Q(l === "left" ? this.lb.zm() : this.lb.Lm()).xp(Q(e), o, u)
      };
      if (this.cn.timeScale.visible) {
          const l = this.lb.Mp();
          if (e !== null) {
              let o = 0;
              this.Mb() && (a("left", o, n), o = Q(s.bm()).Mp().width), this.lb.xp(e, o, n), o += l.width, this.xb() && a("right", o, n)
          }
          n += l.height
      }
      return Ge({
          width: t,
          height: n
      })
  }
  Tb() {
      let e = 0,
          t = 0,
          n = 0;
      for (const p of this.Zm) this.Mb() && (t = Math.max(t, Q(p.bm()).ap(), this.cn.leftPriceScale.minimumWidth)), this.xb() && (n = Math.max(n, Q(p.wm()).ap(), this.cn.rightPriceScale.minimumWidth)), e += p.g_();
      t = ko(t), n = ko(n);
      const s = this.o_,
          r = this.ro,
          a = Math.max(s - t - n, 0),
          l = this.cn.timeScale.visible;
      let o = l ? Math.max(this.lb.Fm(), this.cn.timeScale.minimumHeight) : 0;
      var u;
      o = (u = o) + u % 2;
      const c = 0 + o,
          h = r < c ? 0 : r - c,
          d = h / e;
      let f = 0;
      for (let p = 0; p < this.Zm.length; ++p) {
          const g = this.Zm[p];
          g.Up(this.$i.Uc()[p]);
          let w = 0,
              y = 0;
          y = p === this.Zm.length - 1 ? h - f : Math.round(g.g_() * d), w = Math.max(y, 2), f += w, g.up(Ge({
              width: a,
              height: w
          })), this.Mb() && g.om(t, "left"), this.xb() && g.om(n, "right"), g.dp() && this.$i.Xc(g.dp(), w)
      }
      this.lb.Nm(Ge({
          width: l ? a : 0,
          height: o
      }), l ? t : 0, l ? n : 0), this.$i.x_(a), this.Km !== t && (this.Km = t), this.Gm !== n && (this.Gm = n)
  }
  rb(e) {
      e ? this.Zd.addEventListener("wheel", this.sb, {
          passive: !1
      }) : this.Zd.removeEventListener("wheel", this.sb)
  }
  Pb(e) {
      switch (e.deltaMode) {
          case e.DOM_DELTA_PAGE:
              return 120;
          case e.DOM_DELTA_LINE:
              return 32
      }
      return yE ? 1 / window.devicePixelRatio : 1
  }
  eb(e) {
      if (!(e.deltaX !== 0 && this.cn.handleScroll.mouseWheel || e.deltaY !== 0 && this.cn.handleScale.mouseWheel)) return;
      const t = this.Pb(e),
          n = t * e.deltaX / 100,
          s = -t * e.deltaY / 100;
      if (e.cancelable && e.preventDefault(), s !== 0 && this.cn.handleScale.mouseWheel) {
          const r = Math.sign(s) * Math.min(1, Math.abs(s)),
              a = e.clientX - this.Zd.getBoundingClientRect().left;
          this.$t().Jc(a, r)
      }
      n !== 0 && this.cn.handleScroll.mouseWheel && this.$t().Qc(-80 * n)
  }
  pb(e, t) {
      var n;
      const s = e.jn();
      s === 3 && this.Rb(), s !== 3 && s !== 2 || (this.Db(e), this.Vb(e, t), this.lb.bt(), this.Zm.forEach(r => {
          r.Zp()
      }), ((n = this.Jm) === null || n === void 0 ? void 0 : n.jn()) === 3 && (this.Jm.ts(e), this.Rb(), this.Db(this.Jm), this.Vb(this.Jm, t), e = this.Jm, this.Jm = null)), this.fp(e)
  }
  Vb(e, t) {
      for (const n of e.Qn()) this.ns(n, t)
  }
  Db(e) {
      const t = this.$i.Uc();
      for (let n = 0; n < t.length; n++) e.Hn(n).Wn && t[n].E_()
  }
  ns(e, t) {
      const n = this.$i.St();
      switch (e.qn) {
          case 0:
              n.rc();
              break;
          case 1:
              n.hc(e.Vt);
              break;
          case 2:
              n.Gn(e.Vt);
              break;
          case 3:
              n.Jn(e.Vt);
              break;
          case 4:
              n.Uu();
              break;
          case 5:
              e.Vt.Ju(t) || n.Jn(e.Vt.Qu(t))
      }
  }
  Dc(e) {
      this.Jm !== null ? this.Jm.ts(e) : this.Jm = e, this.Qm || (this.Qm = !0, this.Xm = window.requestAnimationFrame(t => {
          if (this.Qm = !1, this.Xm = 0, this.Jm !== null) {
              const n = this.Jm;
              this.Jm = null, this.pb(n, t);
              for (const s of n.Qn())
                  if (s.qn === 5 && !s.Vt.Ju(t)) {
                      this.$t().Zn(s.Vt);
                      break
                  }
          }
      }))
  }
  Rb() {
      this._b()
  }
  _b() {
      const e = this.$i.Uc(),
          t = e.length,
          n = this.Zm.length;
      for (let s = t; s < n; s++) {
          const r = xt(this.Zm.pop());
          this.nb.removeChild(r.hp()), r.hm().p(this), r.lm().p(this), r.S()
      }
      for (let s = n; s < t; s++) {
          const r = new Pu(this, e[s]);
          r.hm().l(this.Ob.bind(this), this), r.lm().l(this.Bb.bind(this), this), this.Zm.push(r), this.nb.insertBefore(r.hp(), this.lb.hp())
      }
      for (let s = 0; s < t; s++) {
          const r = e[s],
              a = this.Zm[s];
          a.dp() !== r ? a.Up(r) : a.$p()
      }
      this.ub(), this.Tb()
  }
  Ab(e, t, n) {
      var s;
      const r = new Map;
      e !== null && this.$i.wt().forEach(c => {
          const h = c.In().hl(e);
          h !== null && r.set(c, h)
      });
      let a;
      if (e !== null) {
          const c = (s = this.$i.St().Ui(e)) === null || s === void 0 ? void 0 : s.originalTime;
          c !== void 0 && (a = c)
      }
      const l = this.$t().Fc(),
          o = l !== null && l.jc instanceof Cu ? l.jc : void 0,
          u = l !== null && l.Av !== void 0 ? l.Av.wr : void 0;
      return {
          Ib: a,
          se: e ?? void 0,
          zb: t ?? void 0,
          Lb: o,
          Eb: r,
          Nb: u,
          Fb: n ?? void 0
      }
  }
  Ob(e, t, n) {
      this.Dp.m(() => this.Ab(e, t, n))
  }
  Bb(e, t, n) {
      this.Vp.m(() => this.Ab(e, t, n))
  }
  hb(e, t, n) {
      this.Pc.m(() => this.Ab(e, t, n))
  }
  ub() {
      const e = this.cn.timeScale.visible ? "" : "none";
      this.lb.hp().style.display = e
  }
  Mb() {
      return this.Zm[0].dp().P_().W().visible
  }
  xb() {
      return this.Zm[0].dp().R_().W().visible
  }
  ab() {
      return "ResizeObserver" in window && (this.tb = new ResizeObserver(e => {
          const t = e.find(n => n.target === this.Gd);
          t && this.ob(t.contentRect.width, t.contentRect.height)
      }), this.tb.observe(this.Gd, {
          box: "border-box"
      }), !0)
  }
  fb() {
      this.tb !== null && this.tb.disconnect(), this.tb = null
  }
}

function Vl(i) {
  return Boolean(i.handleScroll.mouseWheel || i.handleScale.mouseWheel)
}

function bE(i) {
  return function(e) {
      return e.open !== void 0
  }(i) || function(e) {
      return e.value !== void 0
  }(i)
}

function rm(i, e) {
  var t = {};
  for (var n in i) Object.prototype.hasOwnProperty.call(i, n) && e.indexOf(n) < 0 && (t[n] = i[n]);
  if (i != null && typeof Object.getOwnPropertySymbols == "function") {
      var s = 0;
      for (n = Object.getOwnPropertySymbols(i); s < n.length; s++) e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(i, n[s]) && (t[n[s]] = i[n[s]])
  }
  return t
}

function Xh(i, e, t, n) {
  const s = t.value,
      r = {
          se: e,
          ot: i,
          Vt: [s, s, s, s],
          Ib: n
      };
  return t.color !== void 0 && (r.V = t.color), r
}

function wE(i, e, t, n) {
  const s = t.value,
      r = {
          se: e,
          ot: i,
          Vt: [s, s, s, s],
          Ib: n
      };
  return t.lineColor !== void 0 && (r.lt = t.lineColor), t.topColor !== void 0 && (r.Ts = t.topColor), t.bottomColor !== void 0 && (r.Ps = t.bottomColor), r
}

function kE(i, e, t, n) {
  const s = t.value,
      r = {
          se: e,
          ot: i,
          Vt: [s, s, s, s],
          Ib: n
      };
  return t.topLineColor !== void 0 && (r.Pe = t.topLineColor), t.bottomLineColor !== void 0 && (r.Re = t.bottomLineColor), t.topFillColor1 !== void 0 && (r.Se = t.topFillColor1), t.topFillColor2 !== void 0 && (r.ke = t.topFillColor2), t.bottomFillColor1 !== void 0 && (r.ye = t.bottomFillColor1), t.bottomFillColor2 !== void 0 && (r.Ce = t.bottomFillColor2), r
}

function _E(i, e, t, n) {
  const s = {
      se: e,
      ot: i,
      Vt: [t.open, t.high, t.low, t.close],
      Ib: n
  };
  return t.color !== void 0 && (s.V = t.color), s
}

function xE(i, e, t, n) {
  const s = {
      se: e,
      ot: i,
      Vt: [t.open, t.high, t.low, t.close],
      Ib: n
  };
  return t.color !== void 0 && (s.V = t.color), t.borderColor !== void 0 && (s.Ot = t.borderColor), t.wickColor !== void 0 && (s.Zh = t.wickColor), s
}

function TE(i, e, t, n, s) {
  const r = xt(s)(t),
      a = Math.max(...r),
      l = Math.min(...r),
      o = r[r.length - 1],
      u = [o, a, l, o],
      c = t,
      {
          time: h,
          color: d
      } = c;
  return {
      se: e,
      ot: i,
      Vt: u,
      Ib: n,
      He: rm(c, ["time", "color"]),
      V: d
  }
}

function br(i) {
  return i.Vt !== void 0
}

function Jh(i, e) {
  return e.customValues !== void 0 && (i.Wb = e.customValues), i
}

function en(i) {
  return (e, t, n, s, r, a) => function(l, o) {
      return o ? o(l) : (u = l).open === void 0 && u.value === void 0;
      var u
  }(n, a) ? Jh({
      ot: e,
      se: t,
      Ib: s
  }, n) : Jh(i(e, t, n, s, r), n)
}

function Yh(i) {
  return {
      Candlestick: en(xE),
      Bar: en(_E),
      Area: en(wE),
      Baseline: en(kE),
      Histogram: en(Xh),
      Line: en(Xh),
      Custom: en(TE)
  } [i]
}

function Qh(i) {
  return {
      se: 0,
      jb: new Map,
      ha: i
  }
}

function Zh(i, e) {
  if (i !== void 0 && i.length !== 0) return {
      Hb: e.key(i[0].ot),
      $b: e.key(i[i.length - 1].ot)
  }
}

function ed(i) {
  let e;
  return i.forEach(t => {
      e === void 0 && (e = t.Ib)
  }), xt(e)
}
class SE {
  constructor(e) {
      this.Ub = new Map, this.qb = new Map, this.Yb = new Map, this.Zb = [], this.U_ = e
  }
  S() {
      this.Ub.clear(), this.qb.clear(), this.Yb.clear(), this.Zb = []
  }
  Xb(e, t) {
      let n = this.Ub.size !== 0,
          s = !1;
      const r = this.qb.get(e);
      if (r !== void 0)
          if (this.qb.size === 1) n = !1, s = !0, this.Ub.clear();
          else
              for (const o of this.Zb) o.pointData.jb.delete(e) && (s = !0);
      let a = [];
      if (t.length !== 0) {
          const o = t.map(f => f.time),
              u = this.U_.createConverterToInternalObj(t),
              c = Yh(e.Jh()),
              h = e.ya(),
              d = e.Ca();
          a = t.map((f, p) => {
              const g = u(f.time),
                  w = this.U_.key(g);
              let y = this.Ub.get(w);
              y === void 0 && (y = Qh(g), this.Ub.set(w, y), s = !0);
              const b = c(g, y.se, f, o[p], h, d);
              return y.jb.set(e, b), b
          })
      }
      n && this.Kb(), this.Gb(e, a);
      let l = -1;
      if (s) {
          const o = [];
          this.Ub.forEach(u => {
              o.push({
                  timeWeight: 0,
                  time: u.ha,
                  pointData: u,
                  originalTime: ed(u.jb)
              })
          }), o.sort((u, c) => this.U_.key(u.time) - this.U_.key(c.time)), l = this.Jb(o)
      }
      return this.Qb(e, l, function(o, u, c) {
          const h = Zh(o, c),
              d = Zh(u, c);
          if (h !== void 0 && d !== void 0) return {
              Ql: h.$b >= d.$b && h.Hb >= d.Hb
          }
      }(this.qb.get(e), r, this.U_))
  }
  fd(e) {
      return this.Xb(e, [])
  }
  tw(e, t) {
      const n = t;
      (function(g) {
          g.Ib === void 0 && (g.Ib = g.time)
      })(n), this.U_.preprocessData(t);
      const s = this.U_.createConverterToInternalObj([t])(t.time),
          r = this.Yb.get(e);
      if (r !== void 0 && this.U_.key(s) < this.U_.key(r)) throw new Error(`Cannot update oldest data, last time=${r}, new time=${s}`);
      let a = this.Ub.get(this.U_.key(s));
      const l = a === void 0;
      a === void 0 && (a = Qh(s), this.Ub.set(this.U_.key(s), a));
      const o = Yh(e.Jh()),
          u = e.ya(),
          c = e.Ca(),
          h = o(s, a.se, t, n.Ib, u, c);
      a.jb.set(e, h), this.iw(e, h);
      const d = {
          Ql: br(h)
      };
      if (!l) return this.Qb(e, -1, d);
      const f = {
              timeWeight: 0,
              time: a.ha,
              pointData: a,
              originalTime: ed(a.jb)
          },
          p = Xs(this.Zb, this.U_.key(f.time), (g, w) => this.U_.key(g.time) < w);
      this.Zb.splice(p, 0, f);
      for (let g = p; g < this.Zb.length; ++g) zl(this.Zb[g].pointData, g);
      return this.U_.fillWeightsForPoints(this.Zb, p), this.Qb(e, p, d)
  }
  iw(e, t) {
      let n = this.qb.get(e);
      n === void 0 && (n = [], this.qb.set(e, n));
      const s = n.length !== 0 ? n[n.length - 1] : null;
      s === null || this.U_.key(t.ot) > this.U_.key(s.ot) ? br(t) && n.push(t) : br(t) ? n[n.length - 1] = t : n.splice(-1, 1), this.Yb.set(e, t.ot)
  }
  Gb(e, t) {
      t.length !== 0 ? (this.qb.set(e, t.filter(br)), this.Yb.set(e, t[t.length - 1].ot)) : (this.qb.delete(e), this.Yb.delete(e))
  }
  Kb() {
      for (const e of this.Zb) e.pointData.jb.size === 0 && this.Ub.delete(this.U_.key(e.time))
  }
  Jb(e) {
      let t = -1;
      for (let n = 0; n < this.Zb.length && n < e.length; ++n) {
          const s = this.Zb[n],
              r = e[n];
          if (this.U_.key(s.time) !== this.U_.key(r.time)) {
              t = n;
              break
          }
          r.timeWeight = s.timeWeight, zl(r.pointData, n)
      }
      if (t === -1 && this.Zb.length !== e.length && (t = Math.min(this.Zb.length, e.length)), t === -1) return -1;
      for (let n = t; n < e.length; ++n) zl(e[n].pointData, n);
      return this.U_.fillWeightsForPoints(e, t), this.Zb = e, t
  }
  nw() {
      if (this.qb.size === 0) return null;
      let e = 0;
      return this.qb.forEach(t => {
          t.length !== 0 && (e = Math.max(e, t[t.length - 1].se))
      }), e
  }
  Qb(e, t, n) {
      const s = {
          sw: new Map,
          St: {
              Lu: this.nw()
          }
      };
      if (t !== -1) this.qb.forEach((r, a) => {
          s.sw.set(a, {
              He: r,
              ew: a === e ? n : void 0
          })
      }), this.qb.has(e) || s.sw.set(e, {
          He: [],
          ew: n
      }), s.St.rw = this.Zb, s.St.hw = t;
      else {
          const r = this.qb.get(e);
          s.sw.set(e, {
              He: r || [],
              ew: n
          })
      }
      return s
  }
}

function zl(i, e) {
  i.se = e, i.jb.forEach(t => {
      t.se = e
  })
}

function Nu(i) {
  const e = {
      value: i.Vt[3],
      time: i.Ib
  };
  return i.Wb !== void 0 && (e.customValues = i.Wb), e
}

function td(i) {
  const e = Nu(i);
  return i.V !== void 0 && (e.color = i.V), e
}

function EE(i) {
  const e = Nu(i);
  return i.lt !== void 0 && (e.lineColor = i.lt), i.Ts !== void 0 && (e.topColor = i.Ts), i.Ps !== void 0 && (e.bottomColor = i.Ps), e
}

function CE(i) {
  const e = Nu(i);
  return i.Pe !== void 0 && (e.topLineColor = i.Pe), i.Re !== void 0 && (e.bottomLineColor = i.Re), i.Se !== void 0 && (e.topFillColor1 = i.Se), i.ke !== void 0 && (e.topFillColor2 = i.ke), i.ye !== void 0 && (e.bottomFillColor1 = i.ye), i.Ce !== void 0 && (e.bottomFillColor2 = i.Ce), e
}

function am(i) {
  const e = {
      open: i.Vt[0],
      high: i.Vt[1],
      low: i.Vt[2],
      close: i.Vt[3],
      time: i.Ib
  };
  return i.Wb !== void 0 && (e.customValues = i.Wb), e
}

function $E(i) {
  const e = am(i);
  return i.V !== void 0 && (e.color = i.V), e
}

function LE(i) {
  const e = am(i),
      {
          V: t,
          Ot: n,
          Zh: s
      } = i;
  return t !== void 0 && (e.color = t), n !== void 0 && (e.borderColor = n), s !== void 0 && (e.wickColor = s), e
}

function To(i) {
  return {
      Area: EE,
      Line: td,
      Baseline: CE,
      Histogram: td,
      Bar: $E,
      Candlestick: LE,
      Custom: PE
  } [i]
}

function PE(i) {
  const e = i.Ib;
  return Object.assign(Object.assign({}, i.He), {
      time: e
  })
}
const IE = {
      vertLine: {
          color: "#9598A1",
          width: 1,
          style: 3,
          visible: !0,
          labelVisible: !0,
          labelBackgroundColor: "#131722"
      },
      horzLine: {
          color: "#9598A1",
          width: 1,
          style: 3,
          visible: !0,
          labelVisible: !0,
          labelBackgroundColor: "#131722"
      },
      mode: 1
  },
  NE = {
      vertLines: {
          color: "#D6DCDE",
          style: 0,
          visible: !0
      },
      horzLines: {
          color: "#D6DCDE",
          style: 0,
          visible: !0
      }
  },
  ME = {
      background: {
          type: "solid",
          color: "#FFFFFF"
      },
      textColor: "#191919",
      fontSize: 12,
      fontFamily: ku,
      attributionLogo: !0
  },
  Wl = {
      autoScale: !0,
      mode: 0,
      invertScale: !1,
      alignLabels: !0,
      borderVisible: !0,
      borderColor: "#2B2B43",
      entireTextOnly: !1,
      visible: !1,
      ticksVisible: !1,
      scaleMargins: {
          bottom: .1,
          top: .2
      },
      minimumWidth: 0
  },
  RE = {
      rightOffset: 0,
      barSpacing: 6,
      minBarSpacing: .5,
      fixLeftEdge: !1,
      fixRightEdge: !1,
      lockVisibleTimeRangeOnResize: !1,
      rightBarStaysOnScroll: !1,
      borderVisible: !0,
      borderColor: "#2B2B43",
      visible: !0,
      timeVisible: !1,
      secondsVisible: !0,
      shiftVisibleRangeOnNewBar: !0,
      allowShiftVisibleRangeOnWhitespaceReplacement: !1,
      ticksVisible: !1,
      uniformDistribution: !1,
      minimumHeight: 0,
      allowBoldLabels: !0
  },
  BE = {
      color: "rgba(0, 0, 0, 0)",
      visible: !1,
      fontSize: 48,
      fontFamily: ku,
      fontStyle: "",
      text: "",
      horzAlign: "center",
      vertAlign: "center"
  };

function id() {
  return {
      width: 0,
      height: 0,
      autoSize: !1,
      layout: ME,
      crosshair: IE,
      grid: NE,
      overlayPriceScales: Object.assign({}, Wl),
      leftPriceScale: Object.assign(Object.assign({}, Wl), {
          visible: !1
      }),
      rightPriceScale: Object.assign(Object.assign({}, Wl), {
          visible: !0
      }),
      timeScale: RE,
      watermark: BE,
      localization: {
          locale: Gn ? navigator.language : "",
          dateFormat: "dd MMM 'yy"
      },
      handleScroll: {
          mouseWheel: !0,
          pressedMouseMove: !0,
          horzTouchDrag: !0,
          vertTouchDrag: !0
      },
      handleScale: {
          axisPressedMouseMove: {
              time: !0,
              price: !0
          },
          axisDoubleClickReset: {
              time: !0,
              price: !0
          },
          mouseWheel: !0,
          pinch: !0
      },
      kineticScroll: {
          mouse: !1,
          touch: !0
      },
      trackingMode: {
          exitMode: 1
      }
  }
}
class OE {
  constructor(e, t) {
      this.lw = e, this.aw = t
  }
  applyOptions(e) {
      this.lw.$t().Hc(this.aw, e)
  }
  options() {
      return this.Li().W()
  }
  width() {
      return Sa(this.aw) ? this.lw.gb(this.aw) : 0
  }
  Li() {
      return Q(this.lw.$t().$c(this.aw)).Dt
  }
}

function nd(i, e, t) {
  const n = rm(i, ["time", "originalTime"]),
      s = Object.assign({
          time: e
      }, n);
  return t !== void 0 && (s.originalTime = t), s
}
const DE = {
  color: "#FF0000",
  price: 0,
  lineStyle: 2,
  lineWidth: 1,
  lineVisible: !0,
  axisLabelVisible: !0,
  title: "",
  axisLabelColor: "",
  axisLabelTextColor: ""
};
class FE {
  constructor(e) {
      this.Eh = e
  }
  applyOptions(e) {
      this.Eh.Hh(e)
  }
  options() {
      return this.Eh.W()
  }
  ow() {
      return this.Eh
  }
}
class AE {
  constructor(e, t, n, s, r) {
      this._w = new Ze, this.Ls = e, this.uw = t, this.cw = n, this.U_ = r, this.dw = s
  }
  S() {
      this._w.S()
  }
  priceFormatter() {
      return this.Ls.ma()
  }
  priceToCoordinate(e) {
      const t = this.Ls.Ct();
      return t === null ? null : this.Ls.Dt().Rt(e, t.Vt)
  }
  coordinateToPrice(e) {
      const t = this.Ls.Ct();
      return t === null ? null : this.Ls.Dt().pn(e, t.Vt)
  }
  barsInLogicalRange(e) {
      if (e === null) return null;
      const t = new An(new ks(e.from, e.to)).hu(),
          n = this.Ls.In();
      if (n.Ni()) return null;
      const s = n.hl(t.Vs(), 1),
          r = n.hl(t.ui(), -1),
          a = Q(n.sl()),
          l = Q(n.An());
      if (s !== null && r !== null && s.se > r.se) return {
          barsBefore: e.from - a,
          barsAfter: l - e.to
      };
      const o = {
          barsBefore: s === null || s.se === a ? e.from - a : s.se - a,
          barsAfter: r === null || r.se === l ? l - e.to : l - r.se
      };
      return s !== null && r !== null && (o.from = s.Ib, o.to = r.Ib), o
  }
  setData(e) {
      this.U_, this.Ls.Jh(), this.uw.fw(this.Ls, e), this.pw("full")
  }
  update(e) {
      this.Ls.Jh(), this.uw.mw(this.Ls, e), this.pw("update")
  }
  dataByIndex(e, t) {
      const n = this.Ls.In().hl(e, t);
      return n === null ? null : To(this.seriesType())(n)
  }
  data() {
      const e = To(this.seriesType());
      return this.Ls.In().ie().map(t => e(t))
  }
  subscribeDataChanged(e) {
      this._w.l(e)
  }
  unsubscribeDataChanged(e) {
      this._w.v(e)
  }
  setMarkers(e) {
      this.U_;
      const t = e.map(n => nd(n, this.U_.convertHorzItemToInternal(n.time), n.time));
      this.Ls.ia(t)
  }
  markers() {
      return this.Ls.na().map(e => nd(e, e.originalTime, void 0))
  }
  applyOptions(e) {
      this.Ls.Hh(e)
  }
  options() {
      return xi(this.Ls.W())
  }
  priceScale() {
      return this.cw.priceScale(this.Ls.Dt().Ta())
  }
  createPriceLine(e) {
      const t = ni(xi(DE), e),
          n = this.Ls.sa(t);
      return new FE(n)
  }
  removePriceLine(e) {
      this.Ls.ea(e.ow())
  }
  seriesType() {
      return this.Ls.Jh()
  }
  attachPrimitive(e) {
      this.Ls.Sa(e), e.attached && e.attached({
          chart: this.dw,
          series: this,
          requestUpdate: () => this.Ls.$t().Xl()
      })
  }
  detachPrimitive(e) {
      this.Ls.ka(e), e.detached && e.detached()
  }
  pw(e) {
      this._w.M() && this._w.m(e)
  }
}
class VE {
  constructor(e, t, n) {
      this.bw = new Ze, this.pu = new Ze, this.Vm = new Ze, this.$i = e, this.kl = e.St(), this.lb = t, this.kl.tc().l(this.ww.bind(this)), this.kl.nc().l(this.gw.bind(this)), this.lb.Em().l(this.Mw.bind(this)), this.U_ = n
  }
  S() {
      this.kl.tc().p(this), this.kl.nc().p(this), this.lb.Em().p(this), this.bw.S(), this.pu.S(), this.Vm.S()
  }
  scrollPosition() {
      return this.kl.ju()
  }
  scrollToPosition(e, t) {
      t ? this.kl.Gu(e, 1e3) : this.$i.Jn(e)
  }
  scrollToRealTime() {
      this.kl.Ku()
  }
  getVisibleRange() {
      const e = this.kl.Du();
      return e === null ? null : {
          from: e.from.originalTime,
          to: e.to.originalTime
      }
  }
  setVisibleRange(e) {
      const t = {
              from: this.U_.convertHorzItemToInternal(e.from),
              to: this.U_.convertHorzItemToInternal(e.to)
          },
          n = this.kl.Au(t);
      this.$i.vd(n)
  }
  getVisibleLogicalRange() {
      const e = this.kl.Ru();
      return e === null ? null : {
          from: e.Vs(),
          to: e.ui()
      }
  }
  setVisibleLogicalRange(e) {
      Hi(e.from <= e.to, "The from index cannot be after the to index."), this.$i.vd(e)
  }
  resetTimeScale() {
      this.$i.Kn()
  }
  fitContent() {
      this.$i.rc()
  }
  logicalToCoordinate(e) {
      const t = this.$i.St();
      return t.Ni() ? null : t.It(e)
  }
  coordinateToLogical(e) {
      return this.kl.Ni() ? null : this.kl.Eu(e)
  }
  timeToCoordinate(e) {
      const t = this.U_.convertHorzItemToInternal(e),
          n = this.kl.Da(t, !1);
      return n === null ? null : this.kl.It(n)
  }
  coordinateToTime(e) {
      const t = this.$i.St(),
          n = t.Eu(e),
          s = t.Ui(n);
      return s === null ? null : s.originalTime
  }
  width() {
      return this.lb._m().width
  }
  height() {
      return this.lb._m().height
  }
  subscribeVisibleTimeRangeChange(e) {
      this.bw.l(e)
  }
  unsubscribeVisibleTimeRangeChange(e) {
      this.bw.v(e)
  }
  subscribeVisibleLogicalRangeChange(e) {
      this.pu.l(e)
  }
  unsubscribeVisibleLogicalRangeChange(e) {
      this.pu.v(e)
  }
  subscribeSizeChange(e) {
      this.Vm.l(e)
  }
  unsubscribeSizeChange(e) {
      this.Vm.v(e)
  }
  applyOptions(e) {
      this.kl.Hh(e)
  }
  options() {
      return Object.assign(Object.assign({}, xi(this.kl.W())), {
          barSpacing: this.kl.he()
      })
  }
  ww() {
      this.bw.M() && this.bw.m(this.getVisibleRange())
  }
  gw() {
      this.pu.M() && this.pu.m(this.getVisibleLogicalRange())
  }
  Mw(e) {
      this.Vm.m(e.width, e.height)
  }
}

function zE(i) {
  if (i === void 0 || i.type === "custom") return;
  const e = i;
  e.minMove !== void 0 && e.precision === void 0 && (e.precision = function(t) {
      if (t >= 1) return 0;
      let n = 0;
      for (; n < 8; n++) {
          const s = Math.round(t);
          if (Math.abs(s - t) < 1e-8) return n;
          t *= 10
      }
      return n
  }(e.minMove))
}

function sd(i) {
  return function(e) {
      if (cr(e.handleScale)) {
          const n = e.handleScale;
          e.handleScale = {
              axisDoubleClickReset: {
                  time: n,
                  price: n
              },
              axisPressedMouseMove: {
                  time: n,
                  price: n
              },
              mouseWheel: n,
              pinch: n
          }
      } else if (e.handleScale !== void 0) {
          const {
              axisPressedMouseMove: n,
              axisDoubleClickReset: s
          } = e.handleScale;
          cr(n) && (e.handleScale.axisPressedMouseMove = {
              time: n,
              price: n
          }), cr(s) && (e.handleScale.axisDoubleClickReset = {
              time: s,
              price: s
          })
      }
      const t = e.handleScroll;
      cr(t) && (e.handleScroll = {
          horzTouchDrag: t,
          vertTouchDrag: t,
          mouseWheel: t,
          pressedMouseMove: t
      })
  }(i), i
}
class WE {
  constructor(e, t, n) {
      this.xw = new Map, this.Sw = new Map, this.kw = new Ze, this.yw = new Ze, this.Cw = new Ze, this.Tw = new SE(t);
      const s = n === void 0 ? xi(id()) : ni(xi(id()), sd(n));
      this.U_ = t, this.lw = new vE(e, s, t), this.lw.hm().l(a => {
          this.kw.M() && this.kw.m(this.Pw(a()))
      }, this), this.lw.lm().l(a => {
          this.yw.M() && this.yw.m(this.Pw(a()))
      }, this), this.lw.Zc().l(a => {
          this.Cw.M() && this.Cw.m(this.Pw(a()))
      }, this);
      const r = this.lw.$t();
      this.Rw = new VE(r, this.lw.cb(), this.U_)
  }
  remove() {
      this.lw.hm().p(this), this.lw.lm().p(this), this.lw.Zc().p(this), this.Rw.S(), this.lw.S(), this.xw.clear(), this.Sw.clear(), this.kw.S(), this.yw.S(), this.Cw.S(), this.Tw.S()
  }
  resize(e, t, n) {
      this.autoSizeActive() || this.lw.ob(e, t, n)
  }
  addCustomSeries(e, t) {
      const n = En(e),
          s = Object.assign(Object.assign({}, Bp), n.defaultOptions());
      return this.Dw("Custom", s, t, n)
  }
  addAreaSeries(e) {
      return this.Dw("Area", SS, e)
  }
  addBaselineSeries(e) {
      return this.Dw("Baseline", ES, e)
  }
  addBarSeries(e) {
      return this.Dw("Bar", xS, e)
  }
  addCandlestickSeries(e = {}) {
      return function(t) {
          t.borderColor !== void 0 && (t.borderUpColor = t.borderColor, t.borderDownColor = t.borderColor), t.wickColor !== void 0 && (t.wickUpColor = t.wickColor, t.wickDownColor = t.wickColor)
      }(e), this.Dw("Candlestick", _S, e)
  }
  addHistogramSeries(e) {
      return this.Dw("Histogram", CS, e)
  }
  addLineSeries(e) {
      return this.Dw("Line", TS, e)
  }
  removeSeries(e) {
      const t = xt(this.xw.get(e)),
          n = this.Tw.fd(t);
      this.lw.$t().fd(t), this.Vw(n), this.xw.delete(e), this.Sw.delete(t)
  }
  fw(e, t) {
      this.Vw(this.Tw.Xb(e, t))
  }
  mw(e, t) {
      this.Vw(this.Tw.tw(e, t))
  }
  subscribeClick(e) {
      this.kw.l(e)
  }
  unsubscribeClick(e) {
      this.kw.v(e)
  }
  subscribeCrosshairMove(e) {
      this.Cw.l(e)
  }
  unsubscribeCrosshairMove(e) {
      this.Cw.v(e)
  }
  subscribeDblClick(e) {
      this.yw.l(e)
  }
  unsubscribeDblClick(e) {
      this.yw.v(e)
  }
  priceScale(e) {
      return new OE(this.lw, e)
  }
  timeScale() {
      return this.Rw
  }
  applyOptions(e) {
      this.lw.Hh(sd(e))
  }
  options() {
      return this.lw.W()
  }
  takeScreenshot() {
      return this.lw.bb()
  }
  autoSizeActive() {
      return this.lw.Sb()
  }
  chartElement() {
      return this.lw.kb()
  }
  paneSize() {
      const e = this.lw.Cb();
      return {
          height: e.height,
          width: e.width
      }
  }
  setCrosshairPosition(e, t, n) {
      const s = this.xw.get(n);
      if (s === void 0) return;
      const r = this.lw.$t().cr(s);
      r !== null && this.lw.$t().ld(e, t, r)
  }
  clearCrosshairPosition() {
      this.lw.$t().ad(!0)
  }
  Dw(e, t, n = {}, s) {
      zE(n.priceFormat);
      const r = ni(xi(Op), xi(t), n),
          a = this.lw.$t().ud(e, r, s),
          l = new AE(a, this, this, this, this.U_);
      return this.xw.set(l, a), this.Sw.set(a, l), l
  }
  Vw(e) {
      const t = this.lw.$t();
      t.od(e.St.Lu, e.St.rw, e.St.hw), e.sw.forEach((n, s) => s.J(n.He, n.ew)), t.Fu()
  }
  Ow(e) {
      return xt(this.Sw.get(e))
  }
  Pw(e) {
      const t = new Map;
      e.Eb.forEach((s, r) => {
          const a = r.Jh(),
              l = To(a)(s);
          if (a !== "Custom") Hi(bE(l));
          else {
              const o = r.Ca();
              Hi(!o || o(l) === !1)
          }
          t.set(this.Ow(r), l)
      });
      const n = e.Lb !== void 0 && this.Sw.has(e.Lb) ? this.Ow(e.Lb) : void 0;
      return {
          time: e.Ib,
          logical: e.se,
          point: e.zb,
          hoveredSeries: n,
          hoveredObjectId: e.Nb,
          seriesData: t,
          sourceEvent: e.Fb
      }
  }
}

function UE(i, e, t) {
  let n;
  if (Ks(i)) {
      const r = document.getElementById(i);
      Hi(r !== null, `Cannot find element in DOM with id=${i}`), n = r
  } else n = i;
  const s = new WE(n, e, t);
  return e.setOptions(s.options()), s
}

function Mu(i, e) {
  return UE(i, new Uh, Uh.Ad(e))
}
Object.assign(Object.assign({}, Op), Bp);
const jE = {
      key: 0,
      class: "mb-4"
  },
  HE = {
      class: "flex flex-col space-y-1 mb-1 w-full"
  },
  qE = {
      class: "flex flex-col sm:flex-row w-full"
  },
  GE = {
      class: "flex flex-row gap-1 items-center"
  },
  KE = {
      class: "text-xs sm:text-sm text-gray-700 dark:text-gray-300"
  },
  XE = {
      class: "text-xs sm:text-sm text-gray-500 dark:text-gray-50"
  },
  JE = {
      class: "flex flex-row gap-1 items-center mt-1 sm:mt-0 sm:ml-1"
  },
  YE = {
      class: "text-[10px] sm:text-xs text-green-500 dark:text-green-400 flex"
  },
  QE = {
      class: "text-[10px] sm:text-xs text-green-500 dark:text-green-400 flex"
  },
  ZE = {
      class: "flex flex-row gap-1 items-center sm:ml-auto"
  },
  eC = {
      class: "items-center flex flex-row items-center"
  },
  tC = {
      class: "trust-factor-emoji text-[10px] sm:text-xs ml-1"
  },
  iC = {
      class: "text-[10px] sm:text-xs text-gray-700 dark:text-gray-300 flex items-center"
  },
  nC = {
      type: "button"
  },
  sC = {
      class: "flex gap-1 items-center"
  },
  rC = ["alt"],
  aC = {
      class: "rounded hover:underline flex -ml-1",
      style: {
          "background-color": "transparent"
      }
  },
  lC = {
      class: "flex flex-row space-x-1 sm:space-x-2 items-center w-full justify-start"
  },
  oC = ["onClick"],
  uC = U({
      name: "PriceChart"
  }),
  So = U({
      ...uC,
      props: {
          launch: {}
      },
      setup(i) {
          const e = i,
              t = Zn(),
              n = St(),
              s = t.params.id,
              r = M(window.innerWidth < 768),
              a = () => {
                  r.value = window.innerWidth < 768
              },
              l = ["5s", "15s", "30s", "1m", "5m", "15m", "30m", "1h", "4h", "1d"],
              o = ["5s", "30s", "5m", "30m", "2h", "4h", "1d"],
              u = q(() => r.value ? o : l);
          Te(() => {
              window.addEventListener("resize", a)
          }), ct(() => {
              window.removeEventListener("resize", a)
          });
          let c = !1,
              h = null,
              d = null;
          const f = M(!1),
              p = () => {
                  const D = {
                      layout: {
                          background: {
                              type: As.Solid,
                              color: f.value ? "#1E1E1E" : "#FFFFFF"
                          },
                          textColor: f.value ? "#D9D9D9" : "#191919"
                      },
                      grid: {
                          vertLines: {
                              color: f.value ? "#2B2B2B" : "#E1E1E1"
                          },
                          horzLines: {
                              color: f.value ? "#2B2B2B" : "#E1E1E1"
                          }
                      },
                      rightPriceScale: {
                          borderVisible: !1,
                          formatter: P => ut(P)
                      }
                  };
                  d ? d.applyOptions(D) : (d = Mu(document.getElementById("chart"), D), h = d.addCandlestickSeries({
                      upColor: "#26a69a",
                      downColor: "#ef5350",
                      borderVisible: !1,
                      wickUpColor: "#26a69a",
                      wickDownColor: "#ef5350",
                      priceFormat: {
                          type: "custom",
                          formatter: P => ut(P),
                          minMove: 1e-8
                      }
                  }))
              };
          Ie(() => f.value, () => {
              p()
          }), Te(() => {
              f.value = document.documentElement.classList.contains("dark");
              const D = new MutationObserver(() => {
                  f.value = document.documentElement.classList.contains("dark")
              });
              p(), D.observe(document.documentElement, {
                  attributes: !0,
                  attributeFilter: ["class"]
              }), n.startCandleStream(parseInt(s), "5m")
          });
          let g = 0;
          Ie(() => n.candles, D => {
              if (D.length === 0) {
                  c = !1, g = 0;
                  return
              }
              if (!c) console.log("CANDLES", D.length), h.setData(n.candles), d.timeScale().fitContent(), c = !0;
              else {
                  const P = D[D.length - 1];
                  P.time >= g && (h.update(P), g = P.time)
              }
          }, {
              deep: !0
          });
          const w = D => {
                  console.log("SET TIME FRAME", D), n.stopCandleStream(), n.startCandleStream(parseInt(s), D), c = !1, console.log("CANDLES", n.candles.length)
              },
              y = q(() => !e.launch || !e.launch.session ? "Unknown" : e.launch.session.fullName),
              b = q(() => !e.launch || !e.launch.session ? "Unknown" : e.launch.session.tokenName),
              x = q(() => {
                  if (!e.launch.telegramUser) return "\u2753";
                  let D = e.launch.telegramUser.reputationScore;
                  return D < 3 ? "\u{1F534}" : D < 5 ? "\u{1F7E1}" : D < 8 ? "\u{1F7E2}" : "\u{1F451}"
              }),
              k = q(() => {
                  switch (e.launch.poolType) {
                      case Gt.Quadratic:
                          let D = e.launch.k / (e.launch.x + e.launch.x0);
                          return (e.launch.x + e.launch.x0) / D;
                      case Gt.Fixed:
                          return e.launch.x0 / e.launch.k;
                      default:
                          return 0
                  }
              }),
              S = q(() => e.launch.telegramUser ? e.launch.telegramUser.username : "Unknown"),
              B = q(() => {
                  if (!e.launch.session) return "0";
                  let P = -e.launch.y / Math.pow(10, e.launch.decimals) * k.value;
                  return ut(P)
              });
          return (D, P) => e.launch ? (_(), T("div", jE, [m("div", HE, [m("div", qE, [m("div", GE, [m("p", KE, A(y.value), 1), m("p", XE, " (" + A(b.value) + ") ", 1)]), m("div", JE, [P[0] || (P[0] = m("p", {
              class: "hidden sm:block text-xs sm:text-sm text-gray-300 dark:text-gray-700"
          }, " | ", -1)), m("div", YE, " Market cap: " + A(B.value), 1), P[1] || (P[1] = m("p", {
              class: "text-xs sm:text-sm text-gray-300"
          }, "|", -1)), m("div", QE, " Price: " + A(k.value.toFixed(5)), 1)]), m("div", ZE, [m("div", eC, [P[2] || (P[2] = m("span", {
              class: "text-[10px] sm:text-xs text-gray-900 dark:text-gray-300"
          }, "Trust Factor:", -1)), m("span", tC, A(x.value), 1)]), P[4] || (P[4] = m("p", {
              class: "text-xs sm:text-sm text-gray-300"
          }, "|", -1)), m("div", iC, [P[3] || (P[3] = m("div", {
              class: "text-black dark:text-white bold"
          }, "Created by:", -1)), m("button", nC, [m("span", sC, [m("img", {
              alt: S.value,
              loading: "lazy",
              width: "24",
              height: "24",
              decoding: "async",
              "data-nimg": "1",
              class: "w-6 h-6 rounded-full",
              src: Is
          }, null, 8, rC), m("span", aC, A(S.value), 1)])])])])]), m("div", lC, [(_(!0), T(F, null, ue(u.value, I => (_(), T("button", {
              key: I,
              onClick: $ => w(I),
              class: "px-3 py-1 bg-green-300 rounded text-xs sm:text-sm whitespace-nowrap overflow-hidden text-ellipsis text-black hover:bg-green-500 ease-in-out duration-300"
          }, A(I), 9, oC))), 128))])]), P[5] || (P[5] = m("div", {
              class: "h-56 sm:h-80 mt-2 rounded-lg overflow-hidden shadow",
              id: "chart"
          }, null, -1))])) : ye("", !0)
      }
  }),
  es = U({
      __name: "WalletAddress",
      props: {
          walletAddress: {}
      },
      setup(i) {
          const e = Ji(),
              t = i,
              n = q(() => e.walletLabels.has(t.walletAddress) ? e.walletLabels.get(t.walletAddress) : t.walletAddress.slice(0, 6) + "..." + t.walletAddress.slice(-4));
          return (s, r) => (_(), T("span", null, A(n.value), 1))
      }
  }),
  cC = ["href"],
  hC = {
      key: 0,
      class: "text-[10px] md:text-xs font-bold text-orange-700 bg-orange-200 ml-2 px-0.5 rounded-md"
  },
  dC = U({
      name: "TransactionRow"
  }),
  fC = U({
      ...dC,
      props: {
          decimals: {},
          dev: {},
          fill: {},
          columns: {}
      },
      setup(i) {
          const e = i,
              t = q(() => e.fill.wallet?.ethereumAddress ?? "");
          gp();
          const n = c => new Intl.NumberFormat("en-US", {
                  minimumFractionDigits: 2
              }).format(c),
              s = c => new Intl.NumberFormat("en-US", {
                  style: "currency",
                  currency: "USD"
              }).format(c);

          function r(c) {
              const h = new Date,
                  d = new Date(c),
                  f = Math.floor((h.getTime() - d.getTime()) / 1e3);
              return f < 60 ? `${f}s ago` : f < 3600 ? `${Math.floor(f/60)}m ago` : f < 86400 ? `${Math.floor(f/3600)}h ago` : `${Math.floor(f/86400)}d ago`
          }
          const a = () => e.fill.usdcDelta <= 0 ? ["text-green-700", "dark:text-green-400"] : ["text-red-700", "dark:text-red-400"],
              l = c => {
                  let h;
                  switch (c) {
                      case "account":
                          if (e.fill.wallet) {
                              const d = e.fill.wallet.ethereumAddress;
                              return `${d.slice(0,4)}...${d.slice(-4)}`
                          } else return "";
                      case "type":
                          return e.fill.usdcDelta <= 0 ? "Buy" : "Sell";
                      case "price":
                          return s(Math.abs(e.fill.usdcDelta) / Math.abs(e.fill.launchDelta));
                      case "usdcDelta":
                          return h = e.fill.usdcDelta > 0 ? e.fill.usdcDelta : -e.fill.usdcDelta, n(h / Math.pow(10, e.decimals));
                      case "launchDelta":
                          return h = e.fill.launchDelta > 0 ? e.fill.launchDelta : -e.fill.launchDelta, n(h / Math.pow(10, e.decimals));
                      case "date":
                          return r(e.fill.timestamp);
                      case "transaction":
                          return e.fill.movementHash ? e.fill.movementHash.value.slice(0, 6) : "";
                      default:
                          return ""
                  }
              },
              o = M(!1),
              u = M(0);
          return Ie(() => e.fill, c => {
              if (e.fill.timestamp < Date.now() - 1e3 || u.value === e.fill.id) return;
              o.value = !0, u.value = e.fill.id;
              const h = setTimeout(() => {}, 1e3);
              return () => clearTimeout(h)
          }), (c, h) => {
              const d = st("router-link");
              return _(), T("div", {
                  class: ie([o.value ? "animate-new-row" : "", "transition-colors duration-300 flex w-full"])
              }, [(_(!0), T(F, null, ue(c.columns, f => (_(), T("div", {
                  key: f.key,
                  class: ie(["whitespace-nowrap py-4 px-3 text-sm", f.align === "right" ? "text-right" : "text-left", f.key === "base.name" ? "font-medium text-gray-900 dark:text-gray-300 sticky left-0 bg-white dark:text-gray-300 z-10" : "text-gray-500 dark:text-gray-300", ["type", "usdcDelta", "launchDelta"].includes(f.key) ? a() : ""]),
                  style: tt({
                      width: f.width
                  })
              }, [f.key === "transaction" && e.fill.movementHash ? (_(), T("a", {
                  key: 0,
                  target: "_blank",
                  href: "https://app.hyperliquid.xyz/explorer/tx/" + e.fill.movementHash.value
              }, A(l(f.key)), 9, cC)) : f.key === "account" && t.value ? (_(), xe(d, {
                  key: 1,
                  to: "/wallet/" + t.value
              }, {
                  default: We(() => [z(es, {
                      "wallet-address": t.value
                  }, null, 8, ["wallet-address"]), t.value === c.dev ? (_(), T("span", hC, " dev ")) : ye("", !0)]),
                  _: 1
              }, 8, ["to"])) : (_(), T(F, {
                  key: 2
              }, [Xe(A(l(f.key)), 1)], 64))], 6))), 128))], 2)
          }
      }
  });
const pC = Ee(fC, [
      ["__scopeId", "data-v-b0d6982e"]
  ]),
  mC = {
      class: "flex w-full animate-pulse"
  },
  gC = U({
      name: "TransactionRow"
  }),
  yC = U({
      ...gC,
      props: {
          columns: {}
      },
      setup(i) {
          return (e, t) => (_(), T("div", mC, [(_(!0), T(F, null, ue(e.columns, n => (_(), T("div", {
              key: n.key,
              class: ie(["whitespace-nowrap py-4 px-3", n.align === "right" ? "text-right" : "text-left"]),
              style: tt({
                  width: n.width
              })
          }, t[0] || (t[0] = [m("div", {
              class: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-3/4"
          }, null, -1)]), 6))), 128))]))
      }
  });

function vC() {
  var i = window.navigator.userAgent,
      e = i.indexOf("MSIE ");
  if (e > 0) return parseInt(i.substring(e + 5, i.indexOf(".", e)), 10);
  var t = i.indexOf("Trident/");
  if (t > 0) {
      var n = i.indexOf("rv:");
      return parseInt(i.substring(n + 3, i.indexOf(".", n)), 10)
  }
  var s = i.indexOf("Edge/");
  return s > 0 ? parseInt(i.substring(s + 5, i.indexOf(".", s)), 10) : -1
}
let Lr;

function Eo() {
  Eo.init || (Eo.init = !0, Lr = vC() !== -1)
}
var $a = {
  name: "ResizeObserver",
  props: {
      emitOnMount: {
          type: Boolean,
          default: !1
      },
      ignoreWidth: {
          type: Boolean,
          default: !1
      },
      ignoreHeight: {
          type: Boolean,
          default: !1
      }
  },
  emits: ["notify"],
  mounted() {
      Eo(), pi(() => {
          this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitOnMount && this.emitSize()
      });
      const i = document.createElement("object");
      this._resizeObject = i, i.setAttribute("aria-hidden", "true"), i.setAttribute("tabindex", -1), i.onload = this.addResizeHandlers, i.type = "text/html", Lr && this.$el.appendChild(i), i.data = "about:blank", Lr || this.$el.appendChild(i)
  },
  beforeUnmount() {
      this.removeResizeHandlers()
  },
  methods: {
      compareAndNotify() {
          (!this.ignoreWidth && this._w !== this.$el.offsetWidth || !this.ignoreHeight && this._h !== this.$el.offsetHeight) && (this._w = this.$el.offsetWidth, this._h = this.$el.offsetHeight, this.emitSize())
      },
      emitSize() {
          this.$emit("notify", {
              width: this._w,
              height: this._h
          })
      },
      addResizeHandlers() {
          this._resizeObject.contentDocument.defaultView.addEventListener("resize", this.compareAndNotify), this.compareAndNotify()
      },
      removeResizeHandlers() {
          this._resizeObject && this._resizeObject.onload && (!Lr && this._resizeObject.contentDocument && this._resizeObject.contentDocument.defaultView.removeEventListener("resize", this.compareAndNotify), this.$el.removeChild(this._resizeObject), this._resizeObject.onload = null, this._resizeObject = null)
      }
  }
};
const bC = zg();
Ag("data-v-b329ee4c");
const wC = {
  class: "resize-observer",
  tabindex: "-1"
};
Vg();
const kC = bC((i, e, t, n, s, r) => (_(), xe("div", wC)));
$a.render = kC;
$a.__scopeId = "data-v-b329ee4c";
$a.__file = "src/components/ResizeObserver.vue";

function Pr(i) {
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Pr = function(e) {
      return typeof e
  } : Pr = function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
  }, Pr(i)
}

function _C(i, e) {
  if (!(i instanceof e)) throw new TypeError("Cannot call a class as a function")
}

function rd(i, e) {
  for (var t = 0; t < e.length; t++) {
      var n = e[t];
      n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(i, n.key, n)
  }
}

function xC(i, e, t) {
  return e && rd(i.prototype, e), t && rd(i, t), i
}

function ad(i) {
  return TC(i) || SC(i) || EC(i) || CC()
}

function TC(i) {
  if (Array.isArray(i)) return Co(i)
}

function SC(i) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(i)) return Array.from(i)
}

function EC(i, e) {
  if (!!i) {
      if (typeof i == "string") return Co(i, e);
      var t = Object.prototype.toString.call(i).slice(8, -1);
      if (t === "Object" && i.constructor && (t = i.constructor.name), t === "Map" || t === "Set") return Array.from(i);
      if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return Co(i, e)
  }
}

function Co(i, e) {
  (e == null || e > i.length) && (e = i.length);
  for (var t = 0, n = new Array(e); t < e; t++) n[t] = i[t];
  return n
}

function CC() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
}

function $C(i) {
  var e;
  return typeof i == "function" ? e = {
      callback: i
  } : e = i, e
}

function LC(i, e) {
  var t = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {},
      n, s, r, a = function(o) {
          for (var u = arguments.length, c = new Array(u > 1 ? u - 1 : 0), h = 1; h < u; h++) c[h - 1] = arguments[h];
          if (r = c, !(n && o === s)) {
              var d = t.leading;
              typeof d == "function" && (d = d(o, s)), (!n || o !== s) && d && i.apply(void 0, [o].concat(ad(r))), s = o, clearTimeout(n), n = setTimeout(function() {
                  i.apply(void 0, [o].concat(ad(r))), n = 0
              }, e)
          }
      };
  return a._clear = function() {
      clearTimeout(n), n = null
  }, a
}

function lm(i, e) {
  if (i === e) return !0;
  if (Pr(i) === "object") {
      for (var t in i)
          if (!lm(i[t], e[t])) return !1;
      return !0
  }
  return !1
}
var PC = function() {
  function i(e, t, n) {
      _C(this, i), this.el = e, this.observer = null, this.frozen = !1, this.createObserver(t, n)
  }
  return xC(i, [{
      key: "createObserver",
      value: function(t, n) {
          var s = this;
          if (this.observer && this.destroyObserver(), !this.frozen) {
              if (this.options = $C(t), this.callback = function(l, o) {
                      s.options.callback(l, o), l && s.options.once && (s.frozen = !0, s.destroyObserver())
                  }, this.callback && this.options.throttle) {
                  var r = this.options.throttleOptions || {},
                      a = r.leading;
                  this.callback = LC(this.callback, this.options.throttle, {
                      leading: function(o) {
                          return a === "both" || a === "visible" && o || a === "hidden" && !o
                      }
                  })
              }
              this.oldResult = void 0, this.observer = new IntersectionObserver(function(l) {
                  var o = l[0];
                  if (l.length > 1) {
                      var u = l.find(function(h) {
                          return h.isIntersecting
                      });
                      u && (o = u)
                  }
                  if (s.callback) {
                      var c = o.isIntersecting && o.intersectionRatio >= s.threshold;
                      if (c === s.oldResult) return;
                      s.oldResult = c, s.callback(c, o)
                  }
              }, this.options.intersection), pi(function() {
                  s.observer && s.observer.observe(s.el)
              })
          }
      }
  }, {
      key: "destroyObserver",
      value: function() {
          this.observer && (this.observer.disconnect(), this.observer = null), this.callback && this.callback._clear && (this.callback._clear(), this.callback = null)
      }
  }, {
      key: "threshold",
      get: function() {
          return this.options.intersection && typeof this.options.intersection.threshold == "number" ? this.options.intersection.threshold : 0
      }
  }]), i
}();

function om(i, e, t) {
  var n = e.value;
  if (!!n)
      if (typeof IntersectionObserver > "u") console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");
      else {
          var s = new PC(i, n, t);
          i._vue_visibilityState = s
      }
}

function IC(i, e, t) {
  var n = e.value,
      s = e.oldValue;
  if (!lm(n, s)) {
      var r = i._vue_visibilityState;
      if (!n) {
          um(i);
          return
      }
      r ? r.createObserver(n, t) : om(i, {
          value: n
      }, t)
  }
}

function um(i) {
  var e = i._vue_visibilityState;
  e && (e.destroyObserver(), delete i._vue_visibilityState)
}
var NC = {
      beforeMount: om,
      updated: IC,
      unmounted: um
  },
  MC = {
      itemsLimit: 1e3
  },
  RC = /(auto|scroll)/;

function cm(i, e) {
  return i.parentNode === null ? e : cm(i.parentNode, e.concat([i]))
}
var Ul = function(e, t) {
      return getComputedStyle(e, null).getPropertyValue(t)
  },
  BC = function(e) {
      return Ul(e, "overflow") + Ul(e, "overflow-y") + Ul(e, "overflow-x")
  },
  OC = function(e) {
      return RC.test(BC(e))
  };

function ld(i) {
  if (i instanceof HTMLElement || i instanceof SVGElement) {
      for (var e = cm(i.parentNode, []), t = 0; t < e.length; t += 1)
          if (OC(e[t])) return e[t];
      return document.scrollingElement || document.documentElement
  }
}

function $o(i) {
  return $o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
      return typeof e
  } : function(e) {
      return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
  }, $o(i)
}
var DC = {
  items: {
      type: Array,
      required: !0
  },
  keyField: {
      type: String,
      default: "id"
  },
  direction: {
      type: String,
      default: "vertical",
      validator: function(e) {
          return ["vertical", "horizontal"].includes(e)
      }
  },
  listTag: {
      type: String,
      default: "div"
  },
  itemTag: {
      type: String,
      default: "div"
  }
};

function FC() {
  return this.items.length && $o(this.items[0]) !== "object"
}
var Lo = !1;
if (typeof window < "u") {
  Lo = !1;
  try {
      var AC = Object.defineProperty({}, "passive", {
          get: function() {
              Lo = !0
          }
      });
      window.addEventListener("test", null, AC)
  } catch {}
}
let VC = 0;
var Ru = {
  name: "RecycleScroller",
  components: {
      ResizeObserver: $a
  },
  directives: {
      ObserveVisibility: NC
  },
  props: {
      ...DC,
      itemSize: {
          type: Number,
          default: null
      },
      gridItems: {
          type: Number,
          default: void 0
      },
      itemSecondarySize: {
          type: Number,
          default: void 0
      },
      minItemSize: {
          type: [Number, String],
          default: null
      },
      sizeField: {
          type: String,
          default: "size"
      },
      typeField: {
          type: String,
          default: "type"
      },
      buffer: {
          type: Number,
          default: 200
      },
      pageMode: {
          type: Boolean,
          default: !1
      },
      prerender: {
          type: Number,
          default: 0
      },
      emitUpdate: {
          type: Boolean,
          default: !1
      },
      updateInterval: {
          type: Number,
          default: 0
      },
      skipHover: {
          type: Boolean,
          default: !1
      },
      listTag: {
          type: String,
          default: "div"
      },
      itemTag: {
          type: String,
          default: "div"
      },
      listClass: {
          type: [String, Object, Array],
          default: ""
      },
      itemClass: {
          type: [String, Object, Array],
          default: ""
      }
  },
  emits: ["resize", "visible", "hidden", "update", "scroll-start", "scroll-end"],
  data() {
      return {
          pool: [],
          totalSize: 0,
          ready: !1,
          hoverKey: null
      }
  },
  computed: {
      sizes() {
          if (this.itemSize === null) {
              const i = {
                      "-1": {
                          accumulator: 0
                      }
                  },
                  e = this.items,
                  t = this.sizeField,
                  n = this.minItemSize;
              let s = 1e4,
                  r = 0,
                  a;
              for (let l = 0, o = e.length; l < o; l++) a = e[l][t] || n, a < s && (s = a), r += a, i[l] = {
                  accumulator: r,
                  size: a
              };
              return this.$_computedMinItemSize = s, i
          }
          return []
      },
      simpleArray: FC,
      itemIndexByKey() {
          const {
              keyField: i,
              items: e
          } = this, t = {};
          for (let n = 0, s = e.length; n < s; n++) t[e[n][i]] = n;
          return t
      }
  },
  watch: {
      items() {
          this.updateVisibleItems(!0)
      },
      pageMode() {
          this.applyPageMode(), this.updateVisibleItems(!1)
      },
      sizes: {
          handler() {
              this.updateVisibleItems(!1)
          },
          deep: !0
      },
      gridItems() {
          this.updateVisibleItems(!0)
      },
      itemSecondarySize() {
          this.updateVisibleItems(!0)
      }
  },
  created() {
      this.$_startIndex = 0, this.$_endIndex = 0, this.$_views = new Map, this.$_unusedViews = new Map, this.$_scrollDirty = !1, this.$_lastUpdateScrollPosition = 0, this.prerender && (this.$_prerender = !0, this.updateVisibleItems(!1)), this.gridItems && !this.itemSize && console.error("[vue-recycle-scroller] You must provide an itemSize when using gridItems")
  },
  mounted() {
      this.applyPageMode(), this.$nextTick(() => {
          this.$_prerender = !1, this.updateVisibleItems(!0), this.ready = !0
      })
  },
  activated() {
      const i = this.$_lastUpdateScrollPosition;
      typeof i == "number" && this.$nextTick(() => {
          this.scrollToPosition(i)
      })
  },
  beforeUnmount() {
      this.removeListeners()
  },
  methods: {
      addView(i, e, t, n, s) {
          const r = aa({
                  id: VC++,
                  index: e,
                  used: !0,
                  key: n,
                  type: s
              }),
              a = Qo({
                  item: t,
                  position: 0,
                  nr: r
              });
          return i.push(a), a
      },
      unuseView(i, e = !1) {
          const t = this.$_unusedViews,
              n = i.nr.type;
          let s = t.get(n);
          s || (s = [], t.set(n, s)), s.push(i), e || (i.nr.used = !1, i.position = -9999)
      },
      handleResize() {
          this.$emit("resize"), this.ready && this.updateVisibleItems(!1)
      },
      handleScroll(i) {
          if (!this.$_scrollDirty) {
              if (this.$_scrollDirty = !0, this.$_updateTimeout) return;
              const e = () => requestAnimationFrame(() => {
                  this.$_scrollDirty = !1;
                  const {
                      continuous: t
                  } = this.updateVisibleItems(!1, !0);
                  t || (clearTimeout(this.$_refreshTimout), this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100))
              });
              e(), this.updateInterval && (this.$_updateTimeout = setTimeout(() => {
                  this.$_updateTimeout = 0, this.$_scrollDirty && e()
              }, this.updateInterval))
          }
      },
      handleVisibilityChange(i, e) {
          this.ready && (i || e.boundingClientRect.width !== 0 || e.boundingClientRect.height !== 0 ? (this.$emit("visible"), requestAnimationFrame(() => {
              this.updateVisibleItems(!1)
          })) : this.$emit("hidden"))
      },
      updateVisibleItems(i, e = !1) {
          const t = this.itemSize,
              n = this.gridItems || 1,
              s = this.itemSecondarySize || t,
              r = this.$_computedMinItemSize,
              a = this.typeField,
              l = this.simpleArray ? null : this.keyField,
              o = this.items,
              u = o.length,
              c = this.sizes,
              h = this.$_views,
              d = this.$_unusedViews,
              f = this.pool,
              p = this.itemIndexByKey;
          let g, w, y, b, x;
          if (!u) g = w = b = x = y = 0;
          else if (this.$_prerender) g = b = 0, w = x = Math.min(this.prerender, o.length), y = null;
          else {
              const $ = this.getScroll();
              if (e) {
                  let O = $.start - this.$_lastUpdateScrollPosition;
                  if (O < 0 && (O = -O), t === null && O < r || O < t) return {
                      continuous: !0
                  }
              }
              this.$_lastUpdateScrollPosition = $.start;
              const V = this.buffer;
              $.start -= V, $.end += V;
              let N = 0;
              if (this.$refs.before && (N = this.$refs.before.scrollHeight, $.start -= N), this.$refs.after) {
                  const O = this.$refs.after.scrollHeight;
                  $.end += O
              }
              if (t === null) {
                  let O, se = 0,
                      G = u - 1,
                      te = ~~(u / 2),
                      le;
                  do le = te, O = c[te].accumulator, O < $.start ? se = te : te < u - 1 && c[te + 1].accumulator > $.start && (G = te), te = ~~((se + G) / 2); while (te !== le);
                  for (te < 0 && (te = 0), g = te, y = c[u - 1].accumulator, w = te; w < u && c[w].accumulator < $.end; w++);
                  for (w === -1 ? w = o.length - 1 : (w++, w > u && (w = u)), b = g; b < u && N + c[b].accumulator < $.start; b++);
                  for (x = b; x < u && N + c[x].accumulator < $.end; x++);
              } else {
                  g = ~~($.start / t * n);
                  const O = g % n;
                  g -= O, w = Math.ceil($.end / t * n), b = Math.max(0, Math.floor(($.start - N) / t * n)), x = Math.floor(($.end - N) / t * n), g < 0 && (g = 0), w > u && (w = u), b < 0 && (b = 0), x > u && (x = u), y = Math.ceil(u / n) * t
              }
          }
          w - g > MC.itemsLimit && this.itemsLimitError(), this.totalSize = y;
          let k;
          const S = g <= this.$_endIndex && w >= this.$_startIndex;
          if (S)
              for (let $ = 0, V = f.length; $ < V; $++) k = f[$], k.nr.used && (i && (k.nr.index = p[k.item[l]]), (k.nr.index == null || k.nr.index < g || k.nr.index >= w) && this.unuseView(k));
          const B = S ? null : new Map;
          let D, P, I;
          for (let $ = g; $ < w; $++) {
              D = o[$];
              const V = l ? D[l] : D;
              if (V == null) throw new Error(`Key is ${V} on item (keyField is '${l}')`);
              if (k = h.get(V), !t && !c[$].size) {
                  k && this.unuseView(k);
                  continue
              }
              P = D[a];
              let N = d.get(P),
                  O = !1;
              if (!k) S ? N && N.length ? k = N.pop() : k = this.addView(f, $, D, V, P) : (I = B.get(P) || 0, (!N || I >= N.length) && (k = this.addView(f, $, D, V, P), this.unuseView(k, !0), N = d.get(P)), k = N[I], B.set(P, I + 1)), h.delete(k.nr.key), k.nr.used = !0, k.nr.index = $, k.nr.key = V, k.nr.type = P, h.set(V, k), O = !0;
              else if (!k.nr.used && (k.nr.used = !0, O = !0, N)) {
                  const se = N.indexOf(k);
                  se !== -1 && N.splice(se, 1)
              }
              k.item = D, O && ($ === o.length - 1 && this.$emit("scroll-end"), $ === 0 && this.$emit("scroll-start")), t === null ? (k.position = c[$ - 1].accumulator, k.offset = 0) : (k.position = Math.floor($ / n) * t, k.offset = $ % n * s)
          }
          return this.$_startIndex = g, this.$_endIndex = w, this.emitUpdate && this.$emit("update", g, w, b, x), clearTimeout(this.$_sortTimer), this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300), {
              continuous: S
          }
      },
      getListenerTarget() {
          let i = ld(this.$el);
          return window.document && (i === window.document.documentElement || i === window.document.body) && (i = window), i
      },
      getScroll() {
          const {
              $el: i,
              direction: e
          } = this, t = e === "vertical";
          let n;
          if (this.pageMode) {
              const s = i.getBoundingClientRect(),
                  r = t ? s.height : s.width;
              let a = -(t ? s.top : s.left),
                  l = t ? window.innerHeight : window.innerWidth;
              a < 0 && (l += a, a = 0), a + l > r && (l = r - a), n = {
                  start: a,
                  end: a + l
              }
          } else t ? n = {
              start: i.scrollTop,
              end: i.scrollTop + i.clientHeight
          } : n = {
              start: i.scrollLeft,
              end: i.scrollLeft + i.clientWidth
          };
          return n
      },
      applyPageMode() {
          this.pageMode ? this.addListeners() : this.removeListeners()
      },
      addListeners() {
          this.listenerTarget = this.getListenerTarget(), this.listenerTarget.addEventListener("scroll", this.handleScroll, Lo ? {
              passive: !0
          } : !1), this.listenerTarget.addEventListener("resize", this.handleResize)
      },
      removeListeners() {
          !this.listenerTarget || (this.listenerTarget.removeEventListener("scroll", this.handleScroll), this.listenerTarget.removeEventListener("resize", this.handleResize), this.listenerTarget = null)
      },
      scrollToItem(i) {
          let e;
          const t = this.gridItems || 1;
          this.itemSize === null ? e = i > 0 ? this.sizes[i - 1].accumulator : 0 : e = Math.floor(i / t) * this.itemSize, this.scrollToPosition(e)
      },
      scrollToPosition(i) {
          const e = this.direction === "vertical" ? {
              scroll: "scrollTop",
              start: "top"
          } : {
              scroll: "scrollLeft",
              start: "left"
          };
          let t, n, s;
          if (this.pageMode) {
              const r = ld(this.$el),
                  a = r.tagName === "HTML" ? 0 : r[e.scroll],
                  l = r.getBoundingClientRect(),
                  u = this.$el.getBoundingClientRect()[e.start] - l[e.start];
              t = r, n = e.scroll, s = i + a + u
          } else t = this.$el, n = e.scroll, s = i;
          t[n] = s
      },
      itemsLimitError() {
          throw setTimeout(() => {
              console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.", "Scroller:", this.$el), console.log("Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.")
          }), new Error("Rendered items limit reached")
      },
      sortViews() {
          this.pool.sort((i, e) => i.nr.index - e.nr.index)
      }
  }
};
const zC = {
      key: 0,
      ref: "before",
      class: "vue-recycle-scroller__slot"
  },
  WC = {
      key: 1,
      ref: "after",
      class: "vue-recycle-scroller__slot"
  };

function UC(i, e, t, n, s, r) {
  const a = st("ResizeObserver"),
      l = e0("observe-visibility");
  return Mt((_(), T("div", {
      class: ie(["vue-recycle-scroller", {
          ready: s.ready,
          "page-mode": t.pageMode,
          [`direction-${i.direction}`]: !0
      }]),
      onScrollPassive: e[0] || (e[0] = (...o) => r.handleScroll && r.handleScroll(...o))
  }, [i.$slots.before ? (_(), T("div", zC, [nr(i.$slots, "before")], 512)) : ye("v-if", !0), (_(), xe(Xl(t.listTag), {
      ref: "wrapper",
      style: tt({
          [i.direction === "vertical" ? "minHeight" : "minWidth"]: s.totalSize + "px"
      }),
      class: ie(["vue-recycle-scroller__item-wrapper", t.listClass])
  }, {
      default: We(() => [(_(!0), T(F, null, ue(s.pool, o => (_(), xe(Xl(t.itemTag), $f({
          key: o.nr.id,
          style: s.ready ? {
              transform: `translate${i.direction==="vertical"?"Y":"X"}(${o.position}px) translate${i.direction==="vertical"?"X":"Y"}(${o.offset}px)`,
              width: t.gridItems ? `${i.direction==="vertical"&&t.itemSecondarySize||t.itemSize}px` : void 0,
              height: t.gridItems ? `${i.direction==="horizontal"&&t.itemSecondarySize||t.itemSize}px` : void 0
          } : null,
          class: ["vue-recycle-scroller__item-view", [t.itemClass, {
              hover: !t.skipHover && s.hoverKey === o.nr.key
          }]]
      }, t0(t.skipHover ? {} : {
          mouseenter: () => {
              s.hoverKey = o.nr.key
          },
          mouseleave: () => {
              s.hoverKey = null
          }
      })), {
          default: We(() => [nr(i.$slots, "default", {
              item: o.item,
              index: o.nr.index,
              active: o.nr.used
          })]),
          _: 2
      }, 1040, ["style", "class"]))), 128)), nr(i.$slots, "empty")]),
      _: 3
  }, 8, ["style", "class"])), i.$slots.after ? (_(), T("div", WC, [nr(i.$slots, "after")], 512)) : ye("v-if", !0), z(a, {
      onNotify: r.handleResize
  }, null, 8, ["onNotify"])], 34)), [
      [l, r.handleVisibilityChange]
  ])
}
Ru.render = UC;
Ru.__file = "src/components/RecycleScroller.vue";
const jC = {
      class: "flex flex-col h-full"
  },
  HC = {
      class: "sticky top-0 bg-white dark:bg-slate-700 z-30 flex min-w-[640px]"
  },
  qC = {
      class: "flex-1 min-h-0"
  },
  GC = {
      class: "h-full min-w-[640px]"
  },
  KC = {
      class: "flex w-full border-b border-green-200 dark:border-gray-700"
  },
  XC = {
      key: 1,
      class: "divide-y divide-green-200 dark:divide-gray-700"
  },
  JC = U({
      name: "Transactions"
  }),
  YC = U({
      ...JC,
      props: {
          dev: {},
          ticker: {},
          decimals: {},
          isLoading: {
              type: Boolean
          },
          fills: {}
      },
      setup(i) {
          const e = i,
              t = q(() => [...e.fills].sort((s, r) => r.timestamp - s.timestamp)),
              n = [{
                  key: "account",
                  label: "Account",
                  align: "left",
                  width: "10%"
              }, {
                  key: "type",
                  label: "Type",
                  align: "right",
                  width: "15%"
              }, {
                  key: "price",
                  label: "Price",
                  align: "right",
                  width: "15%"
              }, {
                  key: "usdcDelta",
                  label: "USDC",
                  align: "right",
                  width: "15%"
              }, {
                  key: "launchDelta",
                  label: e.ticker,
                  align: "right",
                  width: "15%"
              }, {
                  key: "date",
                  label: "Date",
                  align: "right",
                  width: "15%"
              }, {
                  key: "transaction",
                  label: "Transaction",
                  align: "right",
                  width: "15%"
              }];
          return (s, r) => (_(), T("div", jC, [m("div", HC, [(_(), T(F, null, ue(n, a => m("div", {
              key: a.key,
              style: tt([{
                  width: a.width
              }]),
              class: ie(["py-3 px-3 text-sm font-semibold text-gray-900 dark:text-gray-300 cursor-pointer whitespace-nowrap", a.align === "right" ? "text-right" : "text-left", a.key === "base.name" ? "sticky left-0 bg-white z-20" : "", a.key === "usdcDelta" || a.key === "launchDelta" ? "sm:min-w-[140px]" : ""])
          }, A(a.label), 7)), 64))]), m("div", qC, [m("div", GC, [s.isLoading ? (_(), T("div", XC, [(_(), T(F, null, ue(10, a => z(yC, {
              key: a,
              columns: n
          })), 64))])) : (_(), xe(pe(Ru), {
              key: 0,
              class: "h-full custom-scrollbar",
              items: t.value,
              "item-size": 53,
              "key-field": "id"
          }, {
              default: We(({
                  item: a
              }) => [m("div", KC, [z(pC, {
                  fill: a,
                  dev: s.dev,
                  columns: n,
                  decimals: s.decimals
              }, null, 8, ["fill", "dev", "decimals"])])]),
              _: 1
          }, 8, ["items"]))])])]))
      }
  });
const QC = Ee(YC, [
      ["__scopeId", "data-v-386e8fec"]
  ]),
  ZC = {
      key: 0,
      class: "text-[10px] md:text-xs font-bold text-orange-700 bg-orange-200 ml-2 px-0.5 rounded-md"
  },
  e$ = U({
      name: "HolderRow"
  }),
  t$ = U({
      ...e$,
      props: {
          position: {},
          total: {},
          decimals: {},
          dev: {},
          columns: {}
      },
      setup(i) {
          const e = i,
              t = n => {
                  switch (n) {
                      case "account":
                          const s = e.position.address;
                          return `${s.slice(0,4)}...${s.slice(-4)}`;
                      case "balance":
                          return Hn(e.position.balance / Math.pow(10, e.decimals));
                      case "percentage":
                          return (e.position.balance / e.total * 100).toFixed(2) + "%";
                      default:
                          return ""
                  }
              };
          return (n, s) => {
              const r = st("router-link");
              return _(), T("tr", null, [(_(!0), T(F, null, ue(n.columns, a => (_(), T("td", {
                  key: a.key,
                  class: ie(["whitespace-nowrap py-4 px-3 text-sm", a.align === "right" ? "text-right" : "text-left", a.key === "base.name" ? "font-medium text-gray-900 dark:text-gray-300 sticky left-0 bg-white dark:text-gray-300 z-10" : "text-gray-500 dark:text-gray-300"]),
                  style: tt({
                      width: a.width
                  })
              }, [a.key === "account" ? (_(), xe(r, {
                  key: 0,
                  to: "/wallet/" + n.position.address
              }, {
                  default: We(() => [z(es, {
                      "wallet-address": n.position.address
                  }, null, 8, ["wallet-address"]), n.position.address === n.dev ? (_(), T("span", ZC, " dev ")) : ye("", !0)]),
                  _: 1
              }, 8, ["to"])) : (_(), T(F, {
                  key: 1
              }, [Xe(A(t(a.key)), 1)], 64))], 6))), 128))])
          }
      }
  }),
  i$ = {
      class: "h-full flex flex-col"
  },
  n$ = {
      class: "w-full sm:min-w-[640px]"
  },
  s$ = {
      class: "sticky top-0 z-20 bg-white dark:bg-slate-700 rounded-t-lg"
  },
  r$ = {
      class: "flex-grow overflow-y-auto custom-scrollbar pr-1"
  },
  a$ = {
      class: "w-full sm:min-w-[640px]"
  },
  l$ = {
      class: "divide-y divide-green-200 dark:divide-gray-700 w-full"
  },
  o$ = U({
      __name: "Holders",
      props: {
          decimals: {},
          dev: {}
      },
      setup(i) {
          const e = Zn(),
              t = St();
          e.params.id;
          const n = [{
                  key: "account",
                  label: "Account",
                  align: "left",
                  width: "14%"
              }, {
                  key: "balance",
                  label: "Balance",
                  align: "right",
                  width: "14%"
              }, {
                  key: "percentage",
                  label: "Percentage",
                  align: "right",
                  width: "19%"
              }],
              s = q(() => t.positions.filter(a => a.balance > 0).sort((a, l) => l.balance - a.balance)),
              r = q(() => t.positions.reduce((a, l) => a + l.balance, 0));
          return (a, l) => (_(), T("div", i$, [m("table", n$, [m("thead", s$, [m("tr", null, [(_(), T(F, null, ue(n, o => m("th", {
              key: o.key,
              scope: "col",
              style: tt({
                  width: o.width
              }),
              class: ie(["py-3 px-3 text-sm font-semibold text-gray-900 dark:text-gray-300 cursor-pointer white-space-nowrap", o.align === "right" ? "text-right" : "text-left", o.key === "base.name" ? "sticky left-0 bg-white z-20" : ""])
          }, A(o.label), 7)), 64))])])]), m("div", r$, [m("table", a$, [m("tbody", l$, [(_(!0), T(F, null, ue(s.value, o => (_(), xe(t$, {
              key: o.address,
              position: o,
              decimals: a.decimals,
              total: r.value,
              columns: n,
              dev: a.dev
          }, null, 8, ["position", "decimals", "total", "dev"]))), 128))])])])]))
      }
  }),
  u$ = {
      class: "transition-colors duration-150"
  },
  c$ = {
      key: 0,
      class: "text-[10px] md:text-xs font-bold text-orange-700 bg-orange-200 ml-2 px-0.5 rounded-md"
  },
  h$ = U({
      name: "TraderRow"
  }),
  d$ = U({
      ...h$,
      props: {
          position: {},
          price: {},
          decimals: {},
          dev: {},
          columns: {}
      },
      setup(i) {
          const e = i,
              t = s => {
                  switch (s) {
                      case "account":
                          const r = e.position.address;
                          return `${r.slice(0,4)}...${r.slice(-4)}`;
                      case "balance":
                          return Hn(e.position.balance / Math.pow(10, e.decimals));
                      case "pnl":
                          return Hn(Yr(e.position, e.price, e.decimals));
                      default:
                          return ""
                  }
              },
              n = s => Yr(s, e.price, e.decimals) >= 0 ? "text-green-500" : "text-red-500";
          return (s, r) => {
              const a = st("router-link");
              return _(), T("tr", u$, [(_(!0), T(F, null, ue(s.columns, l => (_(), T("td", {
                  key: l.key,
                  class: ie(["whitespace-nowrap py-4 px-4 text-sm", l.align === "right" ? "text-right" : "text-left", l.key === "account" ? "font-medium text-gray-900 dark:text-gray-300 sticky left-0 bg-white dark:bg-slate-800 z-10" : "text-gray-600 dark:text-gray-400"]),
                  style: tt({
                      width: l.width
                  })
              }, [l.key === "account" ? (_(), xe(a, {
                  key: 0,
                  to: "/wallet/" + s.position.address,
                  class: "hover:text-blue-500 dark:hover:text-blue-400 transition-colors duration-150"
              }, {
                  default: We(() => [z(es, {
                      "wallet-address": s.position.address
                  }, null, 8, ["wallet-address"]), s.position.address === s.dev ? (_(), T("span", c$, " dev ")) : ye("", !0)]),
                  _: 1
              }, 8, ["to"])) : l.key === "pnl" ? (_(), T("span", {
                  key: 1,
                  class: ie(n(s.position))
              }, A(t(l.key)), 3)) : (_(), T(F, {
                  key: 2
              }, [Xe(A(t(l.key)), 1)], 64))], 6))), 128))])
          }
      }
  }),
  f$ = {
      class: "h-full flex flex-col"
  },
  p$ = {
      class: "w-full sm:min-w-[640px]"
  },
  m$ = {
      class: "sticky top-0 z-20 bg-white dark:bg-slate-700 rounded-t-lg"
  },
  g$ = {
      class: "flex-grow overflow-y-auto custom-scrollbar pr-1"
  },
  y$ = {
      class: "w-full sm:min-w-[640px]"
  },
  v$ = {
      class: "divide-y divide-green-200 dark:divide-gray-700 w-full"
  },
  b$ = U({
      __name: "Traders",
      props: {
          dev: {},
          decimals: {},
          price: {},
          positions: {}
      },
      setup(i) {
          Zn(), St();
          const e = i,
              t = q(() => e.positions.sort((s, r) => Yr(r, e.price, e.decimals) - Yr(s, e.price, e.decimals))),
              n = [{
                  key: "account",
                  label: "Account",
                  align: "left",
                  width: "14%"
              }, {
                  key: "balance",
                  label: "Balance",
                  align: "right",
                  width: "14%"
              }, {
                  key: "pnl",
                  label: "PnL",
                  align: "right",
                  width: "19%"
              }];
          return (s, r) => (_(), T("div", f$, [m("table", p$, [m("thead", m$, [m("tr", null, [(_(), T(F, null, ue(n, a => m("th", {
              key: a.key,
              scope: "col",
              style: tt({
                  width: a.width
              }),
              class: ie(["py-3 px-3 text-sm font-semibold text-gray-900 dark:text-gray-300 cursor-pointer white-space-nowrap", a.align === "right" ? "text-right" : "text-left", a.key === "base.name" ? "sticky left-0 bg-white z-20" : ""])
          }, A(a.label), 7)), 64))])])]), m("div", g$, [m("table", y$, [m("tbody", v$, [(_(!0), T(F, null, ue(t.value, a => (_(), xe(d$, {
              key: a.address,
              position: a,
              price: s.price,
              decimals: s.decimals,
              columns: n,
              dev: s.dev
          }, null, 8, ["position", "price", "decimals", "dev"]))), 128))])])])]))
      }
  }),
  w$ = {
      class: "border-b border-green-200 dark:border-green-700"
  },
  k$ = {
      class: "-mb-px flex space-x-4"
  },
  _$ = ["onClick"],
  x$ = {
      class: "overflow-hidden h-full"
  },
  T$ = U({
      name: "MarketData"
  }),
  Po = U({
      ...T$,
      props: {
          launch: {}
      },
      setup(i) {
          const e = i,
              t = ["Transactions", "Top Traders", "Holders"],
              n = M(t[0]),
              s = M(!0),
              r = M(null),
              a = St(),
              l = q(() => a.fills.sort((c, h) => h.timestamp - c.timestamp)),
              o = q(() => a.positions),
              u = async () => {
                  r.value = setTimeout(() => {
                      s.value = !0
                  }, 100);
                  try {
                      await a.startFillStream(e.launch.id)
                  } finally {
                      r.value && clearTimeout(r.value), s.value = !1
                  }
              };
          return Te(async () => {
              await u()
          }), ct(() => {
              r.value && clearTimeout(r.value), a.stopFillStream()
          }), (c, h) => (_(), T(F, null, [m("div", w$, [m("nav", k$, [(_(), T(F, null, ue(t, d => m("a", {
              key: d,
              onClick: f => n.value = d,
              class: ie([n.value === d ? "border-green-500 text-green-600 dark:text-green-400" : "border-transparent text-gray-500 hover:text-green-700 dark:text-gray-300 dark:hover:text-green-400 hover:border-green-300 ease-in-out duration-300", "cursor-pointer whitespace-nowrap py-2 px-1 border-b-2 dark:border-grey-200 font-medium text-sm"])
          }, A(d), 11, _$)), 64))])]), m("div", x$, [n.value === "Transactions" ? (_(), xe(QC, {
              key: 0,
              dev: c.launch.devWallet?.ethereumAddress ?? "",
              fills: l.value,
              "is-loading": s.value,
              decimals: e.launch.decimals,
              ticker: e.launch.session?.tokenName
          }, null, 8, ["dev", "fills", "is-loading", "decimals", "ticker"])) : ye("", !0), n.value === "Holders" ? (_(), xe(o$, {
              key: 1,
              dev: c.launch.devWallet?.ethereumAddress ?? "",
              positions: o.value,
              decimals: e.launch.decimals
          }, null, 8, ["dev", "positions", "decimals"])) : ye("", !0), n.value === "Top Traders" ? (_(), xe(b$, {
              key: 2,
              dev: c.launch.devWallet?.ethereumAddress ?? "",
              positions: o.value,
              price: pe(Jr)(e.launch),
              decimals: e.launch.decimals
          }, null, 8, ["dev", "positions", "price", "decimals"])) : ye("", !0)])], 64))
      }
  }),
  S$ = U({
      name: "TradeCard"
  }),
  E$ = {
      class: "mb-8"
  };

function C$(i, e, t, n, s, r) {
  return _(), T("div", E$, e[0] || (e[0] = [m("h2", {
      class: "text-xl font-semibold mb-4"
  }, "Trade", -1), m("p", null, "Buy/Sell form", -1)]))
}
const $$ = Ee(S$, [
      ["render", C$]
  ]),
  L$ = {
      class: "mb-4 flex space-x-4"
  },
  P$ = {
      class: "min-w-16 md:min-w-32 flex-shrink-0 relative"
  },
  I$ = {
      class: "pulse-loader absolute inset-0 rounded-lg w-16 h-16 md:w-32 md:h-32 bg-gray-300 dark:bg-slate-700"
  },
  N$ = ["alt", "src"],
  M$ = ["src"],
  R$ = {
      class: "text-sm md:text-md font-semibold flex flex-row items-center gap-1"
  },
  B$ = {
      class: "text-gray-500"
  },
  O$ = {
      key: 0
  },
  D$ = {
      class: "text-[10px] md:text-xs"
  },
  F$ = U({
      name: "TokenInfo"
  }),
  A$ = U({
      ...F$,
      props: {
          launch: {}
      },
      setup(i) {
          const e = i,
              t = M(!1),
              n = q(() => !e.launch || !e.launch.session ? "Unknown" : e.launch.session.fullName),
              s = q(() => !e.launch || !e.launch.session ? "Unknown" : e.launch.session.tokenName),
              r = q(() => !e.launch || !e.launch.session ? "Unknown" : `https://media.hypurr.fun/${e.launch.mediaFileId}`);
          return (a, l) => (_(), T("div", L$, [m("div", P$, [Mt(m("div", I$, null, 512), [
              [Ls, !t.value]
          ]), a.launch.mediaType == "photo" ? (_(), T("img", {
              key: 0,
              alt: s.value,
              loading: "lazy",
              width: "128",
              height: "128",
              decoding: "async",
              "data-nimg": "1",
              class: ie(["w-16 h-16 md:w-32 md:h-32 object-cover rounded-lg", {
                  "opacity-0": !t.value
              }]),
              src: r.value,
              onLoad: l[0] || (l[0] = o => t.value = !0)
          }, null, 42, N$)) : (_(), T("video", {
              key: 1,
              width: "128",
              height: "128",
              "data-nimg": "1",
              class: "w-16 h-16 md:w-32 md:h-32 object-cover rounded-lg",
              onCanplay: l[1] || (l[1] = o => t.value = !0),
              muted: !0,
              autoplay: "",
              loop: "",
              playsinline: ""
          }, [m("source", {
              src: r.value,
              type: "video/mp4"
          }, null, 8, M$), l[2] || (l[2] = Xe(" Your browser does not support the video tag. "))], 32))]), m("div", null, [m("h2", R$, [Xe(A(n.value) + " ", 1), m("p", B$, "(" + A(s.value) + ")", 1)]), a.launch ? (_(), T("div", O$, [m("p", D$, A(a.launch.description), 1)])) : ye("", !0)])]))
      }
  });
const Io = Ee(A$, [
      ["__scopeId", "data-v-f82ffaa3"]
  ]),
  V$ = U({
      name: "MessageRowSkeleton"
  }),
  z$ = {
      class: "flex items-start space-x-3 p-2 rounded-lg bg-gray-50 dark:bg-slate-700 rounded-md mr-1"
  };

function W$(i, e, t, n, s, r) {
  return _(), T("div", z$, e[0] || (e[0] = [un('<div class="h-6 w-6 bg-gray-300 dark:bg-gray-500 rounded-full animate-pulse"></div><div class="flex-1"><div class="flex items-center space-x-1 mb-1"><div class="h-4 w-28 bg-gray-300 dark:bg-gray-500 rounded animate-pulse mr-1"></div><div class="h-3 w-16 bg-gray-300 dark:bg-gray-500 rounded animate-pulse"></div><div class="h-3 w-16 bg-gray-300 dark:bg-gray-500 rounded animate-pulse"></div></div><div class="space-y-2"><div class="h-4 w-3/4 bg-gray-300 dark:bg-gray-500 rounded animate-pulse"></div><div class="h-4 w-3/4 bg-gray-300 dark:bg-gray-500 rounded animate-pulse"></div></div></div>', 2)]))
}
const hm = Ee(V$, [
      ["render", W$]
  ]),
  U$ = {
      class: "flex flex-col items-start mt-2 bg-gray-50 dark:bg-slate-700 px-4 py-1 rounded-md"
  },
  j$ = {
      type: "button",
      class: "flex items-center space-x-2"
  },
  H$ = {
      class: "flex gap-1 items-center"
  },
  q$ = ["alt", "src"],
  G$ = {
      class: "text-[10px] md:text-xs font-bold text-green-700 bg-green-200 px-1 rounded-md"
  },
  K$ = {
      key: 0,
      class: "text-[10px] md:text-xs font-bold text-orange-700 bg-orange-200 px-1 rounded-md"
  },
  X$ = {
      class: "text-[10px] md:text-xs text-gray-500 dark:text-gray-400"
  },
  J$ = {
      class: "flex flex-col"
  },
  Y$ = {
      class: "text-xs md:text-sm text-gray-900 dark:text-gray-200"
  },
  Q$ = U({
      name: "MessageRow"
  }),
  dm = U({
      ...Q$,
      props: {
          message: {},
          dev: {}
      },
      setup(i) {
          const e = i,
              t = q(() => !e.message || !e.message.author ? "" : e.message.author.username),
              n = q(() => !e.message || !e.message.author || e.message.author.pictureFileId == "" ? Is : "https://media.hypurr.fun/" + e.message.author.pictureFileId);
          return (s, r) => (_(), T("div", U$, [m("button", j$, [m("span", H$, [m("img", {
              alt: t.value,
              loading: "lazy",
              width: "24",
              height: "24",
              decoding: "async",
              "data-nimg": "1",
              class: "w-6 h-6 rounded-full",
              src: n.value
          }, null, 8, q$), m("span", G$, A(t.value === "" ? "Hypurr Doe" : t.value), 1), e.message.author.id === s.dev ? (_(), T("span", K$, " dev ")) : ye("", !0)]), m("span", X$, A(new Date(e.message.timestamp).toLocaleString()), 1)]), m("div", J$, [m("span", Y$, A(e.message.message), 1)])]))
      }
  });

function Z$(i, e) {
  return _(), T("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      "stroke-width": "1.5",
      stroke: "currentColor",
      "aria-hidden": "true",
      "data-slot": "icon"
  }, [m("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M15.75 9V5.25A2.25 2.25 0 0 0 13.5 3h-6a2.25 2.25 0 0 0-2.25 2.25v13.5A2.25 2.25 0 0 0 7.5 21h6a2.25 2.25 0 0 0 2.25-2.25V15m3 0 3-3m0 0-3-3m3 3H9"
  })])
}

function od(i, e) {
  return _(), T("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      "stroke-width": "1.5",
      stroke: "currentColor",
      "aria-hidden": "true",
      "data-slot": "icon"
  }, [m("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M13.5 6H5.25A2.25 2.25 0 0 0 3 8.25v10.5A2.25 2.25 0 0 0 5.25 21h10.5A2.25 2.25 0 0 0 18 18.75V10.5m-10.5 6L21 3m0 0h-5.25M21 3v5.25"
  })])
}

function fm(i, e) {
  return _(), T("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      "stroke-width": "1.5",
      stroke: "currentColor",
      "aria-hidden": "true",
      "data-slot": "icon"
  }, [m("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "m19.5 8.25-7.5 7.5-7.5-7.5"
  })])
}

function eL(i, e) {
  return _(), T("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      "stroke-width": "1.5",
      stroke: "currentColor",
      "aria-hidden": "true",
      "data-slot": "icon"
  }, [m("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "m4.5 15.75 7.5-7.5 7.5 7.5"
  })])
}

function tL(i, e) {
  return _(), T("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      viewBox: "0 0 24 24",
      "stroke-width": "1.5",
      stroke: "currentColor",
      "aria-hidden": "true",
      "data-slot": "icon"
  }, [m("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M21 12a2.25 2.25 0 0 0-2.25-2.25H15a3 3 0 1 1-6 0H5.25A2.25 2.25 0 0 0 3 12m18 0v6a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 18v-6m18 0V9M3 12V9m18 0a2.25 2.25 0 0 0-2.25-2.25H5.25A2.25 2.25 0 0 0 3 9m18 0V6a2.25 2.25 0 0 0-2.25-2.25H5.25A2.25 2.25 0 0 0 3 6v3"
  })])
}
const iL = {
      class: "flex flex-col h-full overflow-hidden"
  },
  nL = {
      class: "flex flex-col space-y-1 mb-4"
  },
  sL = {
      class: "text-sm text-blue-500 flex space-x-4 items-center"
  },
  rL = ["href"],
  aL = ["href"],
  lL = {
      class: "space-y-2 w-full"
  },
  oL = U({
      name: "Commentary",
      components: {
          MessageRowSkeleton: hm,
          MessageRow: dm
      }
  }),
  Kn = U({
      ...oL,
      props: {
          pair: {},
          launch: {}
      },
      setup(i) {
          const e = i,
              t = si(),
              n = St(),
              s = q(() => e.launch ? n.messages : e.pair ? t.messages : []),
              r = M(null),
              a = M(!0),
              l = () => {
                  if (!r.value) return;
                  const {
                      scrollTop: u,
                      scrollHeight: c,
                      clientHeight: h
                  } = r.value, d = c - u - h < 100;
                  a.value = d
              };
          Ie(() => s.value, () => {
              a.value && r.value && pi(() => {
                  r.value.scrollTop = r.value.scrollHeight
              })
          }, {
              deep: !0
          }), Te(() => {
              r.value && (r.value.scrollTop = r.value.scrollHeight)
          }), Te(() => {
              e.launch ? n.startMessageStream(e.launch?.id ?? 0) : e.pair && (console.log("fetching base token messages", e.pair.base.id), t.startMessageStream(e.pair?.base?.id ?? 0))
          }), ct(() => {
              e.launch ? n.stopMessageStream() : e.pair && t.stopMessageStream()
          });
          const o = {
              mounted(u) {
                  const c = () => {
                      const d = u.scrollHeight,
                          f = u.clientHeight,
                          p = Math.max(32, f / d * f);
                      u.style.setProperty("--scrollbar-thumb-height", `${p}px`)
                  };
                  c();
                  const h = new MutationObserver(c);
                  h.observe(u, {
                      childList: !0,
                      subtree: !0
                  }), u._cleanup = () => h.disconnect()
              },
              unmounted(u) {
                  u._cleanup && u._cleanup()
              }
          };
          return (u, c) => (_(), T("div", iL, [m("div", nL, [c[2] || (c[2] = m("h2", {
              class: "text-xl font-semibold"
          }, "Thread", -1)), m("div", sL, [u.launch && u.launch.topicId ? (_(), T("a", {
              key: 0,
              class: "text-sm text-blue-500 flex items-center",
              target: "_blank",
              href: "https://t.me/c/2195541592/" + u.launch.topicId?.value
          }, [c[0] || (c[0] = Xe(" Join the chat ")), z(pe(od), {
              class: "ml-1 h-4 w-4",
              "aria-hidden": "true"
          })], 8, rL)) : ye("", !0), u.launch && u.launch.topicId ? (_(), T("a", {
              key: 1,
              class: "text-sm text-blue-500 flex items-center",
              target: "_blank",
              href: "https://t.me/HypurrFunBot?start=launch_" + u.launch.id
          }, [c[1] || (c[1] = Xe(" Trade on Telegram ")), z(pe(od), {
              class: "ml-1 h-4 w-4",
              "aria-hidden": "true"
          })], 8, aL)) : ye("", !0)])]), Mt((_(), T("div", {
              ref_key: "chatContainer",
              ref: r,
              class: "flex-grow overflow-y-auto overflow-x-hidden custom-scrollbar h-full pr-1",
              onScroll: l
          }, [m("div", lL, [s.value.length === 0 ? (_(), T(F, {
              key: 0
          }, ue(10, h => z(hm, {
              key: h
          })), 64)) : (_(!0), T(F, {
              key: 1
          }, ue(s.value, h => (_(), xe(dm, {
              key: h.id,
              message: h,
              dev: u.launch?.telegramUser?.id
          }, null, 8, ["message", "dev"]))), 128))])], 32)), [
              [o]
          ])]))
      }
  }),
  uL = U({
      name: "PriceChartSkeleton"
  }),
  cL = {
      class: "animate-pulse"
  };

function hL(i, e, t, n, s, r) {
  return _(), T("div", cL, e[0] || (e[0] = [m("div", {
      class: "h-4 bg-gray-200 dark:bg-slate-700 rounded w-3/4 mb-2"
  }, null, -1), m("div", {
      class: "h-7 bg-gray-200 dark:bg-slate-700 rounded w-1/2 mb-4"
  }, null, -1), m("div", {
      class: "h-56 sm:h-80 bg-gray-200 dark:bg-slate-700 rounded"
  }, null, -1)]))
}
const Xn = Ee(uL, [
      ["render", hL]
  ]),
  dL = U({
      name: "MarketDataSkeleton"
  }),
  fL = {
      class: "animate-pulse h-[100%] lg:h-[60%] flex flex-col mt-8"
  };

function pL(i, e, t, n, s, r) {
  return _(), T("div", fL, [e[1] || (e[1] = m("div", {
      class: "h-11 bg-gray-200 dark:bg-slate-700 rounded w-full"
  }, null, -1)), (_(), T(F, null, ue(5, a => m("div", {
      key: a,
      class: "flex"
  }, e[0] || (e[0] = [m("div", {
      class: "h-12 bg-gray-200 dark:bg-slate-700 rounded w-full my-1 py-4"
  }, null, -1)]))), 64))])
}
const Jn = Ee(dL, [
      ["render", pL]
  ]),
  mL = U({
      name: "TradeCardSkeleton"
  }),
  gL = {
      class: "animate-pulse mb-8"
  };

function yL(i, e, t, n, s, r) {
  return _(), T("div", gL, e[0] || (e[0] = [m("div", {
      class: "h-6 bg-gray-200 dark:bg-slate-700 rounded w-1/4 mb-4"
  }, null, -1)]))
}
const pm = Ee(mL, [
      ["render", yL]
  ]),
  vL = U({
      name: "TokenInfoSkeleton"
  }),
  bL = {
      class: "animate-pulse mb-4 flex space-x-4"
  };

function wL(i, e, t, n, s, r) {
  return _(), T("div", bL, e[0] || (e[0] = [un('<div class="w-16 h-16 md:w-32 md:h-32 bg-gray-200 dark:bg-slate-700 rounded-lg"></div><div class="flex-1"><div class="flex flex-row"><div class="h-4 bg-gray-200 dark:bg-slate-700 rounded w-2/4 mb-2"></div><div class="h-4 bg-gray-200 dark:bg-slate-700 rounded w-10 ml-1 mb-2"></div></div><div class="h-2 bg-gray-200 dark:bg-slate-700 rounded w-1/2 mb-2"></div><div class="h-2 bg-gray-200 dark:bg-slate-700 rounded w-full"></div></div>', 2)]))
}
const Yn = Ee(vL, [
      ["render", wL]
  ]),
  kL = U({
      name: "CommentarySkeleton"
  }),
  _L = {
      class: "animate-pulse h-full w-full"
  };

function xL(i, e, t, n, s, r) {
  return _(), T("div", _L, e[0] || (e[0] = [m("div", {
      class: "h-6 bg-gray-200 dark:bg-slate-700 rounded w-1/4 mb-4"
  }, null, -1), m("div", {
      class: "h-4 bg-gray-200 dark:bg-slate-700 rounded w-1/4 mb-4"
  }, null, -1), m("div", {
      class: "h-[calc(100%-72px)] bg-gray-200 dark:bg-slate-700 rounded w-full mb-4"
  }, null, -1)]))
}
const Qn = Ee(kL, [
      ["render", xL]
  ]),
  TL = U({
      name: "LaunchProgressSkeleton"
  }),
  SL = {
      class: "mt-4 px-2 w-full mb-4"
  };

function EL(i, e, t, n, s, r) {
  return _(), T("div", SL, e[0] || (e[0] = [un('<div class="animate-pulse"><div class="h-3 w-32 bg-gray-200 dark:bg-gray-700 rounded mb-1"></div><div class="space-y-1"><div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full"></div><div class="flex items-center"><div class="h-3 w-6 bg-gray-200 dark:bg-gray-700 rounded mr-1"></div><div class="h-1 w-2 bg-gray-200 dark:bg-gray-700 rounded mr-1"></div><div class="h-3 w-10 bg-gray-200 dark:bg-gray-700 rounded"></div></div></div></div>', 1)]))
}
const mm = Ee(TL, [
      ["render", EL]
  ]),
  gm = Xi("notification", () => {
      const i = M([]);
      let e = 0;
      const t = s => {
              const r = e++,
                  a = s.duration || 5e3;
              i.value.push({
                  id: r,
                  ...s
              }), setTimeout(() => {
                  n(r)
              }, a)
          },
          n = s => {
              i.value = i.value.filter(r => r.id !== s)
          };
      return {
          notifications: i,
          addNotification: t,
          removeNotification: n
      }
  }),
  CL = {
      class: "relative"
  },
  $L = {
      class: "flex items-center space-x-2"
  },
  LL = {
      class: "dark:text-white"
  },
  PL = {
      key: 0,
      class: "absolute mt-2 w-full bg-white dark:bg-gray-800 rounded-lg shadow-lg z-50 border border-gray-200 dark:border-gray-700"
  },
  IL = {
      class: "py-1 relative"
  },
  NL = ["onClick"],
  ym = U({
      __name: "WalletSelector",
      props: {
          modelValue: {},
          wallets: {}
      },
      emits: ["update:modelValue"],
      setup(i, {
          emit: e
      }) {
          const t = e,
              n = M(!1);

          function s() {
              n.value = !n.value
          }

          function r(l) {
              t("update:modelValue", l), n.value = !1
          }

          function a(l) {
              l.target.closest(".relative") || (n.value = !1)
          }
          return Te(() => {
              document.addEventListener("click", a)
          }), ct(() => {
              document.removeEventListener("click", a)
          }), (l, o) => (_(), T("div", CL, [m("div", $L, [o[0] || (o[0] = m("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              fill: "none",
              viewBox: "0 0 24 24",
              "stroke-width": "1.5",
              stroke: "currentColor",
              class: "w-5 h-5"
          }, [m("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              d: "M21 12a2.25 2.25 0 0 0-2.25-2.25H15a3 3 0 1 1-6 0H5.25A2.25 2.25 0 0 0 3 12m18 0v6a2.25 2.25 0 0 1-2.25 2.25H5.25A2.25 2.25 0 0 1 3 18v-6m18 0V9M3 12V9m18 0a2.25 2.25 0 0 0-2.25-2.25H5.25A2.25 2.25 0 0 0 3 9"
          })], -1)), m("button", {
              onClick: s,
              class: "flex items-center justify-between w-24 px-3 py-1 text-sm rounded-lg bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 focus:outline-none focus:ring-1 focus:ring-green-500 dark:focus:ring-green-400"
          }, [m("span", LL, A(l.modelValue?.name || "Select Wallet"), 1), z(pe(fm), {
              class: "w-4 h-4 dark:text-white"
          })])]), z(ga, {
              "enter-active-class": "transition ease-out duration-200",
              "enter-from-class": "transform opacity-0 scale-95",
              "enter-to-class": "transform opacity-100 scale-100",
              "leave-active-class": "transition ease-in duration-75",
              "leave-from-class": "transform opacity-100 scale-100",
              "leave-to-class": "transform opacity-0 scale-95"
          }, {
              default: We(() => [n.value ? (_(), T("div", PL, [o[1] || (o[1] = m("div", {
                  class: "absolute -top-2 left-1/2 -ml-2 w-4 h-4 rotate-45 bg-white dark:bg-gray-800 border-t border-l border-gray-200 dark:border-gray-700"
              }, null, -1)), m("div", IL, [(_(!0), T(F, null, ue(l.wallets, u => (_(), T("button", {
                  key: u.id,
                  onClick: c => r(u),
                  class: "w-full flex items-center px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-150"
              }, A(u.name), 9, NL))), 128))])])) : ye("", !0)]),
              _: 1
          })]))
      }
  }),
  ML = {
      class: "bg-white dark:bg-slate-800 text-gray-900 dark:text-white rounded-lg border border-gray-200 dark:border-gray-700 p-2 mb-3"
  },
  RL = {
      class: "border-b border-gray-200 dark:border-gray-700"
  },
  BL = {
      class: "flex space-x-4",
      "aria-label": "Tabs"
  },
  OL = ["onClick"],
  DL = {
      class: "mt-2 flex items-center justify-between"
  },
  FL = {
      class: "flex items-center space-x-1 text-sm"
  },
  AL = {
      class: "font-medium text-gray-900 dark:text-gray-100"
  },
  VL = {
      class: "mt-2 grid grid-cols-3 gap-2"
  },
  zL = ["id", "value", "checked"],
  WL = ["for"],
  UL = {
      class: "mt-2"
  },
  jL = ["placeholder"],
  HL = {
      class: "mt-2 flex justify-between text-xs"
  },
  qL = {
      key: 0,
      class: "mt-2 p-2 bg-red-100 dark:bg-red-900 text-red-700 dark:text-red-100 rounded-md text-xs"
  },
  GL = ["disabled"],
  KL = {
      key: 0,
      class: "absolute inset-0 flex items-center justify-center"
  },
  XL = U({
      __name: "TradeWidget",
      props: {
          launch: {}
      },
      setup(i) {
          M(null);
          const e = Ji();
          q(() => e.user);
          const t = M(null),
              n = q(() => e.user ? e.user.user.wallets.filter(x => !x.isAgent && !x.isReadOnly) : []),
              s = i,
              r = M("Buy"),
              a = [{
                  name: "Buy",
                  label: "Buy"
              }, {
                  name: "Sell",
                  label: "Sell"
              }],
              l = [10, 20, 100],
              o = [25, 50, 100],
              u = M(l[0]),
              c = M(0),
              h = M(""),
              d = q(() => c.value ? r.value === "Buy" ? `${c.value} USDC` : `${c.value}%` : r.value === "Buy" ? `${u.value} USDC` : `${u.value}%`);
          Ie(r, x => {
              c.value = 0, u.value = x === "Buy" ? l[0] : o[0]
          });
          const f = gm(),
              p = M(!1),
              g = async () => {
                  if (!t.value) {
                      f.addNotification({
                          message: "Please select a wallet",
                          type: "error"
                      });
                      return
                  }
                  p.value = !0;
                  const x = c.value || u.value;
                  if (x == null) {
                      f.addNotification({
                          message: "Please enter a valid amount",
                          type: "error"
                      }), p.value = !1;
                      return
                  }
                  try {
                      let k = r.value === "Buy" ? Hr.BUY : Hr.SELL,
                          S = await e.onLaunchTrade(s.launch.id, s.launch.decimals, t.value.id, k, x);
                      S.success ? (f.addNotification({
                          message: S.message,
                          type: "success"
                      }), await pi(), e.user?.user && (t.value = e.user.user.wallets.find(B => B.id === t.value?.id) || null)) : f.addNotification({
                          message: S.message,
                          type: "error"
                      })
                  } catch (k) {
                      console.log(k);
                      const S = k instanceof Error ? k.message : "Unknown error";
                      f.addNotification({
                          message: `Failed to place trade: ${S}`,
                          type: "error"
                      })
                  } finally {
                      p.value = !1
                  }
              };
          Te(() => {
              e.user?.user && (t.value = e.user.user.wallets.find(x => x.id === e.user.user.walletId) || null)
          });
          const w = x => {
                  c.value && (u.value = null)
              },
              y = () => {
                  c.value = 0
              },
              b = q(() => {
                  if (!t.value?.launchBalances) return 0;
                  let k = (t.value.launchBalances.find(S => S.launchId === s.launch.id)?.balance || 0) / Math.pow(10, s.launch.decimals);
                  return Hn(k)
              });
          return Ie(() => e.user?.user?.wallets, x => {
              x && t.value && (t.value = x.find(k => k.id === t.value?.id) || null)
          }, {
              deep: !0
          }), (x, k) => (_(), T("div", ML, [m("div", RL, [m("nav", BL, [(_(), T(F, null, ue(a, S => m("button", {
              key: S.name,
              onClick: B => r.value = S.name,
              class: ie([r.value === S.name ? S.name === "Buy" ? "border-green-500 text-green-600 dark:text-green-400" : "border-red-500 text-red-600 dark:text-red-400" : "border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300", "whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"])
          }, A(S.label), 11, OL)), 64))])]), m("div", DL, [z(ym, {
              modelValue: t.value,
              "onUpdate:modelValue": k[0] || (k[0] = S => t.value = S),
              wallets: n.value
          }, null, 8, ["modelValue", "wallets"]), m("div", FL, [k[3] || (k[3] = m("span", {
              class: "text-gray-500 dark:text-gray-400"
          }, "Balance:", -1)), m("span", AL, A(b.value), 1)])]), m("div", VL, [(_(!0), T(F, null, ue(r.value === "Buy" ? l : o, S => (_(), T("div", {
              key: S,
              datatype: "number",
              class: "flex items-center"
          }, [Mt(m("input", {
              id: "amount-" + S,
              type: "radio",
              "onUpdate:modelValue": k[1] || (k[1] = B => u.value = B),
              value: S,
              checked: !c.value && u.value === S,
              onChange: y,
              class: "h-3 w-3 text-green-600 focus:ring-green-500 dark:bg-gray-700 border-gray-300 dark:border-gray-600"
          }, null, 40, zL), [
              [vy, u.value]
          ]), m("label", {
              for: "amount-" + S,
              class: "ml-1 text-xs"
          }, A(S) + A(r.value === "Buy" ? " USDC" : "%"), 9, WL)]))), 128))]), m("div", UL, [Mt(m("input", {
              type: "number",
              "onUpdate:modelValue": k[2] || (k[2] = S => c.value = S),
              onInput: w,
              placeholder: r.value === "Buy" ? "Enter USDC amount" : "Enter percentage",
              class: "block w-full text-xs rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-700 focus:border-green-500 focus:ring-green-500"
          }, null, 40, jL), [
              [zr, c.value]
          ])]), m("div", HL, [m("span", null, "Amount to " + A(r.value.toLowerCase()), 1), m("span", null, A(d.value), 1)]), h.value ? (_(), T("div", qL, A(h.value), 1)) : ye("", !0), m("button", {
              onClick: g,
              disabled: p.value,
              class: ie(["mt-2 w-full flex items-center justify-center px-3 py-1.5 border border-transparent rounded-md shadow-sm text-xs font-medium text-white relative", r.value === "Buy" ? "bg-green-600 hover:bg-green-700 focus:ring-green-500" : "bg-red-600 hover:bg-red-700 focus:ring-red-500", p.value ? "opacity-75 cursor-not-allowed" : ""])
          }, [m("span", {
              class: ie({
                  "opacity-0": p.value
              })
          }, " Quick " + A(r.value) + " " + A(d.value), 3), p.value ? (_(), T("div", KL, k[4] || (k[4] = [m("svg", {
              class: "animate-spin h-5 w-5 text-white",
              xmlns: "http://www.w3.org/2000/svg",
              fill: "none",
              viewBox: "0 0 24 24"
          }, [m("circle", {
              class: "opacity-25",
              cx: "12",
              cy: "12",
              r: "10",
              stroke: "currentColor",
              "stroke-width": "4"
          }), m("path", {
              class: "opacity-75",
              fill: "currentColor",
              d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
          })], -1)]))) : ye("", !0)], 10, GL)]))
      }
  });
const vm = Ee(XL, [
      ["__scopeId", "data-v-de362cb3"]
  ]),
  JL = {
      key: 0,
      class: "fixed bottom-0 left-0 right-0 bg-white dark:bg-slate-800 shadow-up p-2 flex justify-around lg:hidden z-50 h-14"
  },
  YL = ["onClick"],
  QL = {
      class: "max-w-screen-2xl mx-auto flex flex-col h-[calc(100vh-136px)] py-2 sm:py-4 z-10 relative px-2 sm:px-6 xl:px-2 overflow-y-auto landscape:overflow-y-auto"
  },
  ZL = {
      class: "grid grid-cols-1 lg:grid-cols-3 gap-8 h-full"
  },
  eP = {
      class: "lg:col-span-2 rounded-lg bg-white dark:bg-slate-800 dark:text-white border border-gray-300 dark:border-gray-700 shadow pb-2 px-2 sm:pb-4 sm:px-4 pt-1 h-full overflow-hidden flex flex-col"
  },
  tP = {
      class: "lg:col-span-1 rounded-lg bg-white dark:bg-slate-800 dark:text-white border border-gray-300 dark:border-gray-700 shadow p-2 sm:p-4 h-full overflow-hidden flex flex-col"
  },
  iP = {
      key: 1,
      class: "lg:col-span-1 rounded-lg bg-white dark:bg-slate-800 dark:text-white border border-gray-300 dark:border-gray-700 shadow p-2 sm:p-4 h-full overflow-hidden flex flex-col"
  },
  nP = [{
      name: "info",
      label: "Info"
  }, {
      name: "chart",
      label: "Chart"
  }],
  sP = U({
      name: "LaunchDetail",
      components: {
          PriceChart: So,
          MarketData: Po,
          TradeCard: $$,
          TokenInfo: Io,
          Commentary: Kn,
          LaunchProgress: ka,
          PriceChartSkeleton: Xn,
          MarketDataSkeleton: Jn,
          TradeCardSkeleton: pm,
          TokenInfoSkeleton: Yn,
          CommentarySkeleton: Qn,
          LaunchProgressSkeleton: mm,
          TradeWidget: vm
      }
  }),
  rP = U({
      ...sP,
      setup(i) {
          const e = Zn(),
              t = St(),
              n = e.params.id,
              s = M(!0),
              r = M(null),
              a = M(window.innerWidth < 1024),
              l = M("info"),
              o = Ji(),
              u = q(() => o.user),
              c = () => {
                  a.value = window.innerWidth < 1024
              };
          Te(() => {
              window.addEventListener("resize", c)
          }), ct(() => {
              window.removeEventListener("resize", c)
          }), Te(async () => {
              t.fetchAuction(), r.value = await t.fetchLaunch(parseInt(n)), s.value = !1
          });
          const h = q(() => r.value ? Jr(r.value) : 0),
              d = q(() => {
                  if (!r.value) return 0;
                  const p = r.value;
                  return -p.y / Math.pow(10, p.decimals) * h.value
              }),
              f = q(() => Math.min(Math.round(d.value / 1e6) * 100, 100));
          return q(() => f.value < 50 ? "Not ready" : f.value < 100 ? "Almost there" : "Ready for deployment"), (p, g) => (_(), T(F, null, [g[0] || (g[0] = m("div", {
              class: "absolute inset-y-0 right-1/2 z-1 -mr-96 w-[200%] origin-top-right skew-x-[-30deg] bg-white dark:bg-slate-900 ring-1 ring-green-50 sm:-mr-80 lg:-mr-48",
              "aria-hidden": "true"
          }, null, -1)), a.value ? (_(), T("div", JL, [(_(), T(F, null, ue(nP, w => m("button", {
              key: w.name,
              onClick: y => l.value = w.name,
              class: ie([l.value === w.name ? "border-green-500 text-green-600 dark:text-green-400 dark:border-green-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-green-700 hover:border-green-300 ease-in-out duration-300", "cursor-pointer whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"])
          }, A(w.label), 11, YL)), 64))])) : ye("", !0), m("div", QL, [m("div", ZL, [a.value ? (_(), T("div", iP, [l.value === "info" ? (_(), T(F, {
              key: 0
          }, [s.value ? (_(), T(F, {
              key: 0
          }, [z(Yn), z(Qn)], 64)) : (_(), T(F, {
              key: 1
          }, [z(Io, {
              launch: r.value
          }, null, 8, ["launch"]), z(Kn, {
              launch: r.value
          }, null, 8, ["launch"])], 64))], 64)) : ye("", !0), l.value === "chart" ? (_(), T(F, {
              key: 1
          }, [s.value ? (_(), T(F, {
              key: 0
          }, [z(Xn), z(Jn)], 64)) : (_(), T(F, {
              key: 1
          }, [z(So, {
              launch: r.value
          }, null, 8, ["launch"]), z(Po, {
              launch: r.value
          }, null, 8, ["launch"])], 64))], 64)) : ye("", !0)])) : (_(), T(F, {
              key: 0
          }, [m("div", eP, [s.value ? (_(), T(F, {
              key: 0
          }, [z(Xn), z(Jn)], 64)) : (_(), T(F, {
              key: 1
          }, [z(So, {
              launch: r.value
          }, null, 8, ["launch"]), z(Po, {
              launch: r.value
          }, null, 8, ["launch"])], 64))]), m("div", tP, [s.value ? (_(), T(F, {
              key: 0
          }, [z(Yn), z(mm), z(Qn)], 64)) : (_(), T(F, {
              key: 1
          }, [z(Io, {
              launch: r.value
          }, null, 8, ["launch"]), z(ka, {
              launch: r.value
          }, null, 8, ["launch"]), u.value ? (_(), xe(vm, {
              key: 0,
              launch: r.value
          }, null, 8, ["launch"])) : ye("", !0), z(Kn, {
              launch: r.value
          }, null, 8, ["launch"])], 64))])], 64))])])], 64))
      }
  }),
  aP = U({
      name: "HolderRow"
  }),
  lP = U({
      ...aP,
      props: {
          holder: {},
          total: {},
          columns: {}
      },
      setup(i) {
          const e = i,
              t = n => {
                  switch (n) {
                      case "account":
                          const s = e.holder.address;
                          return `${s.slice(0,4)}...${s.slice(-4)}`;
                      case "balance":
                          return console.log(e.holder.balance), Hn(e.holder.balance);
                      case "percentage":
                          return (e.holder.balance / e.total * 100).toFixed(2) + "%";
                      default:
                          return ""
                  }
              };
          return (n, s) => {
              const r = st("router-link");
              return _(), T("tr", null, [(_(!0), T(F, null, ue(n.columns, a => (_(), T("td", {
                  key: a.key,
                  class: ie(["whitespace-nowrap py-4 px-3 text-sm", a.align === "right" ? "text-right" : "text-left", a.key === "base.name" ? "font-medium text-gray-900 dark:text-gray-300 sticky left-0 bg-white dark:text-gray-300 z-10" : "text-gray-500 dark:text-gray-300"]),
                  style: tt({
                      width: a.width
                  })
              }, [a.key === "account" ? (_(), xe(r, {
                  key: 0,
                  to: "/wallet/" + e.holder.address
              }, {
                  default: We(() => [z(es, {
                      "wallet-address": e.holder.address
                  }, null, 8, ["wallet-address"])]),
                  _: 1
              }, 8, ["to"])) : (_(), T(F, {
                  key: 1
              }, [Xe(A(t(a.key)), 1)], 64))], 6))), 128))])
          }
      }
  }),
  oP = {
      class: "h-full flex flex-col"
  },
  uP = {
      class: "w-full sm:min-w-[640px]"
  },
  cP = {
      class: "sticky top-0 z-20 bg-white dark:bg-slate-700 rounded-t-lg"
  },
  hP = {
      class: "flex-grow overflow-y-auto custom-scrollbar pr-1"
  },
  dP = {
      class: "w-full sm:min-w-[640px]"
  },
  fP = {
      class: "divide-y divide-green-200 dark:divide-gray-700 w-full"
  },
  pP = U({
      __name: "Holders",
      props: {
          token: {}
      },
      setup(i) {
          const e = si(),
              t = i,
              n = [{
                  key: "account",
                  label: "Account",
                  align: "left",
                  width: "14%"
              }, {
                  key: "balance",
                  label: "Balance",
                  align: "right",
                  width: "14%"
              }, {
                  key: "percentage",
                  label: "Percentage",
                  align: "right",
                  width: "19%"
              }],
              s = M([]),
              r = q(() => s.value.sort((l, o) => o.balance - l.balance));
          Te(() => {
              a()
          });
          async function a() {
              s.value = await e.fetchTokenHolders(t.token.id)
          }
          return (l, o) => (_(), T("div", oP, [m("table", uP, [m("thead", cP, [m("tr", null, [(_(), T(F, null, ue(n, u => m("th", {
              key: u.key,
              scope: "col",
              style: tt({
                  width: u.width
              }),
              class: ie(["py-3 px-3 text-sm font-semibold text-gray-900 dark:text-gray-300 cursor-pointer white-space-nowrap", u.align === "right" ? "text-right" : "text-left", u.key === "base.name" ? "sticky left-0 bg-white z-20" : ""])
          }, A(u.label), 7)), 64))])])]), m("div", hP, [m("table", dP, [m("tbody", fP, [(_(!0), T(F, null, ue(r.value, u => (_(), xe(lP, {
              key: u.address,
              holder: u,
              total: l.token.circulatingSupply,
              columns: n
          }, null, 8, ["holder", "total"]))), 128))])])])]))
      }
  });
const mP = Ee(pP, [
      ["__scopeId", "data-v-2158b7f4"]
  ]),
  gP = {
      class: "border-b border-green-200 dark:border-green-700"
  },
  yP = {
      class: "-mb-px flex space-x-4"
  },
  vP = ["onClick"],
  bP = {
      class: "overflow-hidden h-full"
  },
  wP = U({
      name: "MarketData"
  }),
  ud = U({
      ...wP,
      props: {
          pair: {}
      },
      setup(i) {
          const e = ["Transactions", "Top Traders", "Holders"],
              t = M(e[0]);
          return (n, s) => (_(), T(F, null, [m("div", gP, [m("nav", yP, [(_(), T(F, null, ue(e, r => m("a", {
              key: r,
              onClick: a => t.value = r,
              class: ie([t.value === r ? "border-green-500 text-green-600 dark:text-green-400" : "border-transparent text-gray-500 hover:text-green-700 dark:text-gray-300 dark:hover:text-green-400 hover:border-green-300 ease-in-out duration-300", "cursor-pointer whitespace-nowrap py-2 px-1 border-b-2 dark:border-grey-200 font-medium text-sm"])
          }, A(r), 11, vP)), 64))])]), m("div", bP, [t.value === "Transactions" ? (_(), T(F, {
              key: 0
          }, [], 64)) : ye("", !0), t.value === "Holders" ? (_(), xe(mP, {
              key: 1,
              token: n.pair.base
          }, null, 8, ["token"])) : ye("", !0)])], 64))
      }
  });
const kP = {
      name: "ProfilePicture",
      props: {
          src: {
              type: String,
              required: !0
          }
      },
      data() {
          return {
              loaded: !1,
              tsrc: ""
          }
      },
      watch: {
          src() {
              this.loaded && (this.tsrc = this.src)
          }
      },
      methods: {
          onLoaded() {
              this.loaded = !0
          }
      }
  },
  _P = ["src"];

function xP(i, e, t, n, s, r) {
  return _(), T("div", {
      class: ie(["relative rounded-full overflow-hidden shrink-0", s.loaded ? "bg-none" : "bg-gray-200"])
  }, [z(ga, {
      name: "fade"
  }, {
      default: We(() => [Mt(m("img", {
          class: "absolute top-0 left-0 w-full h-full object-cover object-center",
          src: t.src,
          onLoad: e[0] || (e[0] = (...a) => r.onLoaded && r.onLoaded(...a)),
          onError: e[1] || (e[1] = a => s.tsrc = "")
      }, null, 40, _P), [
          [Ls, s.loaded]
      ]), e[2] || (e[2] = Xe("\xA0 "))]),
      _: 1
  })], 2)
}
const qi = Ee(kP, [
      ["render", xP],
      ["__scopeId", "data-v-f38c159b"]
  ]),
  TP = {
      class: "mb-4"
  },
  SP = {
      class: "flex flex-col space-y-1 mb-1 mt-1 w-full"
  },
  EP = {
      class: "flex flex-col sm:flex-row w-full"
  },
  CP = {
      class: "flex flex-row gap-1 items-center"
  },
  $P = {
      class: "text-xs sm:text-sm ml-1 text-gray-700 dark:text-gray-300"
  },
  LP = {
      class: "text-xs sm:text-sm text-gray-500 dark:text-gray-50"
  },
  PP = {
      class: "flex flex-row gap-1 items-center mt-1 sm:mt-0 sm:ml-1"
  },
  IP = {
      class: "text-[10px] sm:text-xs text-green-500 dark:text-green-400 flex"
  },
  NP = {
      class: "text-[10px] sm:text-xs text-green-500 dark:text-green-400 flex"
  },
  MP = {
      class: "text-[10px] sm:text-xs text-green-500 dark:text-green-400 flex"
  },
  RP = {
      class: "flex flex-row space-x-1 sm:space-x-2 items-center w-full justify-start"
  },
  BP = ["onClick"],
  OP = U({
      name: "PriceChart"
  }),
  No = U({
      ...OP,
      props: {
          pair: {}
      },
      setup(i) {
          const e = i,
              t = si(),
              n = ["1m", "5m", "15m", "30m", "1h", "4h", "1d"],
              s = M(null);
          let r = null,
              a = null;
          const l = M(!1),
              o = () => {
                  const g = {
                      layout: {
                          background: {
                              type: As.Solid,
                              color: l.value ? "#1E1E1E" : "#FFFFFF"
                          },
                          textColor: l.value ? "#D9D9D9" : "#191919"
                      },
                      grid: {
                          vertLines: {
                              color: l.value ? "#2B2B2B" : "#E1E1E1"
                          },
                          horzLines: {
                              color: l.value ? "#2B2B2B" : "#E1E1E1"
                          }
                      }
                  };
                  a ? a.applyOptions(g) : s.value && (a = Mu(s.value, g), r = a.addCandlestickSeries({
                      upColor: "#26a69a",
                      downColor: "#ef5350",
                      borderVisible: !1,
                      wickUpColor: "#26a69a",
                      wickDownColor: "#ef5350"
                  }))
              };
          Ie(() => l.value, () => {
              o()
          }), Te(async () => {
              l.value = document.documentElement.classList.contains("dark");
              const g = new MutationObserver(() => {
                  l.value = document.documentElement.classList.contains("dark")
              });
              o(), g.observe(document.documentElement, {
                  attributes: !0,
                  attributeFilter: ["class"]
              }), e.pair?.base?.id && await t.fetchCandleData(e.pair.index, "5m")
          }), Ie(() => t.candles, g => {
              !r || g.length === 0 || (r.setData(g), a?.timeScale().fitContent())
          }, {
              deep: !0
          }), Ie(() => e.pair?.base?.id, async g => {
              g && await t.fetchCandleData(g)
          });
          const u = async g => {
              !e.pair?.base?.id || (await t.fetchCandleData(e.pair.index, g), r && t.candles.length > 0 && (r.setData(t.candles), a?.timeScale().fitContent()))
          }, c = q(() => e.pair?.base?.fullName ?? "Unknown"), h = q(() => e.pair?.base?.name ?? "Unknown"), d = q(() => {
              if (!e.pair?.base) return "0";
              const w = e.pair.base.circulatingSupply * e.pair.midPrice;
              return ut(w)
          }), f = q(() => {
              if (!e.pair?.base?.deployInfo || e.pair.base.deployInfo.hip2Price === 0) return "0";
              let g = 0,
                  w = e.pair.base.deployInfo.hip2Price;
              for (; w < e.pair.midPrice;) g += w * e.pair.base.deployInfo.hip2OrderSize, w *= 1.003;
              return ut(g)
          }), p = q(() => e.pair?.base?.name ? `https://app.hyperliquid.xyz/coins/${e.pair.base.name}_USDC.svg` : "");
          return (g, w) => (_(), T("div", TP, [m("div", SP, [m("div", EP, [m("div", CP, [z(qi, {
              class: "h-8 w-8",
              src: p.value
          }, null, 8, ["src"]), m("p", $P, A(c.value), 1), m("p", LP, " (" + A(h.value) + ") ", 1)]), m("div", PP, [w[0] || (w[0] = m("p", {
              class: "hidden sm:block text-xs sm:text-sm text-gray-300 dark:text-gray-700"
          }, " | ", -1)), m("div", IP, " Market cap: " + A(d.value), 1), w[1] || (w[1] = m("p", {
              class: "text-xs sm:text-sm text-gray-300"
          }, "|", -1)), m("div", NP, " Price: " + A(e.pair?.midPrice.toFixed(5) ?? "0.00000"), 1), w[2] || (w[2] = m("p", {
              class: "text-xs sm:text-sm text-gray-300"
          }, "|", -1)), m("div", MP, " Liquidity: " + A(f.value), 1)]), w[3] || (w[3] = m("div", {
              class: "flex flex-row gap-1 items-center sm:ml-auto"
          }, null, -1))]), m("div", RP, [(_(), T(F, null, ue(n, y => m("button", {
              key: y,
              onClick: b => u(y),
              class: "px-3 py-1 bg-green-300 rounded text-xs sm:text-sm whitespace-nowrap overflow-hidden text-ellipsis text-black hover:bg-green-500 ease-in-out duration-300"
          }, A(y), 9, BP)), 64))])]), m("div", {
              class: "h-56 sm:h-80 mt-2 rounded-lg overflow-hidden shadow",
              ref_key: "chartContainer",
              ref: s
          }, null, 512)]))
      }
  }),
  DP = {
      class: "mb-4 flex flex-col text-center space-y-4"
  },
  FP = {
      class: ""
  },
  AP = {
      class: "text-xl font-semibold"
  },
  VP = {
      class: "flex flex-row"
  },
  zP = {
      class: "flex flex-col space-y-1 w-full text-left"
  },
  WP = {
      class: "text-s font-semibold"
  },
  UP = {
      class: "flex flex-col space-y-1 w-full text-left"
  },
  jP = {
      class: "text-s font-semibold"
  },
  HP = {
      key: 0,
      class: "flex flex-col space-y-1 w-full text-left"
  },
  qP = {
      class: "text-s font-semibold"
  },
  GP = {
      key: 0,
      class: "flex flex-row"
  },
  KP = {
      class: "flex flex-col space-y-1 w-full text-left"
  },
  XP = {
      class: "text-s font-semibold"
  },
  JP = {
      class: "flex flex-col space-y-1 w-full text-left"
  },
  YP = U({
      name: "TokenInfo"
  }),
  QP = U({
      ...YP,
      props: {
          pair: {}
      },
      setup(i) {
          const e = q(() => n.pair?.base?.statistics ? n.pair?.base.statistics.concentrationCoefficient * 100 : 0),
              t = q(() => e.value > 90 ? "text-red-500" : e.value > 80 ? "text-orange-500" : "text-green-500"),
              n = i;
          return (s, r) => {
              const a = st("router-link");
              return _(), T("div", DP, [m("div", FP, [m("h2", AP, A(s.pair?.base.name), 1)]), r[5] || (r[5] = m("hr", {
                  class: "border-gray-300 dark:border-gray-700"
              }, null, -1)), m("div", VP, [m("div", zP, [r[0] || (r[0] = m("div", {
                  class: "text-xs text-gray-600 dark:text-gray-300"
              }, " Price ", -1)), m("div", WP, A(s.pair?.midPrice.toFixed(5)), 1)]), m("div", UP, [r[1] || (r[1] = m("div", {
                  class: "text-xs text-gray-600 dark:text-gray-300"
              }, " 24h Vol. ", -1)), m("div", jP, A(pe(Nt)(s.pair?.dailyNtlVolume)), 1)]), s.pair?.base?.deployInfo ? (_(), T("div", HP, [r[2] || (r[2] = m("div", {
                  class: "text-xs text-gray-600 dark:text-gray-300"
              }, " Deployer ", -1)), m("div", qP, [z(a, {
                  to: "/wallet/" + n.pair.base.deployInfo.deployer
              }, {
                  default: We(() => [z(es, {
                      "wallet-address": n.pair.base.deployInfo.deployer
                  }, null, 8, ["wallet-address"])]),
                  _: 1
              }, 8, ["to"])])])) : ye("", !0)]), s.pair?.base?.statistics ? (_(), T("div", GP, [m("div", KP, [r[3] || (r[3] = m("div", {
                  class: "text-xs text-gray-600 dark:text-gray-300"
              }, " Holder count ", -1)), m("div", XP, A(s.pair?.base.statistics.holderCount), 1)]), m("div", JP, [r[4] || (r[4] = m("div", {
                  class: "text-xs text-gray-600 dark:text-gray-300"
              }, " Supply inequality ", -1)), m("div", {
                  class: ie(["text-s font-semibold", t.value])
              }, A(pe(Hn)(e.value)), 3)])])) : ye("", !0), r[6] || (r[6] = m("hr", {
                  class: "border-gray-300 dark:border-gray-700"
              }, null, -1))])
          }
      }
  });
const Mo = Ee(QP, [
      ["__scopeId", "data-v-6e13b5a2"]
  ]),
  ZP = {
      class: "fixed bottom-0 left-0 right-0 bg-white dark:bg-slate-800 shadow-up p-2 flex justify-around lg:hidden z-50 h-14"
  },
  eI = {
      class: "max-w-screen-2xl mx-auto flex flex-col h-[calc(100vh-136px)] py-2 sm:py-4 z-10 relative px-2 sm:px-6 xl:px-2 overflow-y-auto landscape:overflow-y-auto"
  },
  tI = {
      class: "grid grid-cols-1 lg:grid-cols-3 gap-8 h-full"
  },
  iI = {
      class: "lg:col-span-2 rounded-lg bg-white dark:bg-slate-800 dark:text-white border border-gray-300 dark:border-gray-700 shadow pb-2 px-2 sm:pb-4 sm:px-4 pt-1 h-full overflow-hidden flex flex-col"
  },
  nI = {
      class: "lg:col-span-1 rounded-lg bg-white dark:bg-slate-800 dark:text-white border border-gray-300 dark:border-gray-700 shadow pb-2 px-2 sm:pb-4 sm:px-4 pt-1 h-full overflow-hidden flex flex-col"
  },
  sI = {
      key: 0,
      class: "lg:col-span-1 rounded-lg bg-white dark:bg-slate-800 dark:text-white border border-gray-300 dark:border-gray-700 shadow p-2 sm:p-4 h-full overflow-hidden flex flex-col"
  },
  rI = {
      key: 1,
      class: "lg:col-span-1 rounded-lg bg-white dark:bg-slate-800 dark:text-white border border-gray-300 dark:border-gray-700 shadow p-2 sm:p-4 h-full overflow-hidden flex flex-col"
  },
  aI = U({
      name: "PairDetail",
      components: {
          PriceChart: No,
          Commentary: Kn,
          TokenInfo: Mo,
          PriceChartSkeleton: Xn,
          MarketDataSkeleton: Jn,
          TradeCardSkeleton: pm,
          TokenInfoSkeleton: Yn,
          CommentarySkeleton: Qn
      }
  }),
  lI = U({
      ...aI,
      setup(i) {
          const e = Zn(),
              t = si(),
              n = e.params.id,
              s = M(!0),
              r = M(null),
              a = M(window.innerWidth < 768),
              l = M("info"),
              o = () => {
                  a.value = window.innerWidth < 768
              };
          return Te(() => {
              window.addEventListener("resize", o)
          }), ct(() => {
              window.removeEventListener("resize", o)
          }), Te(async () => {
              r.value = await t.fetchSpotPair(parseInt(n)), console.log("pair", r.value), r.value && (console.log("pair", e.params.id, r.value.id, r.value.base.name), s.value = !1)
          }), (u, c) => (_(), T(F, null, [c[2] || (c[2] = m("div", {
              class: "absolute inset-y-0 right-1/2 z-1 -mr-96 w-[200%] origin-top-right skew-x-[-30deg] bg-white dark:bg-slate-900 ring-1 ring-green-50 sm:-mr-80 lg:-mr-48",
              "aria-hidden": "true"
          }, null, -1)), m("div", ZP, [m("button", {
              onClick: c[0] || (c[0] = h => l.value = "chart"),
              class: ie([l.value === "chart" ? "border-green-500 text-green-600 dark:text-green-400 dark:border-green-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-green-700 hover:border-green-300 ease-in-out duration-300", "cursor-pointer whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"])
          }, " Chart ", 2), m("button", {
              onClick: c[1] || (c[1] = h => l.value = "info"),
              class: ie([l.value === "info" ? "border-green-500 text-green-600 dark:text-green-400 dark:border-green-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-green-700 hover:border-green-300 ease-in-out duration-300", "cursor-pointer whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"])
          }, " Info ", 2)]), m("div", eI, [m("div", tI, [a.value ? (_(), T(F, {
              key: 1
          }, [l.value === "chart" ? (_(), T("div", sI, [s.value ? (_(), T(F, {
              key: 0
          }, [z(Xn), z(Jn)], 64)) : (_(), T(F, {
              key: 1
          }, [z(No, {
              pair: r.value
          }, null, 8, ["pair"]), z(ud, {
              pair: r.value
          }, null, 8, ["pair"])], 64))])) : ye("", !0), l.value === "info" ? (_(), T("div", rI, [s.value ? (_(), T(F, {
              key: 0
          }, [z(Yn), z(Qn)], 64)) : (_(), T(F, {
              key: 1
          }, [z(Mo, {
              pair: r.value
          }, null, 8, ["pair"]), z(Kn, {
              pair: r.value
          }, null, 8, ["pair"])], 64))])) : ye("", !0)], 64)) : (_(), T(F, {
              key: 0
          }, [m("div", iI, [s.value ? (_(), T(F, {
              key: 0
          }, [z(Xn), z(Jn)], 64)) : (_(), T(F, {
              key: 1
          }, [z(No, {
              pair: r.value
          }, null, 8, ["pair"]), z(ud, {
              pair: r.value
          }, null, 8, ["pair"])], 64))]), m("div", nI, [s.value ? (_(), T(F, {
              key: 0
          }, [z(Yn), z(Qn)], 64)) : (_(), T(F, {
              key: 1
          }, [z(Mo, {
              pair: r.value
          }, null, 8, ["pair"]), z(Kn, {
              pair: r.value
          }, null, 8, ["pair"])], 64))])], 64))])])], 64))
      }
  });
class oI extends Z {
  constructor() {
      super("google.protobuf.Timestamp", [{
          no: 1,
          name: "seconds",
          kind: "scalar",
          T: 3,
          L: 2
      }, {
          no: 2,
          name: "nanos",
          kind: "scalar",
          T: 5
      }])
  }
  now() {
      const e = this.create(),
          t = Date.now();
      return e.seconds = He.from(Math.floor(t / 1e3)).toNumber(), e.nanos = t % 1e3 * 1e6, e
  }
  toDate(e) {
      return new Date(He.from(e.seconds).toNumber() * 1e3 + Math.ceil(e.nanos / 1e6))
  }
  fromDate(e) {
      const t = this.create(),
          n = e.getTime();
      return t.seconds = He.from(Math.floor(n / 1e3)).toNumber(), t.nanos = n % 1e3 * 1e6, t
  }
  internalJsonWrite(e, t) {
      let n = He.from(e.seconds).toNumber() * 1e3;
      if (n < Date.parse("0001-01-01T00:00:00Z") || n > Date.parse("9999-12-31T23:59:59Z")) throw new Error("Unable to encode Timestamp to JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      if (e.nanos < 0) throw new Error("Unable to encode invalid Timestamp to JSON. Nanos must not be negative.");
      let s = "Z";
      if (e.nanos > 0) {
          let r = (e.nanos + 1e9).toString().substring(1);
          r.substring(3) === "000000" ? s = "." + r.substring(0, 3) + "Z" : r.substring(6) === "000" ? s = "." + r.substring(0, 6) + "Z" : s = "." + r + "Z"
      }
      return new Date(n).toISOString().replace(".000Z", s)
  }
  internalJsonRead(e, t, n) {
      if (typeof e != "string") throw new Error("Unable to parse Timestamp from JSON " + ou(e) + ".");
      let s = e.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
      if (!s) throw new Error("Unable to parse Timestamp from JSON. Invalid format.");
      let r = Date.parse(s[1] + "-" + s[2] + "-" + s[3] + "T" + s[4] + ":" + s[5] + ":" + s[6] + (s[8] ? s[8] : "Z"));
      if (Number.isNaN(r)) throw new Error("Unable to parse Timestamp from JSON. Invalid value.");
      if (r < Date.parse("0001-01-01T00:00:00Z") || r > Date.parse("9999-12-31T23:59:59Z")) throw new globalThis.Error("Unable to parse Timestamp from JSON. Must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive.");
      return n || (n = this.create()), n.seconds = He.from(r / 1e3).toNumber(), n.nanos = 0, s[7] && (n.nanos = parseInt("1" + s[7] + "0".repeat(9 - s[7].length)) - 1e9), n
  }
  create(e) {
      const t = {
          seconds: 0,
          nanos: 0
      };
      return globalThis.Object.defineProperty(t, J, {
          enumerable: !1,
          value: this
      }), e !== void 0 && X(this, t, e), t
  }
  internalBinaryRead(e, t, n, s) {
      let r = s ?? this.create(),
          a = e.pos + t;
      for (; e.pos < a;) {
          let [l, o] = e.tag();
          switch (l) {
              case 1:
                  r.seconds = e.int64().toNumber();
                  break;
              case 2:
                  r.nanos = e.int32();
                  break;
              default:
                  let u = n.readUnknownField;
                  if (u === "throw") throw new globalThis.Error(`Unknown field ${l} (wire type ${o}) for ${this.typeName}`);
                  let c = e.skip(o);
                  u !== !1 && (u === !0 ? L.onRead : u)(this.typeName, r, l, o, c)
          }
      }
      return r
  }
  internalBinaryWrite(e, t, n) {
      e.seconds !== 0 && t.tag(1, v.Varint).int64(e.seconds), e.nanos !== 0 && t.tag(2, v.Varint).int32(e.nanos);
      let s = n.writeUnknownFields;
      return s !== !1 && (s == !0 ? L.onWrite : s)(this.typeName, e, t), t
  }
}
new oI;
const Js = Xi("wallet", () => {
      const i = M(new Map);
      M(new Map);
      const e = M("value"),
          t = M("desc");

      function n(l) {
          e.value = l
      }

      function s(l) {
          t.value = l
      }
      async function r(l) {
          const o = {
              ethereumAddress: {
                  value: l
              }
          };
          try {
              const u = await dt.hyperliquidWallet(o, {});
              return console.log("response", u), i.value.set(u.response.wallet.id, u.response.wallet), i.value.get(u.response.wallet.id)
          } catch (u) {
              return console.log("getWallet error", u), u.code, null
          }
      }
      async function a(l, o) {
          const u = {
              ethereumAddress: {
                  value: l
              },
              accountType: o
          };
          try {
              const c = await Jw.hyperliquidWalletPerformance(u, {});
              return console.log("response", c.response), c.response
          } catch (c) {
              return console.log("getWallet error", c), c.code, null
          }
      }
      return {
          fetchWalletPerformance: a,
          fetchWallet: r,
          sortColumn: e,
          sortDirection: t,
          setSortColumn: n,
          setSortDirection: s
      }
  }),
  uI = {
      class: "sticky top-0 z-20 bg-gray-50 dark:bg-slate-700 rounded-t-lg"
  },
  cI = ["onClick"],
  hI = {
      class: "mr-4"
  },
  dI = {
      key: 0,
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-0 md:group-hover:opacity-100 transition-opacity duration-200"
  },
  fI = {
      key: 1
  },
  pI = {
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-100 md:group-hover:opacity-0 transition-opacity"
  },
  mI = {
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-0 md:group-hover:opacity-100 transition-opacity"
  },
  gI = U({
      name: "BalanceFilter"
  }),
  bm = U({
      ...gI,
      props: {
          columns: {}
      },
      emits: ["update"],
      setup(i, {
          emit: e
      }) {
          const t = Js(),
              n = s => {
                  t.sortColumn === s ? t.setSortDirection(t.sortDirection === "asc" ? "desc" : "asc") : (t.setSortColumn(s), t.setSortDirection("desc"))
              };
          return (s, r) => (_(), T("thead", uI, [m("tr", null, [(_(!0), T(F, null, ue(s.columns, a => (_(), T("th", {
              key: a.key,
              class: ie(["py-3 px-3 text-sm font-semibold text-gray-900 dark:text-gray-300 cursor-pointer white-space-nowrap", a.align === "right" ? "text-right" : "text-left", a.key === "asset" ? "sticky left-0 bg-gray-50 dark:bg-slate-700 z-20" : ""])
          }, [m("div", {
              class: ie(["flex items-center", a.align === "right" ? "justify-end" : "justify-start"])
          }, [m("span", {
              onClick: l => n(a.key),
              class: "cursor-pointer group relative"
          }, [m("span", hI, A(a.label), 1), pe(t).sortColumn !== a.key ? (_(), T("span", dI, " \u25BC ")) : ye("", !0), pe(t).sortColumn === a.key ? (_(), T("span", fI, [m("span", pI, A(pe(t).sortDirection === "asc" ? "\u25B2" : "\u25BC"), 1), m("span", mI, A(pe(t).sortDirection === "asc" ? "\u25BC" : "\u25B2"), 1)])) : ye("", !0)], 8, cI)], 2)], 2))), 128))])]))
      }
  }),
  yI = {
      class: "border-t dark:border-gray-700"
  },
  vI = {
      key: 0,
      class: "flex items-center gap-3"
  },
  bI = {
      class: "font-medium"
  },
  wI = {
      class: "text-sm text-gray-500 dark:text-gray-400"
  },
  kI = U({
      name: "BalanceRow"
  }),
  wm = U({
      ...kI,
      props: {
          balance: {},
          columns: {}
      },
      setup(i) {
          return si(), (e, t) => (_(), T("tr", yI, [(_(!0), T(F, null, ue(e.columns, n => (_(), T("td", {
              key: n.key,
              class: ie(["whitespace-nowrap py-4 px-3 text-sm bg-white dark:bg-slate-800", n.align === "right" ? "text-right" : "text-left", n.key === "asset" ? "font-medium text-gray-900 dark:text-gray-300 sticky left-0 bg-white dark:bg-slate-800 z-10" : "text-gray-500 dark:text-gray-300"])
          }, [n.key === "asset" ? (_(), T("div", vI, [z(qi, {
              src: e.balance.icon,
              alt: e.balance.name,
              class: "w-8 h-8"
          }, null, 8, ["src", "alt"]), m("div", null, [m("div", bI, A(e.balance.name), 1), m("div", wI, A(e.balance.origin), 1)])])) : n.key === "price" ? (_(), T(F, {
              key: 1
          }, [Xe(A(pe(Nt)(e.balance.price)), 1)], 64)) : n.key === "balance" ? (_(), T(F, {
              key: 2
          }, [Xe(A(e.balance.balance), 1)], 64)) : n.key === "value" ? (_(), T(F, {
              key: 3
          }, [m("div", null, A(pe(ut)(e.balance.balance * e.balance.price)), 1), m("div", {
              class: ie(e.balance.change >= 0 ? "text-green-500" : "text-red-500")
          }, A(e.balance.change >= 0 ? "+" : "") + A(e.balance.change.toFixed(2)) + "% ", 3)], 64)) : ye("", !0)], 2))), 128))]))
      }
  }),
  _I = {
      class: "border-t dark:border-gray-700"
  },
  xI = U({
      name: "BalanceRowLoading"
  }),
  km = U({
      ...xI,
      props: {
          columns: {}
      },
      setup(i) {
          return (e, t) => (_(), T("tr", _I, [(_(!0), T(F, null, ue(e.columns, n => (_(), T("td", {
              key: n.key,
              class: ie(["whitespace-nowrap py-4 px-3 text-sm bg-white dark:bg-slate-800", [n.align === "right" ? "text-right" : "text-left"]])
          }, t[0] || (t[0] = [m("div", {
              class: "animate-pulse"
          }, [m("div", {
              class: "h-4 bg-gray-200 dark:bg-gray-700 rounded"
          })], -1)]), 2))), 128))]))
      }
  }),
  TI = {
      class: "mt-8 animate-pulse"
  },
  SI = {
      class: "flex flex-col h-full max-w-screen-2xl mx-auto bg-gray-300/75 dark:bg-slate-700/75 rounded-lg lg:rounded-xl overflow-hidden border border-gray-300 dark:border-gray-700"
  },
  EI = {
      key: 0,
      class: "p-4 border-b dark:border-gray-700 bg-gray-50 dark:bg-slate-700 border-b-gray-300 dark:border-b-gray-700 border-b-1"
  },
  CI = {
      class: "overflow-x-auto overflow-y-auto"
  },
  $I = {
      class: "w-full min-w-[640px]"
  },
  LI = {
      class: "border-b border-gray-300 dark:border-gray-700"
  },
  PI = {
      class: "divide-y divide-gray-300 dark:divide-gray-700"
  },
  II = U({
      name: "BalanceSkeleton"
  }),
  NI = U({
      ...II,
      setup(i) {
          const e = M(window.innerWidth < 768),
              t = [{
                  key: "asset",
                  label: "ASSET",
                  align: "left"
              }, {
                  key: "price",
                  label: "PRICE",
                  align: "right"
              }, {
                  key: "balance",
                  label: "BALANCE",
                  align: "right"
              }, {
                  key: "value",
                  label: "VALUE",
                  align: "right"
              }];
          return window.addEventListener("resize", () => {
              e.value = window.innerWidth < 768
          }), (n, s) => (_(), T("div", TI, [m("div", SI, [e.value ? ye("", !0) : (_(), T("div", EI, s[0] || (s[0] = [m("div", {
              class: "flex items-center gap-2"
          }, [m("div", {
              class: "w-6 h-6 bg-gray-200 dark:bg-gray-600 rounded"
          }), m("div", {
              class: "h-5 w-32 bg-gray-200 dark:bg-gray-600 rounded"
          }), m("div", {
              class: "h-5 w-24 bg-gray-200 dark:bg-gray-600 rounded"
          })], -1)]))), m("div", CI, [m("table", $I, [m("thead", null, [m("tr", LI, [(_(), T(F, null, ue(t, r => m("th", {
              key: r.key,
              class: ie(["p-4 text-left text-sm font-medium text-gray-500 dark:text-gray-400", r.align === "right" ? "text-right" : "text-left"])
          }, s[1] || (s[1] = [m("div", {
              class: "h-4 w-16 bg-gray-200 dark:bg-gray-600 rounded"
          }, null, -1)]), 2)), 64))])]), m("tbody", PI, [(_(), T(F, null, ue(10, r => m("tr", {
              key: r,
              class: "hover:bg-gray-50 dark:hover:bg-gray-700/50"
          }, s[2] || (s[2] = [m("td", {
              class: "p-4"
          }, [m("div", {
              class: "flex items-center gap-2"
          }, [m("div", {
              class: "w-8 h-8 bg-gray-200 dark:bg-gray-600 rounded-full"
          }), m("div", {
              class: "h-5 w-24 bg-gray-200 dark:bg-gray-600 rounded"
          })])], -1), m("td", {
              class: "p-4 text-right"
          }, [m("div", {
              class: "h-5 w-20 bg-gray-200 dark:bg-gray-600 rounded ml-auto"
          })], -1), m("td", {
              class: "p-4 text-right"
          }, [m("div", {
              class: "h-5 w-24 bg-gray-200 dark:bg-gray-600 rounded ml-auto"
          })], -1), m("td", {
              class: "p-4 text-right"
          }, [m("div", {
              class: "h-5 w-28 bg-gray-200 dark:bg-gray-600 rounded ml-auto"
          })], -1)]))), 64))])])])])]))
      }
  });
const _m = Ee(NI, [
      ["__scopeId", "data-v-2089f4fc"]
  ]),
  MI = {
      key: 1,
      class: "mt-8"
  },
  RI = {
      class: "flex flex-col h-full max-w-screen-2xl mx-auto bg-white dark:bg-gray-800 rounded-lg lg:rounded-xl overflow-hidden border border-gray-200 dark:border-gray-700"
  },
  BI = {
      class: "p-4 border-b dark:border-gray-700 bg-white dark:bg-gray-800 border-gray-200"
  },
  OI = {
      class: "flex items-center justify-between"
  },
  DI = {
      class: "flex items-center gap-2"
  },
  FI = {
      class: "font-medium text-gray-900 dark:text-white"
  },
  AI = {
      class: "font-medium text-gray-900 dark:text-white"
  },
  VI = {
      class: "overflow-x-auto overflow-y-auto custom-scrollbar max-h-[500px]"
  },
  zI = {
      class: "w-full min-w-[640px]"
  },
  WI = {
      class: "divide-y divide-gray-200 dark:divide-gray-700 w-full"
  },
  UI = U({
      name: "Balance",
      components: {
          BalanceSkeleton: _m,
          BalanceFilter: bm,
          BalanceRow: wm,
          BalanceRowLoading: km
      }
  }),
  xm = U({
      ...UI,
      props: {
          spotBalances: {},
          launchBalances: {},
          walletName: {}
      },
      setup(i) {
          M(window.innerWidth < 768);
          const e = M(!1),
              t = i,
              n = si(),
              s = Js(),
              r = St(),
              a = M(!0),
              l = [{
                  key: "asset",
                  label: "ASSET",
                  align: "left"
              }, {
                  key: "price",
                  label: "PRICE",
                  align: "right"
              }, {
                  key: "balance",
                  label: "BALANCE",
                  align: "right"
              }, {
                  key: "value",
                  label: "VALUE",
                  align: "right"
              }],
              o = q(() => {
                  let f = [];
                  return t.spotBalances.forEach(p => {
                      let g = 1,
                          w = p.balance;
                      if (p.tokenId !== 1e4) {
                          const y = n.spotPairByBaseId.get(p.tokenId);
                          if (!y) return;
                          g = y.midPrice, w = p.balance * g
                      }
                      w < 1 || f.push({
                          key: p.tokenId,
                          icon: c(p.tokenId),
                          name: h(p.tokenId),
                          price: g,
                          balance: p.balance,
                          value: w,
                          change: 0,
                          origin: "Hyperliquid Spot"
                      })
                  }), t.launchBalances.forEach(p => {
                      if (r.launchMap.has(p.launchId)) {
                          const g = r.launchMap.get(p.launchId);
                          if (g.session && g.session.step > 1) return;
                          let w = p.balance / Math.pow(10, g.decimals),
                              y = Jr(g),
                              b = w * y;
                          if (b < 1) return;
                          f.push({
                              key: g.id,
                              icon: "",
                              name: g.session.tokenName,
                              price: y,
                              balance: w,
                              value: b,
                              change: (y / g.previousDayPx - 1) * 100,
                              origin: "Hypurr Pump"
                          })
                      }
                  }), f.sort((p, g) => {
                      let w, y;
                      switch (s.sortColumn) {
                          case "asset":
                              w = p.value, y = g.value;
                              break;
                          case "price":
                              w = p.price, y = g.price;
                              break;
                          case "balance":
                              w = p.balance, y = g.balance;
                              break;
                          case "value":
                          default:
                              w = p.value, y = g.value;
                              break
                      }
                      if (w === y) return 0;
                      const b = s.sortDirection === "asc" ? 1 : -1;
                      return w < y ? -1 * b : 1 * b
                  }), f
              });

          function u(f) {
              if (f === 1e4) return 1;
              const p = n.spotPairByBaseId.get(f);
              return !p || !p.midPrice ? 0 : p.midPrice
          }

          function c(f) {
              const p = n.spotPairByBaseId.get(f);
              return p ? `https://stats-data.hyperliquid.xyz/svg/${p.base.name}_USDC.svg` : ""
          }

          function h(f) {
              if (f === 1e4) return "USDC";
              const p = n.spotPairByBaseId.get(f);
              return p ? p.base.name : "Unknown"
          }
          const d = q(() => {
              let f = t.spotBalances.reduce((g, w) => g + w.balance * u(w.tokenId), 0),
                  p = t.launchBalances.reduce((g, w) => {
                      if (r.launchMap.has(w.launchId)) {
                          const y = r.launchMap.get(w.launchId);
                          let b = w.balance / Math.pow(10, y.decimals);
                          return g + b * Jr(y)
                      }
                      return g
                  }, 0);
              return console.log(f, p), f + p
          });
          return Te(async () => {
              await n.fetchSpotPairs(), setTimeout(() => {
                  a.value = !1
              }, 200)
          }), Ie(() => [s.sortColumn, s.sortDirection], ([f, p]) => {
              console.log("Store changed:", f, p)
          }), (f, p) => a.value ? (_(), xe(_m, {
              key: 0
          })) : (_(), T("div", MI, [m("div", RI, [m("div", BI, [m("div", OI, [m("div", DI, [p[1] || (p[1] = m("div", {
              class: "w-6 h-6 bg-green-500 rounded"
          }, null, -1)), m("span", FI, A(f.walletName), 1), p[2] || (p[2] = m("span", {
              class: "text-gray-500 dark:text-gray-400"
          }, "\xB7", -1)), m("span", AI, A(pe(ut)(d.value)), 1)]), m("button", {
              onClick: p[0] || (p[0] = g => e.value = !e.value),
              class: "p-2 text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors duration-150"
          }, [e.value ? (_(), xe(pe(fm), {
              key: 1,
              class: "w-5 h-5"
          })) : (_(), xe(pe(eL), {
              key: 0,
              class: "w-5 h-5"
          }))])])]), Mt(m("div", VI, [m("table", zI, [z(bm, {
              columns: l
          }), m("tbody", WI, [a.value ? (_(), T(F, {
              key: 0
          }, ue(5, g => z(km, {
              key: g,
              columns: l
          })), 64)) : (_(!0), T(F, {
              key: 1
          }, ue(o.value, g => (_(), xe(wm, {
              key: g.tokenId,
              balance: g,
              columns: l
          }, null, 8, ["balance"]))), 128))])])], 512), [
              [Ls, !e.value]
          ])])]))
      }
  });

function jI(i, e) {
  return _(), T("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24",
      fill: "currentColor",
      "aria-hidden": "true",
      "data-slot": "icon"
  }, [m("path", {
      "fill-rule": "evenodd",
      d: "M16.28 11.47a.75.75 0 0 1 0 1.06l-7.5 7.5a.75.75 0 0 1-1.06-1.06L14.69 12 7.72 5.03a.75.75 0 0 1 1.06-1.06l7.5 7.5Z",
      "clip-rule": "evenodd"
  })])
}
const HI = {
      class: "flex flex-col h-full animate-pulse"
  },
  qI = {
      class: "bg-white rounded-xl border flex flex-col dark:bg-gray-800 dark:border-gray-700 dark:text-white"
  },
  GI = {
      class: "border-b border-gray-200 dark:border-gray-700"
  },
  KI = {
      class: "flex space-x-4 mt-4 px-6"
  },
  XI = {
      class: "grid grid-cols-1 lg:grid-cols-3 gap-6 p-6"
  },
  JI = {
      class: "lg:col-span-1"
  },
  YI = {
      class: "bg-white dark:bg-slate-800 rounded-lg"
  },
  QI = {
      class: "space-y-2 mt-2"
  },
  ZI = {
      key: 0,
      class: "w-full h-[2px] bg-gray-300 dark:bg-gray-700"
  },
  eN = {
      class: "lg:col-span-2"
  },
  tN = U({
      __name: "PerformanceSkeleton",
      props: {
          tabs: {},
          activeTab: {}
      },
      setup(i) {
          const e = M(window.innerWidth < 768);
          return window.addEventListener("resize", () => {
              e.value = window.innerWidth < 768
          }), (t, n) => (_(), T("div", HI, [m("div", qI, [m("div", GI, [n[0] || (n[0] = un('<div class="flex items-center justify-between px-6 pt-6"><div class="flex items-center gap-2"><h2 class="text-xl font-semibold">Performance</h2><svg class="w-5 h-5 text-gray-400" viewBox="0 0 24 24" fill="none" stroke="currentColor"><circle cx="12" cy="12" r="10" stroke-width="2"></circle><path d="M12 16v-4M12 8h.01" stroke-width="2" stroke-linecap="round"></path></svg></div><div class="flex items-center gap-2"><div class="h-8 w-36 bg-gray-200 dark:bg-gray-700 rounded"></div><div class="h-8 w-24 bg-gray-200 dark:bg-gray-700 rounded"></div></div></div>', 1)), m("div", KI, [(_(!0), T(F, null, ue(t.tabs, s => (_(), T("div", {
              key: s.id,
              class: ie(["pb-4 px-1 relative", [t.activeTab === s.id ? "text-green-500 dark:text-green-400" : "text-gray-500 dark:text-gray-400"]])
          }, [Xe(A(s.label) + " ", 1), m("div", {
              class: ie(["absolute bottom-0 left-0 w-full h-0.5", [t.activeTab === s.id ? "bg-green-500 dark:bg-green-400" : "bg-transparent"]])
          }, null, 2)], 2))), 128))])]), m("div", XI, [m("div", JI, [m("div", YI, [m("div", {
              class: ie(e.value ? "p-2" : "p-4")
          }, [(_(), T(F, null, ue(2, s => m("div", {
              key: s,
              class: "mb-6"
          }, [n[2] || (n[2] = m("div", {
              class: "flex justify-between items-center py-2 px-3"
          }, [m("div", {
              class: "h-5 w-28 bg-gray-200 dark:bg-gray-700 rounded"
          }), m("div", {
              class: "h-5 w-24 bg-gray-200 dark:bg-gray-700 rounded"
          })], -1)), m("div", QI, [(_(), T(F, null, ue(4, r => m("div", {
              key: r,
              class: "flex justify-between items-center py-1.5 px-3"
          }, n[1] || (n[1] = [m("div", {
              class: "flex items-center space-x-2 pl-4"
          }, [m("div", {
              class: "w-4 h-4 bg-gray-200 dark:bg-gray-700 rounded"
          }), m("div", {
              class: "h-4 w-32 bg-gray-200 dark:bg-gray-700 rounded"
          })], -1), m("div", {
              class: "h-4 w-20 bg-gray-200 dark:bg-gray-700 rounded"
          }, null, -1)]))), 64))])])), 64))], 2)])]), e.value ? (_(), T("div", ZI)) : ye("", !0), m("div", eN, [m("div", {
              class: ie(["rounded-lg bg-gray-200 dark:bg-gray-700", e.value ? "h-[300px]" : "h-[500px]"])
          }, null, 2)])])])]))
      }
  }),
  iN = {
      class: "bg-white dark:bg-gray-800 rounded-lg relative"
  },
  nN = {
      class: "flex justify-between items-center py-2 px-3 hover:bg-gray-50 dark:hover:bg-gray-700"
  },
  sN = {
      class: "text-md font-medium text-gray-700 dark:text-gray-200"
  },
  rN = {
      class: "text-right text-gray-800 dark:text-white"
  },
  aN = {
      class: "space-y-1"
  },
  lN = ["onClick"],
  oN = {
      key: 1,
      class: "w-4"
  },
  uN = {
      class: "text-gray-800 dark:text-white"
  },
  cN = {
      key: 0,
      class: "pl-8 bg-white dark:bg-gray-800 relative z-10 custom-scrollbar"
  },
  hN = {
      class: "max-h-[200px] overflow-y-auto"
  },
  dN = {
      class: "text-gray-700 dark:text-gray-200 pl-6"
  },
  fN = U({
      __name: "PerformanceSheet",
      props: {
          currentData: {},
          activeTab: {},
          isMobile: {
              type: Boolean
          }
      },
      setup(i) {
          const e = i,
              t = si(),
              n = St(),
              s = M({
                  title: "Performance report",
                  sections: [{
                      title: "Account",
                      amount: 0,
                      items: [{
                          code: "pnl",
                          label: "Profit & Loss (+)/(-)",
                          amount: 0,
                          isTotal: !0,
                          items: []
                      }, {
                          code: "profit",
                          label: "Profit",
                          amount: 0,
                          items: []
                      }, {
                          code: "loss",
                          label: "Loss",
                          amount: 0,
                          items: []
                      }, {
                          code: "cash",
                          label: "Cash Movements (+)/(-)",
                          amount: 0,
                          items: []
                      }]
                  }]
              });
          Te(() => {
              s.value.sections.forEach(c => {
                  c.items?.forEach(h => {
                      Array.isArray(h.items) && h.items.length > 0 && r.value.set(h.code, !0)
                  })
              })
          });
          const r = M(new Map),
              a = c => {
                  r.value.set(c, !l(c))
              },
              l = c => r.value.get(c) ?? !0,
              o = c => {
                  switch (e.activeTab) {
                      case "spot":
                          return t.spotPairByBaseId.get(c)?.base?.name ?? "Unknown";
                      case "perp":
                          return t.perpPairById.get(c)?.name ?? "Unknown";
                      case "launch":
                          return n.launchMap.get(c)?.session?.tokenName ?? "Unknown";
                      default:
                          return "Unknown"
                  }
              },
              u = () => {
                  if (!e.currentData) return;
                  const c = e.currentData;
                  s.value.sections[0].title = `${e.activeTab.charAt(0).toUpperCase()+e.activeTab.slice(1)} Account`;
                  let h = c.reports.map(p => ({
                          label: o(p.tokenId),
                          amount: p.totalPnl
                      })),
                      d = h.filter(p => p.amount > 0),
                      f = h.filter(p => p.amount < 0);
                  s.value.sections[0].items[1].items = d, s.value.sections[0].items[2].items = f, s.value.sections[0].items[1].amount = d.reduce((p, g) => p + g.amount, 0), s.value.sections[0].items[2].amount = f.reduce((p, g) => p + g.amount, 0), s.value.sections[0].items[0].amount = s.value.sections[0].items[1].amount + s.value.sections[0].items[2].amount, s.value.sections[0].items[3].amount = c.netCash, s.value.sections[0].amount = s.value.sections[0].items[0].amount + s.value.sections[0].items[3].amount
              };
          return Ie(() => [e.currentData, e.activeTab], () => {
              u()
          }, {
              immediate: !0
          }), (c, h) => (_(), T("div", iN, [m("div", {
              class: ie([c.isMobile ? "p-2" : "p-4", "overflow-visible"])
          }, [(_(!0), T(F, null, ue(s.value.sections, d => (_(), T("div", {
              key: d.title,
              class: "mb-4 relative"
          }, [m("div", nN, [m("h2", sN, A(d.title), 1), m("span", rN, A(pe(Nt)(d.amount)), 1)]), m("div", aN, [(_(!0), T(F, null, ue(d.items, f => (_(), T(F, {
              key: f.code
          }, [m("div", {
              class: ie(["flex justify-between items-center py-1.5 px-3 hover:bg-gray-50 dark:hover:bg-gray-700 relative", f.isTotal ? "font-semibold" : ""])
          }, [m("div", {
              class: ie(["flex items-center space-x-2", f.isTotal ? "" : "pl-4"])
          }, [f.items?.length ? (_(), T("button", {
              key: 0,
              onClick: p => a(f.code),
              class: "w-4 h-4 flex items-center justify-center focus:outline-none"
          }, [z(pe(jI), {
              class: ie(["w-4 h-4 transition-transform duration-200", l(f.code) ? "" : "transform rotate-90"])
          }, null, 8, ["class"])], 8, lN)) : (_(), T("span", oN)), m("span", uN, A(f.label), 1)], 2), m("span", {
              class: ie(["text-right", f.amount < 0 ? "text-red-500" : "text-gray-800 dark:text-white"])
          }, A(pe(Nt)(f.amount)), 3)], 2), f.items && !l(f.code) ? (_(), T("div", cN, [m("div", hN, [(_(!0), T(F, null, ue(f.items, p => (_(), T("div", {
              key: p.code,
              class: "flex justify-between items-center py-1 px-3 text-sm hover:bg-gray-50 dark:hover:bg-gray-700"
          }, [m("span", dN, A(p.label), 1), m("span", {
              class: ie(["text-right", p.amount < 0 ? "text-red-500" : "text-gray-700 dark:text-gray-200"])
          }, A(pe(Nt)(p.amount)), 3)]))), 128))])])) : ye("", !0)], 64))), 128))])]))), 128))], 2)]))
      }
  }),
  pN = {
      key: 1,
      class: "flex flex-col h-full z-10"
  },
  mN = {
      class: "bg-white rounded-xl border flex flex-col dark:bg-gray-800 dark:border-gray-700 dark:text-white"
  },
  gN = {
      class: "border-b border-gray-200 dark:border-gray-700"
  },
  yN = {
      class: "flex items-center justify-between px-6 pt-6"
  },
  vN = {
      class: "flex items-center gap-2"
  },
  bN = {
      class: "text-2xl font-bold"
  },
  wN = {
      class: "flex space-x-4 mt-4 px-6"
  },
  kN = ["onClick"],
  _N = {
      class: "grid grid-cols-1 lg:grid-cols-3 gap-6 p-6"
  },
  xN = {
      class: "lg:col-span-1"
  },
  TN = {
      key: 0,
      class: "w-full h-[2px] bg-gray-300 dark:bg-gray-700"
  },
  SN = {
      class: "lg:col-span-2"
  },
  EN = U({
      name: "Performance"
  }),
  CN = U({
      ...EN,
      props: {
          walletAddress: {}
      },
      setup(i) {
          const e = i,
              t = Js(),
              n = M(null),
              s = M("spot"),
              r = M(null);
          let a = null,
              l = null;
          const o = M(!1),
              u = M(window.innerWidth < 768),
              c = [{
                  id: "spot",
                  label: "Spot"
              }, {
                  id: "perp",
                  label: "Perpetual"
              }, {
                  id: "launch",
                  label: "Launch"
              }],
              h = q(() => n.value ? n.value[s.value] : null),
              d = q(() => h.value && h.value.notional || 0),
              f = q(() => h.value ? (h.value.notional || 0) - (h.value.netCash || 0) : 0),
              p = async () => {
                  if (!!e.walletAddress) {
                      n.value = null;
                      try {
                          n.value = await t.fetchWalletPerformance(e.walletAddress, s.value)
                      } catch (y) {
                          console.error("Error fetching wallet performance:", y), n.value = null
                      }
                  }
              }, g = () => {
                  if (!r.value) return;
                  a && a.remove();
                  const y = {
                      layout: {
                          background: {
                              type: As.Solid,
                              color: o.value ? "#1e293b" : "#ffffff"
                          },
                          textColor: o.value ? "#e2e8f0" : "#1e293b"
                      },
                      grid: {
                          vertLines: {
                              color: o.value ? "#334155" : "#e2e8f0"
                          },
                          horzLines: {
                              color: o.value ? "#334155" : "#e2e8f0"
                          }
                      },
                      width: r.value.clientWidth,
                      height: r.value.clientHeight
                  };
                  a = Mu(r.value, y), l = a.addBaselineSeries({
                      color: o.value ? "#26a69a" : "#16a34a",
                      lineWidth: 2,
                      priceLineVisible: !0,
                      priceFormat: {
                          type: "custom",
                          formatter: b => ut(b),
                          minMove: 1e-8
                      }
                  }), w()
              }, w = () => {
                  if (!n || !l || !h.value) return;
                  const y = h.value.points.map(b => ({
                      time: b.time,
                      value: b.pnl
                  }));
                  l.setData(y), a.timeScale().fitContent()
              };
          return Ie(s, async () => {
              await p(), w()
          }), Ie(() => e.walletAddress, async () => {
              await p(), w()
          }), Te(() => {
              p(), o.value = document.documentElement.classList.contains("dark"), pi(() => {
                  g()
              })
          }), Ie(r, () => {
              g()
          }), Ie(() => o.value, () => {
              g()
          }), ct(() => {
              a && (a.remove(), a = null)
          }), (y, b) => n.value ? (_(), T("div", pN, [m("div", mN, [m("div", gN, [m("div", yN, [b[0] || (b[0] = un('<div class="flex items-center gap-2" data-v-e96a02ca><h2 class="text-xl font-semibold" data-v-e96a02ca>Performance</h2><svg class="w-5 h-5 text-gray-400" viewBox="0 0 24 24" fill="none" stroke="currentColor" data-v-e96a02ca><circle cx="12" cy="12" r="10" stroke-width="2" data-v-e96a02ca></circle><path d="M12 16v-4M12 8h.01" stroke-width="2" stroke-linecap="round" data-v-e96a02ca></path></svg></div>', 1)), m("div", vN, [m("span", bN, A(pe(ut)(d.value)), 1), m("span", {
              class: ie(f.value >= 0 ? "text-green-500" : "text-red-500")
          }, " (" + A(f.value > 0 ? "+" : "") + A(pe(ut)(f.value)) + ") ", 3)])]), m("div", wN, [(_(), T(F, null, ue(c, x => m("button", {
              key: x.id,
              onClick: k => s.value = x.id,
              class: ie(["pb-4 px-1 relative", [s.value === x.id ? "text-green-500 dark:text-green-400" : "text-gray-500 hover:text-gray-700 dark:hover:text-gray-300"]])
          }, [Xe(A(x.label) + " ", 1), m("div", {
              class: ie(["absolute bottom-0 left-0 w-full h-0.5 transition-colors duration-200", [s.value === x.id ? "bg-green-500 dark:bg-green-400" : "bg-transparent"]])
          }, null, 2)], 10, kN)), 64))])]), m("div", _N, [m("div", xN, [z(fN, {
              "current-data": h.value,
              "active-tab": s.value,
              "is-mobile": u.value
          }, null, 8, ["current-data", "active-tab", "is-mobile"])]), u.value ? (_(), T("div", TN)) : ye("", !0), m("div", SN, [m("div", {
              class: ie(["overflow-visible w-full", u.value ? "h-[300px]" : "h-[500px]"]),
              ref_key: "chartContainer",
              ref: r
          }, null, 2)])])])])) : (_(), xe(tN, {
              key: 0,
              tabs: c,
              "active-tab": s.value
          }, null, 8, ["active-tab"]))
      }
  });
const Tm = Ee(CN, [
      ["__scopeId", "data-v-e96a02ca"]
  ]),
  $N = {
      class: "max-w-screen-2xl mx-auto mt-4 flow-root h-full flex flex-col w-full"
  },
  LN = {
      class: "flex flex-col py-4 z-10 relative px-2 sm:px-6 xl:px-2 overflow-x-hidden landscape:overflow-y-auto custom-scrollbar"
  },
  PN = {
      class: "flex items-center justify-between mb-8"
  },
  IN = {
      key: 0,
      class: "flex items-center gap-4"
  },
  NN = {
      class: "flex flex-col gap-2 dark:text-white"
  },
  MN = {
      class: "px-1 font-semibold"
  },
  RN = {
      class: "gap-8 mb-8 border-b border-green-200 dark:border-green-700"
  },
  BN = {
      class: "-mb-px flex space-x-4"
  },
  ON = ["onClick"],
  DN = {
      class: "grid grid-cols-1 lg:grid-cols-3 gap-8"
  },
  FN = U({
      __name: "UserWallet",
      setup(i) {
          const e = Ji(),
              t = q(() => e.user),
              n = si();
          Js(), M([{
              type: "Trade",
              date: "Sep 9",
              amount: "+0.38749 ETH"
          }, {
              type: "Trade",
              date: "Sep 9",
              amount: "+0.59442 ETH"
          }, {
              type: "Execute",
              date: "Jun 12",
              amount: "-0.176 ETH"
          }, {
              type: "Execute",
              date: "Jun 12",
              amount: "-0.241 ETH"
          }, {
              type: "Execute",
              date: "Jun 12",
              amount: "-0.192 ETH"
          }]), M([{
              name: "Ethereum",
              network: "5 Networks",
              icon: "/placeholder/32/32",
              price: "2,429.08",
              balance: "2.513 ETH",
              value: "6,104.53",
              change: .06
          }, {
              name: "Wrapped Ethereum",
              network: "Ethereum",
              icon: "/placeholder/32/32",
              price: "2,429.21",
              balance: "0.087 WETH",
              value: "212.54",
              change: .07
          }]);
          const s = ["Portfolio", "History"],
              r = M(s[0]),
              a = M(null),
              l = q(() => e.user ? e.user.user.wallets : []);
          async function o() {
              await n.fetchSpotPairs(), await n.fetchPerpPairs()
          }
          return Te(() => {
              o(), a.value = e.user?.user.wallets.find(u => u.id === e.user?.user.walletId) || null
          }), (u, c) => (_(), T(F, null, [c[2] || (c[2] = m("div", {
              class: "absolute inset-y-0 right-1/2 z-1 -mr-96 w-[200%] origin-top-right skew-x-[-30deg] bg-white dark:bg-slate-900 ring-1 ring-green-50 dark:ring-green-400 sm:-mr-80 lg:-mr-48",
              "aria-hidden": "true"
          }, null, -1)), m("div", $N, [m("div", LN, [m("div", PN, [t.value ? (_(), T("div", IN, [z(qi, {
              src: t.value.getProfilePicture(),
              class: "h-14 w-14 rounded-full"
          }, null, 8, ["src"]), m("div", NN, [m("span", MN, A(t.value.getDisplayName()), 1), z(ym, {
              modelValue: a.value,
              "onUpdate:modelValue": c[0] || (c[0] = h => a.value = h),
              wallets: l.value
          }, null, 8, ["modelValue", "wallets"])])])) : ye("", !0)]), m("div", RN, [m("nav", BN, [(_(), T(F, null, ue(s, h => m("a", {
              key: h,
              onClick: d => r.value = h,
              class: ie([r.value === h ? "border-green-500 text-green-600 dark:text-green-400" : "border-transparent text-gray-500 hover:text-green-700 dark:text-gray-300 dark:hover:text-green-400 hover:border-green-300 ease-in-out duration-300", "cursor-pointer whitespace-nowrap py-2 px-1 border-b-2 dark:border-grey-200 font-medium text-sm"])
          }, A(h), 11, ON)), 64))])]), m("div", DN, [z(Tm, {
              class: "col-span-3 lg:col-span-3",
              "wallet-address": a.value?.ethereumAddress ?? ""
          }, null, 8, ["wallet-address"])]), c[1] || (c[1] = m("div", {
              class: "flex items-center justify-between mt-4"
          }, [m("h2", {
              class: "text-xl font-semibold dark:text-white"
          }, "Assets")], -1)), (_(!0), T(F, null, ue(l.value, h => (_(), xe(xm, {
              key: h.id,
              "spot-balances": h.spotBalances,
              "launch-balances": h.launchBalances,
              walletName: h.name
          }, null, 8, ["spot-balances", "launch-balances", "walletName"]))), 128))])])], 64))
      }
  }),
  AN = {
      class: "max-w-screen-2xl mx-auto mt-4 flow-root h-full flex flex-col w-full"
  },
  VN = {
      class: "fixed bottom-0 left-0 right-0 bg-white dark:bg-slate-800 shadow-up p-2 flex justify-around lg:hidden z-50 h-14"
  },
  zN = {
      class: "flex flex-col w-full z-10 relative"
  },
  WN = {
      class: "flex-1 w-full max-w-screen-2xl mx-auto px-2 sm:px-6 xl:px-2 py-2 sm:py-4 relative z-10"
  },
  UN = {
      class: "flex flex-col sm:flex-row items-start sm:items-center justify-between mb-4 sm:mb-8"
  },
  jN = {
      class: "flex items-center gap-4"
  },
  HN = {
      class: "flex items-center gap-2 dark:text-white"
  },
  qN = {
      class: "font-semibold"
  },
  GN = {
      class: "flex items-center gap-2 dark:text-white"
  },
  KN = {
      key: 0,
      class: "text-2xl font-bold"
  },
  XN = {
      class: "flex-1 overflow-y-auto custom-scrollbar"
  },
  JN = {
      class: "w-full max-w-screen-2xl mx-auto px-2 sm:px-6 xl:px-2"
  },
  YN = {
      key: 0
  },
  QN = {
      class: "grid grid-cols-1 lg:grid-cols-3 gap-8"
  },
  ZN = {
      key: 1
  },
  eM = U({
      __name: "PublicWallet",
      setup(i) {
          const e = Zn(),
              t = Js(),
              n = si(),
              s = e.params.address,
              r = M(null),
              a = M(null);
          M([]), q(() => a.value ? a.value.spot.notional - a.value.spot.netCash : 0);
          const l = q(() => a.value ? a.value.spot.notional + a.value.perp.notional : 0);
          M([{
              name: "Ethereum",
              network: "5 Networks",
              icon: "/placeholder/32/32",
              price: "2,429.08",
              balance: "2.513 ETH",
              value: "6,104.53",
              change: .06
          }, {
              name: "Wrapped Ethereum",
              network: "Ethereum",
              icon: "/placeholder/32/32",
              price: "2,429.21",
              balance: "0.087 WETH",
              value: "212.54",
              change: .07
          }]), M(["Tokens", "History"][0]);
          const u = M(window.innerWidth < 768),
              c = M("performance"),
              h = () => {
                  u.value = window.innerWidth < 768
              };
          async function d() {
              r.value = await t.fetchWallet(s)
          }
          async function f() {
              await n.fetchSpotPairs(), await n.fetchPerpPairs()
          }
          return Te(() => {
              f(), d(), window.addEventListener("resize", h)
          }), ct(() => {
              window.removeEventListener("resize", h)
          }), (p, g) => (_(), T(F, null, [g[2] || (g[2] = m("div", {
              class: "absolute inset-y-0 right-1/2 z-1 -mr-96 w-[200%] origin-top-right skew-x-[-30deg] bg-white dark:bg-slate-900 ring-1 ring-green-50 dark:ring-green-400 sm:-mr-80 lg:-mr-48",
              "aria-hidden": "true"
          }, null, -1)), m("div", AN, [m("div", VN, [m("button", {
              onClick: g[0] || (g[0] = w => c.value = "performance"),
              class: ie([c.value === "performance" ? "border-green-500 text-green-600 dark:text-green-400 dark:border-green-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-green-700 hover:border-green-300 ease-in-out duration-300", "cursor-pointer whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"])
          }, " Performance ", 2), m("button", {
              onClick: g[1] || (g[1] = w => c.value = "wallet"),
              class: ie([c.value === "wallet" ? "border-green-500 text-green-600 dark:text-green-400 dark:border-green-400" : "border-transparent text-gray-500 dark:text-gray-400 hover:text-green-700 hover:border-green-300 ease-in-out duration-300", "cursor-pointer whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm"])
          }, " Wallet ", 2)]), m("div", zN, [m("div", WN, [m("div", UN, [m("div", jN, [z(qi, {
              src: "",
              class: "h-12 w-12 rounded-lg"
          }), m("div", null, [m("div", HN, [m("span", qN, A(u.value ? `${pe(s).slice(0,6)}...${pe(s).slice(-4)}` : pe(s)), 1), z(es, {
              "wallet-address": pe(s)
          }, null, 8, ["wallet-address"])]), m("div", GN, [a.value ? (_(), T("span", KN, A(pe(ut)(l.value)), 1)) : ye("", !0)])])])])]), m("div", XN, [m("div", JN, [c.value === "performance" && u.value || !u.value ? (_(), T("div", YN, [m("div", QN, [m("div", {
              class: ie(["lg:col-span-3", u.value ? "mb-12" : "0"])
          }, [z(Tm, {
              "wallet-address": pe(s)
          }, null, 8, ["wallet-address"])], 2)])])) : ye("", !0), c.value === "wallet" && u.value || !u.value ? (_(), T("div", ZN, [r.value ? (_(), xe(xm, {
              key: 0,
              "spot-balances": r.value.spotBalances,
              "launch-balances": r.value.launchBalances,
              walletName: r.value.name,
              class: "mt-8 mb-20 lg:mb-8"
          }, null, 8, ["spot-balances", "launch-balances", "walletName"])) : ye("", !0)])) : ye("", !0)])])])])], 64))
      }
  });
const tM = Ee(eM, [
      ["__scopeId", "data-v-1bf13c83"]
  ]),
  Sm = Xi("cabal", () => {
      const i = M(new Map);
      return {
          cabals: i,
          fetchCabals: async () => {
              try {
                  const t = await dt.hypurrFunCabals({}, {});
                  i.value = new Map;
                  for (let n of t.response.cabals) i.value.set(n.telegramChatId, n)
              } catch (t) {
                  console.error(t), t.code
              }
          }
      }
  }),
  iM = {
      key: 0,
      class: "bg-white dark:bg-slate-800 dark:text-white shadow-lg rounded-lg p-4 w-full max-w-sm border border-gray-300 dark:border-gray-700"
  },
  nM = {
      class: "flex items-center mb-4"
  },
  sM = {
      class: "relative"
  },
  rM = {
      class: "ml-3 flex-grow"
  },
  aM = {
      class: "text-lg font-bold text-black dark:text-white truncate"
  },
  lM = {
      class: "grid grid-cols-2 gap-4 mt-2"
  },
  oM = {
      class: "bg-gray-50 dark:bg-slate-700 p-3 rounded-lg"
  },
  uM = {
      class: "text-base font-semibold text-black dark:text-white"
  },
  cM = {
      class: "bg-gray-50 dark:bg-slate-700 p-3 rounded-lg"
  },
  hM = {
      class: "bg-gray-50 dark:bg-slate-700 p-3 rounded-lg"
  },
  dM = {
      class: "bg-gray-50 dark:bg-slate-700 p-3 rounded-lg"
  },
  fM = U({
      name: "Card"
  }),
  Ro = U({
      ...fM,
      props: {
          cabal: {},
          rank: {}
      },
      setup(i) {
          const e = i,
              t = q(() => {
                  let u = 0;
                  return e.cabal.summary && (u += e.cabal.summary.seasonSpotPnl, u += e.cabal.summary.seasonPerpPnl, u += e.cabal.summary.seasonLaunchPnl), Nt(u)
              }),
              n = q(() => e.cabal ? parseFloat(t.value.slice(1)) >= 0 ? "text-green-500" : "text-red-500" : ""),
              s = q(() => e.cabal ? "https://media.hypurr.fun/" + e.cabal.pictureFileId : ""),
              r = q(() => {
                  switch (e.rank) {
                      case 1:
                          return "text-blue-500 border-blue-500";
                      case 2:
                          return "text-yellow-500 border-yellow-500";
                      case 3:
                          return "text-gray-500 border-gray-500";
                      case 4:
                          return "text-amber-600 border-amber-600";
                      default:
                          return ""
                  }
              }),
              a = q(() => e.cabal.summary.seasonSpotPnl >= 0 ? "text-green-500" : "text-red-500"),
              l = q(() => e.cabal.summary.seasonPerpPnl >= 0 ? "text-green-500" : "text-red-500"),
              o = q(() => e.cabal.summary.seasonLaunchPnl >= 0 ? "text-green-500" : "text-red-500");
          return (u, c) => u.cabal ? (_(), T("div", iM, [m("div", nM, [m("div", sM, [z(qi, {
              class: "h-12 w-12",
              src: s.value
          }, null, 8, ["src"]), u.rank ? (_(), T("div", {
              key: 0,
              class: ie([r.value, "absolute -top-2 -left-2 w-6 h-6 rounded-full flex items-center justify-center text-sm font-bold bg-white dark:bg-slate-800 shadow-sm border-2 border-current"])
          }, A(u.rank), 3)) : ye("", !0)]), m("div", rM, [m("h2", aM, A(u.cabal.name), 1), m("span", {
              class: ie([n.value, "text-lg font-semibold"])
          }, A(t.value), 3)])]), m("div", lM, [m("div", oM, [c[0] || (c[0] = m("p", {
              class: "text-xs text-gray-500 dark:text-gray-400"
          }, "User Count", -1)), m("p", uM, A(e.cabal.summary.userCount), 1)]), m("div", cM, [c[1] || (c[1] = m("p", {
              class: "text-xs text-gray-500 dark:text-gray-400"
          }, "Spot PnL", -1)), m("p", {
              class: ie(["text-base font-semibold", a.value])
          }, A(pe(Nt)(e.cabal.summary.seasonSpotPnl)), 3)]), m("div", hM, [c[2] || (c[2] = m("p", {
              class: "text-xs text-gray-500 dark:text-gray-400"
          }, "Perp PnL", -1)), m("p", {
              class: ie(["text-base font-semibold", l.value])
          }, A(pe(Nt)(e.cabal.summary.seasonPerpPnl)), 3)]), m("div", dM, [c[3] || (c[3] = m("p", {
              class: "text-xs text-gray-500 dark:text-gray-400"
          }, "Launch PnL", -1)), m("p", {
              class: ie(["text-base font-semibold", o.value])
          }, A(pe(Nt)(e.cabal.summary.seasonLaunchPnl)), 3)])])])) : ye("", !0)
      }
  }),
  pM = U({
      name: "CardLoading"
  }),
  mM = {
      class: "bg-white dark:bg-slate-800 shadow-lg rounded-lg p-6 w-full max-w-sm border border-gray-700"
  },
  gM = {
      class: "animate-pulse space-y-4"
  },
  yM = {
      class: "grid grid-cols-2 gap-4"
  };

function vM(i, e, t, n, s, r) {
  return _(), T("div", mM, [m("div", gM, [e[1] || (e[1] = m("div", {
      class: "flex justify-between items-center mb-6"
  }, [m("div", {
      class: "h-7 bg-gray-300 dark:bg-slate-700 rounded w-1/4"
  }), m("div", {
      class: "h-7 bg-gray-300 dark:bg-slate-700 rounded w-1/4"
  })], -1)), m("div", yM, [(_(), T(F, null, ue(4, a => m("div", {
      key: a
  }, e[0] || (e[0] = [m("div", {
      class: "h-4 bg-gray-300 dark:bg-slate-700 rounded w-full mb-1 pl-1"
  }, null, -1), m("div", {
      class: "h-5 bg-gray-300 dark:bg-slate-700 rounded w-full mb-1 pl-1"
  }, null, -1)]))), 64))])])])
}
const Bo = Ee(pM, [
      ["render", vM]
  ]),
  bM = {
      class: "max-w-screen-2xl mx-auto mt-4 mb-6 w-full"
  },
  wM = {
      key: 0
  },
  kM = {
      class: "md:hidden"
  },
  _M = {
      class: "hidden md:flex md:justify-between md:space-x-4"
  },
  xM = {
      key: 1
  },
  TM = {
      class: "lg:hidden"
  },
  SM = {
      class: "hidden lg:flex lg:justify-between lg:space-x-4"
  },
  cd = M(!0),
  EM = U({
      name: "TopSection",
      components: {
          Card: Ro,
          CardLoading: Bo,
          Swiper: qs,
          SwiperSlide: Gs
      }
  }),
  CM = U({
      ...EM,
      setup(i) {
          const e = M(window.innerWidth),
              t = Sm(),
              n = q(() => [...t.cabals.values()].sort((a, l) => {
                  let o = a.summary.seasonSpotPnl + a.summary.seasonPerpPnl + a.summary.seasonLaunchPnl;
                  return l.summary.seasonSpotPnl + l.summary.seasonPerpPnl + l.summary.seasonLaunchPnl - o
              }).slice(0, 4)),
              s = q(() => e.value < 640 ? 1 : 2),
              r = async () => {
                  await t.fetchCabals(), setTimeout(() => {
                      cd.value = !1
                  }, 200)
              };
          return Te(() => {
              r(), window.addEventListener("resize", () => {
                  e.value = window.innerWidth
              })
          }), (a, l) => (_(), T("div", bM, [cd.value ? (_(), T("div", wM, [m("div", kM, [(_(), T(F, null, ue(1, o => z(Bo, {
              key: o
          })), 64))]), m("div", _M, [(_(), T(F, null, ue(4, o => z(Bo, {
              key: o
          })), 64))])])) : (_(), T("div", xM, [m("div", TM, [z(pe(qs), {
              "slides-per-view": s.value,
              "space-between": 20,
              modules: [pe(yu), pe(mu), pe(gu)],
              autoplay: {
                  delay: 3e3,
                  disableOnInteraction: !1
              },
              navigation: !1,
              pagination: !1
          }, {
              default: We(() => [(_(!0), T(F, null, ue(n.value, (o, u) => (_(), xe(pe(Gs), {
                  key: u
              }, {
                  default: We(() => [z(Ro, {
                      cabal: o,
                      rank: u + 1
                  }, null, 8, ["cabal", "rank"])]),
                  _: 2
              }, 1024))), 128))]),
              _: 1
          }, 8, ["slides-per-view", "modules"])]), m("div", SM, [(_(!0), T(F, null, ue(n.value, (o, u) => (_(), xe(Ro, {
              key: u,
              cabal: o,
              rank: u + 1
          }, null, 8, ["cabal", "rank"]))), 128))])]))]))
      }
  }),
  $M = Xi("cabalsFilter", {
      state: () => ({
          sortColumn: "",
          sortDirection: "desc"
      }),
      actions: {
          setSortColumn(i) {
              this.sortColumn = i, this.saveToLocalStorage()
          },
          setSortDirection(i) {
              this.sortDirection = i, this.saveToLocalStorage()
          },
          loadFromLocalStorage() {
              const i = localStorage.getItem("exploreFilterState");
              if (i) try {
                  const e = JSON.parse(i);
                  this.$patch(e)
              } catch (e) {
                  console.error("Error parsing saved state:", e)
              }
          },
          saveToLocalStorage() {
              try {
                  localStorage.setItem("exploreFilterState", JSON.stringify({
                      sortColumn: this.sortColumn,
                      sortDirection: this.sortDirection
                  }))
              } catch (i) {
                  console.error("Error saving state to localStorage:", i)
              }
          }
      }
  }),
  LM = {
      class: "sticky top-0 z-20 bg-gray-50 dark:bg-slate-700 rounded-t-lg"
  },
  PM = ["onClick"],
  IM = {
      class: "mr-4"
  },
  NM = {
      key: 0,
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-0 md:group-hover:opacity-100 transition-opacity duration-200"
  },
  MM = {
      key: 1
  },
  RM = {
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-100 md:group-hover:opacity-0 transition-opacity"
  },
  BM = {
      class: "transition-all ease-in-out duration-75 absolute top-0 right-0 opacity-0 md:group-hover:opacity-100 transition-opacity"
  },
  OM = U({
      name: "GalleryFilter"
  }),
  Em = U({
      ...OM,
      props: {
          cabals: {},
          columns: {}
      },
      emits: ["update"],
      setup(i, {
          emit: e
      }) {
          const t = i,
              n = e,
              s = $M(),
              r = (o, u) => u.split(".").reduce((c, h) => c && c[h], o),
              a = () => {
                  let o = t.cabals.filter(u => !0);
                  o.sort((u, c) => {
                      let h, d;
                      return s.sortColumn === "totalPnl" ? (h = u.summary?.seasonSpotPnl + u.summary?.seasonLaunchPnl + u.summary?.seasonPerpPnl || 0, d = c.summary?.seasonSpotPnl + c.summary?.seasonLaunchPnl + c.summary?.seasonPerpPnl || 0) : s.sortColumn === "spotPnl" ? (h = u.summary?.seasonSpotPnl || 0, d = c.summary?.seasonSpotPnl || 0) : s.sortColumn === "perpPnl" ? (h = u.summary?.seasonPerpPnl || 0, d = c.summary?.seasonPerpPnl || 0) : s.sortColumn === "launchPnl" ? (h = u.summary?.seasonLaunchPnl || 0, d = c.summary?.seasonLaunchPnl || 0) : (h = r(u, s.sortColumn), d = r(c, s.sortColumn)), typeof h == "string" && (h = h.toLowerCase()), typeof d == "string" && (d = d.toLowerCase()), h < d ? s.sortDirection === "asc" ? -1 : 1 : h > d ? s.sortDirection === "asc" ? 1 : -1 : 0
                  }), n("update", o)
              },
              l = o => {
                  s.sortColumn === o ? s.sortDirection === "asc" ? (s.setSortColumn(""), s.setSortDirection("desc")) : s.setSortDirection("asc") : (s.setSortColumn(o), s.setSortDirection("desc")), a()
              };
          return Te(() => {
              s.loadFromLocalStorage(), a()
          }), Ie(() => t.cabals, a, {
              immediate: !0
          }), (o, u) => (_(), T("thead", LM, [m("tr", null, [(_(!0), T(F, null, ue(o.columns, c => (_(), T("th", {
              key: c.key,
              scope: "col",
              style: tt([c.key === "marketCap" || c.key === "dailyNtlVolume" ? {
                  minWidth: "140px"
              } : {}, {
                  width: c.width
              }]),
              class: ie(["py-3 px-3 text-sm font-semibold text-gray-900 dark:text-gray-300 cursor-pointer white-space-nowrap", c.align === "right" ? "text-right" : "text-left", c.key === "base.name" ? "sticky left-0 bg-gray-50 dark:bg-slate-700 z-20" : ""])
          }, [m("div", {
              class: ie(["flex items-center", c.align === "right" ? "justify-end" : "justify-start"])
          }, [m("span", {
              onClick: h => l(c.key),
              class: "cursor-pointer group relative"
          }, [m("span", IM, A(c.label), 1), pe(s).sortColumn !== c.key ? (_(), T("span", NM, " \u25BC ")) : ye("", !0), pe(s).sortColumn === c.key ? (_(), T("span", MM, [m("span", RM, A(pe(s).sortDirection === "asc" ? "\u25B2" : "\u25BC"), 1), m("span", BM, A(pe(s).sortDirection === "asc" ? "" : "\u25B2"), 1)])) : ye("", !0)], 8, PM)], 2)], 6))), 128))])]))
      }
  }),
  DM = {
      key: 0,
      class: "flex items-center space-x-2"
  },
  FM = U({
      name: "CabalRow"
  }),
  Cm = U({
      ...FM,
      props: {
          cabal: {},
          columns: {}
      },
      setup(i) {
          const e = i,
              t = s => {
                  switch (s) {
                      case "name":
                          return e.cabal.name;
                      case "totalPnl":
                          let r = e.cabal.summary?.seasonSpotPnl + e.cabal.summary?.seasonLaunchPnl + e.cabal.summary?.seasonPerpPnl;
                          return Nt(r);
                      case "spotPnl":
                          return Nt(e.cabal.summary?.seasonSpotPnl);
                      case "launchPnl":
                          return Nt(e.cabal.summary?.seasonLaunchPnl);
                      case "perpPnl":
                          return Nt(e.cabal.summary?.seasonPerpPnl);
                      default:
                          return ""
                  }
              },
              n = q(() => e.cabal ? "https://media.hypurr.fun/" + e.cabal.pictureFileId : "");
          return (s, r) => {
              const a = st("router-link");
              return _(), T("tr", null, [(_(!0), T(F, null, ue(s.columns, l => (_(), T("td", {
                  key: l.key,
                  class: ie(["whitespace-nowrap py-4 px-3 text-sm bg-white dark:bg-slate-800", l.align === "right" ? "text-right" : "text-left", l.key === "base.name" ? "font-medium text-gray-900 dark:text-gray-300 sticky left-0 bg-white dark:bg-slate-800 z-10" : "text-gray-500 dark:text-gray-300"]),
                  style: tt({
                      width: l.width
                  })
              }, [l.key === "name" ? (_(), T("div", DM, [z(qi, {
                  class: "h-8 w-8",
                  src: n.value
              }, null, 8, ["src"]), z(a, {
                  to: {
                      name: "CabalDetail",
                      params: {
                          id: s.cabal.telegramChatId
                      }
                  }
              }, {
                  default: We(() => [Xe(A(t(l.key)), 1)]),
                  _: 2
              }, 1032, ["to"])])) : (_(), T(F, {
                  key: 1
              }, [Xe(A(t(l.key)), 1)], 64))], 6))), 128))])
          }
      }
  }),
  AM = U({
      name: "PairRowLoading"
  }),
  $m = U({
      ...AM,
      props: {
          columns: {}
      },
      setup(i) {
          const e = t => {
              switch (t) {
                  case "base.name":
                      return "w-3/4";
                  case "markPrice":
                  case "priceChange":
                      return "w-2/3";
                  case "dailyNtlVolume":
                  case "marketCap":
                      return "w-1/2";
                  default:
                      return "w-1/2"
              }
          };
          return (t, n) => (_(), T("tr", null, [(_(!0), T(F, null, ue(t.columns, (s, r) => (_(), T("td", {
              key: r,
              class: ie(["whitespace-nowrap py-4 px-3 text-sm bg-white dark:bg-slate-800", s.key === "base.name" ? "font-medium text-gray-900 sticky left-0 bg-white dark:bg-slate-800 z-10" : "text-gray-500"]),
              style: tt({
                  width: s.width
              })
          }, [m("div", {
              class: ie(["animate-pulse bg-gray-300 dark:bg-slate-700 h-6 rounded", [e(s.key), s.align === "right" ? "ml-auto" : "mr-auto"]])
          }, null, 2)], 6))), 128))]))
      }
  }),
  VM = {
      class: "flex flex-col h-full max-w-screen-2xl mx-auto bg-gray-300/25 dark:bg-slate-700/25 rounded-lg lg:rounded-xl overflow-hidden border border-gray-300 dark:border-gray-700"
  },
  zM = {
      class: "overflow-x-auto overflow-y-auto"
  },
  WM = {
      class: "w-full min-w-[640px]"
  },
  UM = {
      class: "divide-y divide-gray-300 dark:divide-gray-700 w-full"
  },
  hd = M(!0),
  jM = U({
      name: "Gallery",
      components: {
          GalleryFilter: Em,
          CabalRow: Cm,
          CabalRowLoading: $m
      }
  }),
  HM = U({
      ...jM,
      setup(i) {
          const e = Sm(),
              t = q(() => Array.from(e.cabals.values())),
              n = M([]),
              s = M(""),
              r = [{
                  key: "name",
                  label: "Name",
                  align: "left",
                  width: "14%"
              }, {
                  key: "totalPnl",
                  label: "Total PnL",
                  align: "right",
                  width: "20%"
              }, {
                  key: "spotPnl",
                  label: "Spot PnL",
                  align: "right",
                  width: "20%"
              }, {
                  key: "launchPnl",
                  label: "Launch PnL",
                  align: "right",
                  width: "20%"
              }, {
                  key: "perpPnl",
                  label: "Perp PnL",
                  align: "right",
                  width: "24%"
              }],
              a = q(() => s.value ? t.value.filter(o => o.name.toLowerCase().includes(s.value.toLowerCase())) : t.value),
              l = o => {
                  n.value = o
              };
          return Te(async () => {
              await e.fetchCabals(), setTimeout(() => {
                  hd.value = !1
              }, 200)
          }), (o, u) => (_(), T("div", VM, [m("div", zM, [m("table", WM, [z(Em, {
              cabals: a.value,
              columns: r,
              onUpdate: l
          }, null, 8, ["cabals"]), m("tbody", UM, [hd.value ? (_(), T(F, {
              key: 0
          }, ue(24, c => z($m, {
              key: c,
              columns: r
          })), 64)) : (_(!0), T(F, {
              key: 1
          }, ue(n.value, c => (_(), xe(Cm, {
              key: c.telegramChatId,
              cabal: c,
              columns: r
          }, null, 8, ["cabal"]))), 128))])])])]))
      }
  });
const qM = Ee(HM, [
      ["__scopeId", "data-v-27e40d0a"]
  ]),
  GM = {
      name: "Cabals",
      components: {
          TopSection: CM,
          Gallery: qM
      }
  },
  KM = {
      class: "flex flex-col h-[calc(100vh-100px)] py-4 z-10 relative px-4 sm:px-6 xl:px-2 overflow-y-auto landscape:overflow-y-auto"
  },
  XM = {
      class: "flex-shrink-0"
  },
  JM = {
      class: "flex-grow overflow-hidden landscape:min-h-[300px]"
  };

function YM(i, e, t, n, s, r) {
  const a = st("TopSection"),
      l = st("Gallery");
  return _(), T(F, null, [e[0] || (e[0] = m("div", {
      class: "absolute inset-y-0 right-1/2 z-1 -mr-96 w-[200%] origin-top-right skew-x-[-30deg] bg-white dark:bg-slate-900 ring-1 ring-green-50 dark:ring-green-400 sm:-mr-80 lg:-mr-48",
      "aria-hidden": "true"
  }, null, -1)), m("div", KM, [m("div", XM, [z(a)]), m("div", JM, [z(l)])])], 64)
}
const QM = Ee(GM, [
      ["render", YM]
  ]),
  ZM = {
      name: "CabalDetail",
      components: {}
  };

function e4(i, e, t, n, s, r) {
  return null
}
const t4 = Ee(ZM, [
      ["render", e4]
  ]),
  i4 = [{
      path: "/",
      name: "Home",
      component: Rx
  }, {
      path: "/pair/:id",
      name: "PairDetail",
      component: lI,
      props: !0
  }, {
      path: "/launches",
      name: "Launches",
      component: pS
  }, {
      path: "/launch/:id",
      name: "LaunchDetail",
      component: rP,
      props: !0
  }, {
      path: "/wallet",
      name: "UserWallet",
      component: FN
  }, {
      path: "/wallet/:address",
      name: "PublicWallet",
      component: tM
  }, {
      path: "/cabals",
      name: "Cabals",
      component: QM
  }, {
      path: "/cabals/:id",
      name: "CabalDetail",
      component: t4
  }],
  Oo = [{
      name: "Explore",
      to: "/"
  }, {
      name: "Launches",
      to: "/launches"
  }, {
      name: "Cabals",
      to: "/cabals"
  }],
  n4 = Z1({
      history: $1(),
      routes: i4
  }),
  s4 = Object.freeze(Object.defineProperty({
      __proto__: null,
      appRouter: n4,
      routerAppItems: Oo
  }, Symbol.toStringTag, {
      value: "Module"
  })),
  r4 = {
      __name: "TgLogin",
      props: {
          mode: {
              type: String,
              required: !0,
              validator(i) {
                  return ["callback", "redirect"].includes(i)
              }
          },
          telegramLogin: {
              type: String,
              required: !0,
              validator(i) {
                  return i.endsWith("bot") || i.endsWith("Bot")
              }
          },
          redirectUrl: {
              type: String,
              default: ""
          },
          requestAccess: {
              type: String,
              default: "read",
              validator(i) {
                  return ["read", "write"].includes(i)
              }
          },
          size: {
              type: String,
              default: "large",
              validator(i) {
                  return ["small", "medium", "large"].includes(i)
              }
          },
          userpic: {
              type: Boolean,
              default: !0
          },
          radius: {
              type: String
          }
      },
      emits: ["callback", "loaded"],
      setup(i, {
          emit: e
      }) {
          const t = i,
              n = e;

          function s(l) {
              n("callback", l)
          }
          const r = M(null),
              a = document.createElement("script");
          return a.async = !0, a.src = "https://telegram.org/js/telegram-widget.js?3", a.setAttribute("data-size", t.size), a.setAttribute("data-userpic", t.userpic), a.setAttribute("data-telegram-login", t.telegramLogin), a.setAttribute("data-request-access", t.requestAccess), a.onload = () => {
              n("loaded")
          }, t.radius && a.setAttribute("data-radius", t.radius), t.mode === "callback" ? (window.onTelegramAuth = s, a.setAttribute("data-onauth", "window.onTelegramAuth(user)")) : a.setAttribute("data-auth-url", t.redirectUrl), Te(() => {
              r.value.appendChild(a)
          }), (l, o) => (_(), T("div", {
              ref_key: "telegram",
              ref: r
          }, null, 512))
      }
  },
  a4 = {
      key: 0,
      class: "relative"
  },
  l4 = {
      key: 0,
      class: "absolute right-0 mt-4 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg z-10 border border-gray-200 dark:border-gray-700"
  },
  o4 = {
      class: "px-4 py-3 border-b border-gray-200 dark:border-gray-700"
  },
  u4 = {
      class: "flex items-center"
  },
  c4 = {
      class: "ml-3"
  },
  h4 = {
      class: "text-sm font-medium text-gray-900 dark:text-gray-100"
  },
  d4 = {
      class: "text-xs text-gray-500 dark:text-gray-400 truncate"
  },
  f4 = {
      class: "py-1"
  },
  p4 = ["onClick"],
  m4 = {
      key: 1
  },
  g4 = {
      key: 0,
      class: "flex items-center justify-center h-12 w-12"
  },
  y4 = {
      key: 1
  },
  v4 = U({
      name: "TgConnect"
  }),
  b4 = U({
      ...v4,
      setup(i) {
          const e = Ji(),
              t = q(() => e.user),
              n = q(() => e.userLoading),
              s = gp(),
              r = M(!1),
              a = [{
                  label: "Wallets",
                  icon: tL,
                  action: () => o("wallet")
              }, {
                  label: "Logout",
                  icon: Z$,
                  action: u
              }];

          function l() {
              r.value = !r.value
          }

          function o(f) {
              s.push(`/${f}`), r.value = !1
          }

          function u() {
              e.logout(), r.value = !1
          }

          function c(f) {
              console.log("telegramLoadedCallbackFunc", f)
          }
          async function h(f) {
              console.log("login !", f);
              try {
                  await e.onTelegramLogin(f)
              } catch (p) {
                  console.error(p)
              }
          }

          function d(f) {
              f.target.closest(".relative") || (r.value = !1)
          }
          return Te(() => {
              document.addEventListener("click", d)
          }), ct(() => {
              document.removeEventListener("click", d)
          }), (f, p) => t.value ? (_(), T("div", a4, [m("button", {
              onClick: _y(l, ["stop"]),
              class: "flex items-center focus:outline-none"
          }, [z(qi, {
              class: "h-12 w-12",
              src: t.value.getProfilePicture()
          }, null, 8, ["src"])]), z(ga, {
              "enter-active-class": "transition ease-out duration-200",
              "enter-from-class": "transform opacity-0 scale-95",
              "enter-to-class": "transform opacity-100 scale-100",
              "leave-active-class": "transition ease-in duration-75",
              "leave-from-class": "transform opacity-100 scale-100",
              "leave-to-class": "transform opacity-0 scale-95"
          }, {
              default: We(() => [r.value ? (_(), T("div", l4, [p[0] || (p[0] = m("div", {
                  class: "absolute -top-2 right-4 w-4 h-4 rotate-45 bg-white dark:bg-gray-800 border-t border-l border-gray-200 dark:border-gray-700"
              }, null, -1)), m("div", o4, [m("div", u4, [z(qi, {
                  class: "h-8 w-8",
                  src: t.value.getProfilePicture()
              }, null, 8, ["src"]), m("div", c4, [m("p", h4, A(t.value.getDisplayName()), 1), m("p", d4, "@" + A(t.value.auth.username), 1)])])]), m("div", f4, [(_(), T(F, null, ue(a, (g, w) => m("a", {
                  key: w,
                  href: "#",
                  onClick: g.action,
                  class: "flex items-center px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors duration-150"
              }, [(_(), xe(Xl(g.icon), {
                  class: "w-4 h-4 mr-3"
              })), Xe(" " + A(g.label), 1)], 8, p4)), 64))])])) : ye("", !0)]),
              _: 1
          })])) : (_(), T("div", m4, [n.value ? (_(), T("div", g4, p[1] || (p[1] = [m("div", {
              class: "animate-spin rounded-full h-8 w-8 border-b-2 border-green-500"
          }, null, -1)]))) : (_(), T("div", y4, [z(r4, {
              mode: "callback",
              "telegram-login": "HypurrFunBot",
              onLoaded: c,
              onCallback: h
          })]))]))
      }
  });
const Do = Ee(b4, [
      ["__scopeId", "data-v-0f9c5f13"]
  ]),
  w4 = {
      key: 0,
      class: "w-4 h-4 text-green-400",
      fill: "none",
      viewBox: "0 0 24 24",
      stroke: "currentColor"
  },
  k4 = {
      key: 1,
      class: "w-4 h-4 text-gray-400",
      fill: "none",
      viewBox: "0 0 24 24",
      stroke: "currentColor"
  },
  _4 = U({
      name: "SwitchMode"
  }),
  Fo = U({
      ..._4,
      setup(i) {
          const e = M(!1),
              t = () => {
                  e.value = !e.value, n()
              },
              n = () => {
                  e.value ? (document.documentElement.classList.add("dark"), document.body.classList.add("dark")) : (document.documentElement.classList.remove("dark"), document.body.classList.remove("dark")), localStorage.setItem("darkMode", e.value.toString())
              };
          return Te(() => {
              const s = localStorage.getItem("darkMode");
              e.value = s === "true", n()
          }), Ie(e, n), (s, r) => (_(), T("button", {
              onClick: t,
              class: ie(["relative inline-flex items-center h-5 rounded-full w-14 focus:outline-none transition-colors duration-200 ease-in-out", e.value ? "bg-green-600" : "bg-gray-200"])
          }, [m("span", {
              class: ie(["inline-flex items-center justify-center w-7 h-7 transform transition-transform duration-200 ease-in-out rounded-full shadow-md", [e.value ? "translate-x-8 bg-slate-700 shadow-green-400/20" : "translate-x-0 bg-white"]])
          }, [e.value ? (_(), T("svg", w4, r[0] || (r[0] = [m("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
              d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z"
          }, null, -1)]))) : (_(), T("svg", k4, r[1] || (r[1] = [m("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
              d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z"
          }, null, -1)])))], 2)], 2))
      }
  }),
  x4 = ["title"],
  T4 = U({
      name: "AnimationToggle"
  }),
  Ao = U({
      ...T4,
      setup(i) {
          const e = Ji(),
              t = q(() => e.animationsEnabled),
              n = () => {
                  e.toggleAnimations()
              };
          return (s, r) => (_(), T("button", {
              onClick: n,
              class: ie(["p-2 text-gray-500 dark:text-gray-300 hover:text-green-700 dark:hover:text-green-400 transition-colors", t.value ? "text-gray-500 dark:text-gray-300" : "text-green-700 dark:text-green-400"]),
              title: t.value ? "Disable animations" : "Enable animations"
          }, r[0] || (r[0] = [m("svg", {
              xmlns: "http://www.w3.org/2000/svg",
              class: "h-6 w-6",
              fill: "none",
              viewBox: "0 0 24 24",
              stroke: "currentColor"
          }, [m("path", {
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-width": "2",
              d: "M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"
          })], -1)]), 10, x4))
      }
  }),
  S4 = {
      class: "flex justify-between items-center p-4 bg-white dark:bg-slate-800 dark:text-white border-b border-border dark:border-gray-700 overflow-visible z-50 relative w-full h-20"
  },
  E4 = {
      class: "flex items-center"
  },
  C4 = {
      class: "md:hidden"
  },
  $4 = {
      class: "flex flex-col justify-center align-center -mt-2 cursor-pointer"
  },
  L4 = {
      class: "hidden md:flex flex-grow justify-start space-x-4 ml-20 transition-all ease-in-out"
  },
  P4 = ["href", "onClick", "aria-current"],
  I4 = {
      class: "hidden md:flex items-center space-x-4"
  },
  N4 = {
      key: 0,
      class: "fixed top-[80px] left-0 right-0 z-50 min-h-[calc(100vh-80px)] w-full bg-black/50"
  },
  M4 = {
      class: "bg-white dark:bg-slate-800 shadow-green-700 min-h-[calc(100vh-80px)] w-4/6 overflow-y-auto rounded-br-xl drop-shadow-xl flex flex-col justify-between"
  },
  R4 = ["href", "onClick", "aria-current"],
  B4 = {
      class: "md:hidden flex items-center space-x-2"
  },
  O4 = {
      name: "Header",
      components: {
          TgConnect: Do,
          SwitchMode: Fo,
          AnimationToggle: Ao
      }
  },
  D4 = U({
      ...O4,
      props: {
          show: {
              type: Boolean,
              default: !1
          }
      },
      emits: ["toggleEmojiTrail"],
      setup(i, {
          emit: e
      }) {
          const t = Ji(),
              n = M(!1);
          q(() => t.user), M(null), M(null), M(!1), M(""), M("");
          const s = () => {
              n.value = !n.value
          };
          return (r, a) => {
              const l = st("router-link");
              return _(), T("header", S4, [m("div", E4, [m("div", C4, [m("button", {
                  onClick: s,
                  class: ie(["text-gray-500 dark:text-gray-300 hover:text-green-700 dark:hover:text-green-400", n.value ? "text-green-700" : "text-gray-500"])
              }, a[1] || (a[1] = [m("svg", {
                  class: "h-6 w-6",
                  fill: "none",
                  viewBox: "0 0 24 24",
                  stroke: "currentColor"
              }, [m("path", {
                  "stroke-linecap": "round",
                  "stroke-linejoin": "round",
                  "stroke-width": "2",
                  d: "M4 6h16M4 12h16M4 18h16"
              })], -1)]), 2)]), m("div", $4, [m("img", {
                  src: Is,
                  alt: "Logo",
                  class: "h-12 md:h-16",
                  onClick: a[0] || (a[0] = o => r.$emit("toggleEmojiTrail"))
              })])]), m("nav", L4, [(_(!0), T(F, null, ue(pe(Oo), o => (_(), xe(l, {
                  key: o.to,
                  to: o.to,
                  custom: ""
              }, {
                  default: We(({
                      isActive: u,
                      href: c,
                      navigate: h
                  }) => [m("a", {
                      href: c,
                      onClick: h,
                      class: ie([u ? "border-green-500 bg-green-50 text-green-700 dark:text-green-400 dark:bg-slate-700 dark:border-green-400" : "border-transparent text-gray-600 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800 dark:text-gray-300 dark:hover:bg-slate-800 dark:hover:text-white", "block border-l-4 py-2 pl-3 pr-4 text-base font-medium"]),
                      "aria-current": u ? "page" : void 0
                  }, A(o.name), 11, P4)]),
                  _: 2
              }, 1032, ["to"]))), 128))]), m("div", I4, [z(Ao), z(Fo), z(Do)]), n.value ? (_(), T("div", N4, [m("div", M4, [m("div", null, [(_(!0), T(F, null, ue(pe(Oo), o => (_(), xe(l, {
                  key: o.to,
                  to: o.to,
                  custom: ""
              }, {
                  default: We(({
                      isActive: u,
                      href: c,
                      navigate: h
                  }) => [m("a", {
                      href: c,
                      onClick: () => {
                          h(), s()
                      },
                      class: ie([u ? "border-green-500 bg-green-50 text-green-700 dark:text-green-400 dark:bg-slate-700 dark:border-green-400" : "border-transparent text-gray-600 dark:text-gray-500 hover:border-gray-300 hover:bg-gray-50 hover:text-gray-800", "block border-l-4 py-4 pl-3 pr-4 text-base font-medium"]),
                      "aria-current": u ? "page" : void 0
                  }, A(o.name), 11, R4)]),
                  _: 2
              }, 1032, ["to"]))), 128))])])])) : ye("", !0), m("div", B4, [z(Ao), z(Fo), z(Do)])])
          }
      }
  });
const Lm = Ee(D4, [
      ["__scopeId", "data-v-93944997"]
  ]),
  F4 = {
      name: "Footer"
  },
  A4 = {
      class: "p-4 bg-gray-50 dark:bg-slate-800 dark:text-white text-center relative z-10 h-14"
  };

function V4(i, e, t, n, s, r) {
  return _(), T("footer", A4, " Footer with link etc ")
}
const z4 = Ee(F4, [
      ["render", V4]
  ]),
  W4 = U({
      name: "EmojiTrail"
  }),
  U4 = U({
      ...W4,
      props: {
          active: Boolean
      },
      setup(i) {
          const e = i,
              t = M(null),
              n = M([]);
          let s = null,
              r = {
                  x: 0,
                  y: 0
              },
              a = 0;
          const l = 50,
              o = (f, p) => {
                  const g = Math.random() * 360;
                  n.value.push({
                      style: {
                          left: `${f}px`,
                          top: `${p}px`,
                          opacity: 1,
                          transform: `rotate(${g}deg)`
                      },
                      velocity: 0
                  })
              },
              u = () => {
                  n.value = n.value.filter(f => f.style.opacity > 0).map(f => {
                      f.style.opacity -= .01, f.velocity += .2;
                      const p = parseFloat(f.style.top);
                      return f.style.top = `${p+f.velocity}px`, f
                  }), s = requestAnimationFrame(u)
              },
              c = f => {
                  if (!e.active) return;
                  const p = Date.now(),
                      g = f.clientX - r.x,
                      w = f.clientY - r.y,
                      b = Math.sqrt(g * g + w * w) / (p - a),
                      x = Math.max(50, l - b * 100);
                  if (p - a > x && t.value) {
                      const k = t.value.getBoundingClientRect();
                      o(f.clientX - k.left, f.clientY - k.top), a = p
                  }
                  r = {
                      x: f.clientX,
                      y: f.clientY
                  }
              },
              h = () => {
                  window.addEventListener("mousemove", c), s = requestAnimationFrame(u)
              },
              d = () => {
                  window.removeEventListener("mousemove", c), s !== null && cancelAnimationFrame(s), n.value = []
              };
          return Ie(() => e.active, f => {
              f ? h() : d()
          }), Te(() => {
              e.active && h()
          }), ct(() => {
              d()
          }), (f, p) => (_(), T("div", {
              ref_key: "container",
              ref: t,
              class: "mouse-trail-container"
          }, [(_(!0), T(F, null, ue(n.value, (g, w) => (_(), T("div", {
              key: w,
              class: "emoji",
              style: tt(g.style)
          }, " \u{1F4B8} ", 4))), 128))], 512))
      }
  });
const Pm = Ee(U4, [
      ["__scopeId", "data-v-71064595"]
  ]),
  j4 = {
      class: "fixed bottom-4 right-4 z-50 space-y-2"
  },
  H4 = U({
      __name: "NotificationList",
      setup(i) {
          const e = gm(),
              t = q(() => e.notifications);
          return (n, s) => (_(), T("div", j4, [z(Vf, {
              name: "notification"
          }, {
              default: We(() => [(_(!0), T(F, null, ue(t.value, r => (_(), T("div", {
                  key: r.id,
                  class: ie(["p-4 rounded-lg shadow-lg max-w-sm transform transition-all duration-300", {
                      "bg-green-500 text-white": r.type === "success",
                      "bg-red-500 text-white": r.type === "error",
                      "bg-blue-500 text-white": r.type === "info",
                      "bg-yellow-500 text-white": r.type === "warning"
                  }])
              }, A(r.message), 3))), 128))]),
              _: 1
          })]))
      }
  });
const Im = Ee(H4, [
      ["__scopeId", "data-v-b7e636d7"]
  ]),
  q4 = {
      id: "app",
      class: "bg-green-100 dark:bg-slate-800 min-h-screen flex flex-col relative"
  },
  G4 = {
      class: "flex-grow overflow-hidden relative"
  },
  K4 = U({
      name: "App",
      components: {
          AppHeader: Lm,
          AppFooter: z4,
          EmojiTrail: Pm,
          LatestFillsBanner: wu,
          NotificationList: Im
      },
      props: {
          displayType: {
              type: String,
              required: !0
          }
      }
  }),
  X4 = U({
      ...K4,
      setup(i) {
          const e = M(!1),
              t = St();
          Te(() => {
              t.startLaunchStream()
          }), ct(() => {
              t.stopLaunchStream()
          });
          const n = () => {
              e.value = !e.value
          };
          return (s, r) => {
              const a = st("router-view");
              return _(), T("div", q4, [r[0] || (r[0] = m("div", {
                  class: "h-full w-full hidden dark:block bg-green-500/25 absolute top-0 left-0 z-0"
              }, null, -1)), z(Lm, {
                  class: "flex-shrink-0",
                  onToggleEmojiTrail: n
              }), z(ga, {
                  name: "fade",
                  mode: "out-in"
              }, {
                  default: We(() => [m("main", G4, [z(Pm, {
                      active: e.value
                  }, null, 8, ["active"]), z(a)])]),
                  _: 1
              }), z(Im)])
          }
      }
  });
const J4 = Ee(X4, [
  ["__scopeId", "data-v-8a0456b2"]
]);
var La = class {
      constructor() {
          this.listeners = new Set, this.subscribe = this.subscribe.bind(this)
      }
      subscribe(i) {
          return this.listeners.add(i), this.onSubscribe(), () => {
              this.listeners.delete(i), this.onUnsubscribe()
          }
      }
      hasListeners() {
          return this.listeners.size > 0
      }
      onSubscribe() {}
      onUnsubscribe() {}
  },
  Ys = typeof window > "u" || "Deno" in globalThis;

function Xt() {}

function Y4(i, e) {
  return typeof i == "function" ? i(e) : i
}

function Q4(i) {
  return typeof i == "number" && i >= 0 && i !== 1 / 0
}

function Z4(i, e) {
  return Math.max(i + (e || 0) - Date.now(), 0)
}

function dd(i, e) {
  return typeof i == "function" ? i(e) : i
}

function e3(i, e) {
  return typeof i == "function" ? i(e) : i
}

function fd(i, e) {
  const {
      type: t = "all",
      exact: n,
      fetchStatus: s,
      predicate: r,
      queryKey: a,
      stale: l
  } = i;
  if (a) {
      if (n) {
          if (e.queryHash !== Bu(a, e.options)) return !1
      } else if (!zs(e.queryKey, a)) return !1
  }
  if (t !== "all") {
      const o = e.isActive();
      if (t === "active" && !o || t === "inactive" && o) return !1
  }
  return !(typeof l == "boolean" && e.isStale() !== l || s && s !== e.state.fetchStatus || r && !r(e))
}

function pd(i, e) {
  const {
      exact: t,
      status: n,
      predicate: s,
      mutationKey: r
  } = i;
  if (r) {
      if (!e.options.mutationKey) return !1;
      if (t) {
          if (Vs(e.options.mutationKey) !== Vs(r)) return !1
      } else if (!zs(e.options.mutationKey, r)) return !1
  }
  return !(n && e.state.status !== n || s && !s(e))
}

function Bu(i, e) {
  return (e?.queryKeyHashFn || Vs)(i)
}

function Vs(i) {
  return JSON.stringify(i, (e, t) => Vo(t) ? Object.keys(t).sort().reduce((n, s) => (n[s] = t[s], n), {}) : t)
}

function zs(i, e) {
  return i === e ? !0 : typeof i != typeof e ? !1 : i && e && typeof i == "object" && typeof e == "object" ? !Object.keys(e).some(t => !zs(i[t], e[t])) : !1
}

function Nm(i, e) {
  if (i === e) return i;
  const t = md(i) && md(e);
  if (t || Vo(i) && Vo(e)) {
      const n = t ? i : Object.keys(i),
          s = n.length,
          r = t ? e : Object.keys(e),
          a = r.length,
          l = t ? [] : {};
      let o = 0;
      for (let u = 0; u < a; u++) {
          const c = t ? u : r[u];
          (!t && n.includes(c) || t) && i[c] === void 0 && e[c] === void 0 ? (l[c] = void 0, o++) : (l[c] = Nm(i[c], e[c]), l[c] === i[c] && i[c] !== void 0 && o++)
      }
      return s === a && o === s ? i : l
  }
  return e
}

function md(i) {
  return Array.isArray(i) && i.length === Object.keys(i).length
}

function Vo(i) {
  if (!gd(i)) return !1;
  const e = i.constructor;
  if (e === void 0) return !0;
  const t = e.prototype;
  return !(!gd(t) || !t.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(i) !== Object.prototype)
}

function gd(i) {
  return Object.prototype.toString.call(i) === "[object Object]"
}

function t3(i) {
  return new Promise(e => {
      setTimeout(e, i)
  })
}

function i3(i, e, t) {
  return typeof t.structuralSharing == "function" ? t.structuralSharing(i, e) : t.structuralSharing !== !1 ? Nm(i, e) : e
}

function n3(i, e, t = 0) {
  const n = [...i, e];
  return t && n.length > t ? n.slice(1) : n
}

function s3(i, e, t = 0) {
  const n = [e, ...i];
  return t && n.length > t ? n.slice(0, -1) : n
}
var Mm = Symbol(),
  Rm = (i, e) => !i.queryFn && e?.initialPromise ? () => e.initialPromise : !i.queryFn || i.queryFn === Mm ? () => Promise.reject(new Error(`Missing queryFn: '${i.queryHash}'`)) : i.queryFn,
  r3 = class extends La {
      #e;
      #t;
      #i;
      constructor() {
          super(), this.#i = i => {
              if (!Ys && window.addEventListener) {
                  const e = () => i();
                  return window.addEventListener("visibilitychange", e, !1), () => {
                      window.removeEventListener("visibilitychange", e)
                  }
              }
          }
      }
      onSubscribe() {
          this.#t || this.setEventListener(this.#i)
      }
      onUnsubscribe() {
          this.hasListeners() || (this.#t?.(), this.#t = void 0)
      }
      setEventListener(i) {
          this.#i = i, this.#t?.(), this.#t = i(e => {
              typeof e == "boolean" ? this.setFocused(e) : this.onFocus()
          })
      }
      setFocused(i) {
          this.#e !== i && (this.#e = i, this.onFocus())
      }
      onFocus() {
          const i = this.isFocused();
          this.listeners.forEach(e => {
              e(i)
          })
      }
      isFocused() {
          return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden"
      }
  },
  Bm = new r3,
  a3 = class extends La {
      #e = !0;
      #t;
      #i;
      constructor() {
          super(), this.#i = i => {
              if (!Ys && window.addEventListener) {
                  const e = () => i(!0),
                      t = () => i(!1);
                  return window.addEventListener("online", e, !1), window.addEventListener("offline", t, !1), () => {
                      window.removeEventListener("online", e), window.removeEventListener("offline", t)
                  }
              }
          }
      }
      onSubscribe() {
          this.#t || this.setEventListener(this.#i)
      }
      onUnsubscribe() {
          this.hasListeners() || (this.#t?.(), this.#t = void 0)
      }
      setEventListener(i) {
          this.#i = i, this.#t?.(), this.#t = i(this.setOnline.bind(this))
      }
      setOnline(i) {
          this.#e !== i && (this.#e = i, this.listeners.forEach(t => {
              t(i)
          }))
      }
      isOnline() {
          return this.#e
      }
  },
  ea = new a3;

function l3(i) {
  return Math.min(1e3 * 2 ** i, 3e4)
}

function Om(i) {
  return (i ?? "online") === "online" ? ea.isOnline() : !0
}
var Dm = class {
  constructor(i) {
      this.revert = i?.revert, this.silent = i?.silent
  }
};

function jl(i) {
  return i instanceof Dm
}

function Fm(i) {
  let e = !1,
      t = 0,
      n = !1,
      s, r, a;
  const l = new Promise((y, b) => {
          r = y, a = b
      }),
      o = y => {
          n || (p(new Dm(y)), i.abort?.())
      },
      u = () => {
          e = !0
      },
      c = () => {
          e = !1
      },
      h = () => Bm.isFocused() && (i.networkMode === "always" || ea.isOnline()) && i.canRun(),
      d = () => Om(i.networkMode) && i.canRun(),
      f = y => {
          n || (n = !0, i.onSuccess?.(y), s?.(), r(y))
      },
      p = y => {
          n || (n = !0, i.onError?.(y), s?.(), a(y))
      },
      g = () => new Promise(y => {
          s = b => {
              (n || h()) && y(b)
          }, i.onPause?.()
      }).then(() => {
          s = void 0, n || i.onContinue?.()
      }),
      w = () => {
          if (n) return;
          let y;
          const b = t === 0 ? i.initialPromise : void 0;
          try {
              y = b ?? i.fn()
          } catch (x) {
              y = Promise.reject(x)
          }
          Promise.resolve(y).then(f).catch(x => {
              if (n) return;
              const k = i.retry ?? (Ys ? 0 : 3),
                  S = i.retryDelay ?? l3,
                  B = typeof S == "function" ? S(t, x) : S,
                  D = k === !0 || typeof k == "number" && t < k || typeof k == "function" && k(t, x);
              if (e || !D) {
                  p(x);
                  return
              }
              t++, i.onFail?.(t, x), t3(B).then(() => h() ? void 0 : g()).then(() => {
                  e ? p(x) : w()
              })
          })
      };
  return {
      promise: l,
      cancel: o,
      continue: () => (s?.(), l),
      cancelRetry: u,
      continueRetry: c,
      canStart: d,
      start: () => (d() ? w() : g().then(w), l)
  }
}

function o3() {
  let i = [],
      e = 0,
      t = d => {
          d()
      },
      n = d => {
          d()
      },
      s = d => setTimeout(d, 0);
  const r = d => {
          s = d
      },
      a = d => {
          let f;
          e++;
          try {
              f = d()
          } finally {
              e--, e || u()
          }
          return f
      },
      l = d => {
          e ? i.push(d) : s(() => {
              t(d)
          })
      },
      o = d => (...f) => {
          l(() => {
              d(...f)
          })
      },
      u = () => {
          const d = i;
          i = [], d.length && s(() => {
              n(() => {
                  d.forEach(f => {
                      t(f)
                  })
              })
          })
      };
  return {
      batch: a,
      batchCalls: o,
      schedule: l,
      setNotifyFunction: d => {
          t = d
      },
      setBatchNotifyFunction: d => {
          n = d
      },
      setScheduler: r
  }
}
var kt = o3(),
  Am = class {
      #e;
      destroy() {
          this.clearGcTimeout()
      }
      scheduleGc() {
          this.clearGcTimeout(), Q4(this.gcTime) && (this.#e = setTimeout(() => {
              this.optionalRemove()
          }, this.gcTime))
      }
      updateGcTime(i) {
          this.gcTime = Math.max(this.gcTime || 0, i ?? (Ys ? 1 / 0 : 5 * 60 * 1e3))
      }
      clearGcTimeout() {
          this.#e && (clearTimeout(this.#e), this.#e = void 0)
      }
  },
  u3 = class extends Am {
      #e;
      #t;
      #i;
      #n;
      #a;
      #r;
      constructor(i) {
          super(), this.#r = !1, this.#a = i.defaultOptions, this.setOptions(i.options), this.observers = [], this.#i = i.cache, this.queryKey = i.queryKey, this.queryHash = i.queryHash, this.#e = i.state || h3(this.options), this.state = this.#e, this.scheduleGc()
      }
      get meta() {
          return this.options.meta
      }
      get promise() {
          return this.#n?.promise
      }
      setOptions(i) {
          this.options = {
              ...this.#a,
              ...i
          }, this.updateGcTime(this.options.gcTime)
      }
      optionalRemove() {
          !this.observers.length && this.state.fetchStatus === "idle" && this.#i.remove(this)
      }
      setData(i, e) {
          const t = i3(this.state.data, i, this.options);
          return this.#s({
              data: t,
              type: "success",
              dataUpdatedAt: e?.updatedAt,
              manual: e?.manual
          }), t
      }
      setState(i, e) {
          this.#s({
              type: "setState",
              state: i,
              setStateOptions: e
          })
      }
      cancel(i) {
          const e = this.#n?.promise;
          return this.#n?.cancel(i), e ? e.then(Xt).catch(Xt) : Promise.resolve()
      }
      destroy() {
          super.destroy(), this.cancel({
              silent: !0
          })
      }
      reset() {
          this.destroy(), this.setState(this.#e)
      }
      isActive() {
          return this.observers.some(i => e3(i.options.enabled, this) !== !1)
      }
      isDisabled() {
          return this.getObserversCount() > 0 && !this.isActive()
      }
      isStale() {
          return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(i => i.getCurrentResult().isStale) : this.state.data === void 0
      }
      isStaleByTime(i = 0) {
          return this.state.isInvalidated || this.state.data === void 0 || !Z4(this.state.dataUpdatedAt, i)
      }
      onFocus() {
          this.observers.find(e => e.shouldFetchOnWindowFocus())?.refetch({
              cancelRefetch: !1
          }), this.#n?.continue()
      }
      onOnline() {
          this.observers.find(e => e.shouldFetchOnReconnect())?.refetch({
              cancelRefetch: !1
          }), this.#n?.continue()
      }
      addObserver(i) {
          this.observers.includes(i) || (this.observers.push(i), this.clearGcTimeout(), this.#i.notify({
              type: "observerAdded",
              query: this,
              observer: i
          }))
      }
      removeObserver(i) {
          this.observers.includes(i) && (this.observers = this.observers.filter(e => e !== i), this.observers.length || (this.#n && (this.#r ? this.#n.cancel({
              revert: !0
          }) : this.#n.cancelRetry()), this.scheduleGc()), this.#i.notify({
              type: "observerRemoved",
              query: this,
              observer: i
          }))
      }
      getObserversCount() {
          return this.observers.length
      }
      invalidate() {
          this.state.isInvalidated || this.#s({
              type: "invalidate"
          })
      }
      fetch(i, e) {
          if (this.state.fetchStatus !== "idle") {
              if (this.state.data !== void 0 && e?.cancelRefetch) this.cancel({
                  silent: !0
              });
              else if (this.#n) return this.#n.continueRetry(), this.#n.promise
          }
          if (i && this.setOptions(i), !this.options.queryFn) {
              const l = this.observers.find(o => o.options.queryFn);
              l && this.setOptions(l.options)
          }
          const t = new AbortController,
              n = l => {
                  Object.defineProperty(l, "signal", {
                      enumerable: !0,
                      get: () => (this.#r = !0, t.signal)
                  })
              },
              s = () => {
                  const l = Rm(this.options, e),
                      o = {
                          queryKey: this.queryKey,
                          meta: this.meta
                      };
                  return n(o), this.#r = !1, this.options.persister ? this.options.persister(l, o, this) : l(o)
              },
              r = {
                  fetchOptions: e,
                  options: this.options,
                  queryKey: this.queryKey,
                  state: this.state,
                  fetchFn: s
              };
          n(r), this.options.behavior?.onFetch(r, this), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== r.fetchOptions?.meta) && this.#s({
              type: "fetch",
              meta: r.fetchOptions?.meta
          });
          const a = l => {
              jl(l) && l.silent || this.#s({
                  type: "error",
                  error: l
              }), jl(l) || (this.#i.config.onError?.(l, this), this.#i.config.onSettled?.(this.state.data, l, this)), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
          };
          return this.#n = Fm({
              initialPromise: e?.initialPromise,
              fn: r.fetchFn,
              abort: t.abort.bind(t),
              onSuccess: l => {
                  if (l === void 0) {
                      a(new Error(`${this.queryHash} data is undefined`));
                      return
                  }
                  this.setData(l), this.#i.config.onSuccess?.(l, this), this.#i.config.onSettled?.(l, this.state.error, this), this.isFetchingOptimistic || this.scheduleGc(), this.isFetchingOptimistic = !1
              },
              onError: a,
              onFail: (l, o) => {
                  this.#s({
                      type: "failed",
                      failureCount: l,
                      error: o
                  })
              },
              onPause: () => {
                  this.#s({
                      type: "pause"
                  })
              },
              onContinue: () => {
                  this.#s({
                      type: "continue"
                  })
              },
              retry: r.options.retry,
              retryDelay: r.options.retryDelay,
              networkMode: r.options.networkMode,
              canRun: () => !0
          }), this.#n.start()
      }
      #s(i) {
          const e = t => {
              switch (i.type) {
                  case "failed":
                      return {
                          ...t, fetchFailureCount: i.failureCount, fetchFailureReason: i.error
                      };
                  case "pause":
                      return {
                          ...t, fetchStatus: "paused"
                      };
                  case "continue":
                      return {
                          ...t, fetchStatus: "fetching"
                      };
                  case "fetch":
                      return {
                          ...t, ...c3(t.data, this.options), fetchMeta: i.meta ?? null
                      };
                  case "success":
                      return {
                          ...t, data: i.data, dataUpdateCount: t.dataUpdateCount + 1, dataUpdatedAt: i.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!i.manual && {
                              fetchStatus: "idle",
                              fetchFailureCount: 0,
                              fetchFailureReason: null
                          }
                      };
                  case "error":
                      const n = i.error;
                      return jl(n) && n.revert && this.#t ? {
                          ...this.#t,
                          fetchStatus: "idle"
                      } : {
                          ...t,
                          error: n,
                          errorUpdateCount: t.errorUpdateCount + 1,
                          errorUpdatedAt: Date.now(),
                          fetchFailureCount: t.fetchFailureCount + 1,
                          fetchFailureReason: n,
                          fetchStatus: "idle",
                          status: "error"
                      };
                  case "invalidate":
                      return {
                          ...t, isInvalidated: !0
                      };
                  case "setState":
                      return {
                          ...t, ...i.state
                      }
              }
          };
          this.state = e(this.state), kt.batch(() => {
              this.observers.forEach(t => {
                  t.onQueryUpdate()
              }), this.#i.notify({
                  query: this,
                  type: "updated",
                  action: i
              })
          })
      }
  };

function c3(i, e) {
  return {
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchStatus: Om(e.networkMode) ? "fetching" : "paused",
      ...i === void 0 && {
          error: null,
          status: "pending"
      }
  }
}

function h3(i) {
  const e = typeof i.initialData == "function" ? i.initialData() : i.initialData,
      t = e !== void 0,
      n = t ? typeof i.initialDataUpdatedAt == "function" ? i.initialDataUpdatedAt() : i.initialDataUpdatedAt : 0;
  return {
      data: e,
      dataUpdateCount: 0,
      dataUpdatedAt: t ? n ?? Date.now() : 0,
      error: null,
      errorUpdateCount: 0,
      errorUpdatedAt: 0,
      fetchFailureCount: 0,
      fetchFailureReason: null,
      fetchMeta: null,
      isInvalidated: !1,
      status: t ? "success" : "pending",
      fetchStatus: "idle"
  }
}
var Vm = class extends La {
      constructor(i = {}) {
          super(), this.config = i, this.#e = new Map
      }
      #e;
      build(i, e, t) {
          const n = e.queryKey,
              s = e.queryHash ?? Bu(n, e);
          let r = this.get(s);
          return r || (r = new u3({
              cache: this,
              queryKey: n,
              queryHash: s,
              options: i.defaultQueryOptions(e),
              state: t,
              defaultOptions: i.getQueryDefaults(n)
          }), this.add(r)), r
      }
      add(i) {
          this.#e.has(i.queryHash) || (this.#e.set(i.queryHash, i), this.notify({
              type: "added",
              query: i
          }))
      }
      remove(i) {
          const e = this.#e.get(i.queryHash);
          e && (i.destroy(), e === i && this.#e.delete(i.queryHash), this.notify({
              type: "removed",
              query: i
          }))
      }
      clear() {
          kt.batch(() => {
              this.getAll().forEach(i => {
                  this.remove(i)
              })
          })
      }
      get(i) {
          return this.#e.get(i)
      }
      getAll() {
          return [...this.#e.values()]
      }
      find(i) {
          const e = {
              exact: !0,
              ...i
          };
          return this.getAll().find(t => fd(e, t))
      }
      findAll(i = {}) {
          const e = this.getAll();
          return Object.keys(i).length > 0 ? e.filter(t => fd(i, t)) : e
      }
      notify(i) {
          kt.batch(() => {
              this.listeners.forEach(e => {
                  e(i)
              })
          })
      }
      onFocus() {
          kt.batch(() => {
              this.getAll().forEach(i => {
                  i.onFocus()
              })
          })
      }
      onOnline() {
          kt.batch(() => {
              this.getAll().forEach(i => {
                  i.onOnline()
              })
          })
      }
  },
  d3 = class extends Am {
      #e;
      #t;
      #i;
      constructor(i) {
          super(), this.mutationId = i.mutationId, this.#t = i.mutationCache, this.#e = [], this.state = i.state || f3(), this.setOptions(i.options), this.scheduleGc()
      }
      setOptions(i) {
          this.options = i, this.updateGcTime(this.options.gcTime)
      }
      get meta() {
          return this.options.meta
      }
      addObserver(i) {
          this.#e.includes(i) || (this.#e.push(i), this.clearGcTimeout(), this.#t.notify({
              type: "observerAdded",
              mutation: this,
              observer: i
          }))
      }
      removeObserver(i) {
          this.#e = this.#e.filter(e => e !== i), this.scheduleGc(), this.#t.notify({
              type: "observerRemoved",
              mutation: this,
              observer: i
          })
      }
      optionalRemove() {
          this.#e.length || (this.state.status === "pending" ? this.scheduleGc() : this.#t.remove(this))
      }
      continue () {
          return this.#i?.continue() ?? this.execute(this.state.variables)
      }
      async execute(i) {
          this.#i = Fm({
              fn: () => this.options.mutationFn ? this.options.mutationFn(i) : Promise.reject(new Error("No mutationFn found")),
              onFail: (n, s) => {
                  this.#n({
                      type: "failed",
                      failureCount: n,
                      error: s
                  })
              },
              onPause: () => {
                  this.#n({
                      type: "pause"
                  })
              },
              onContinue: () => {
                  this.#n({
                      type: "continue"
                  })
              },
              retry: this.options.retry ?? 0,
              retryDelay: this.options.retryDelay,
              networkMode: this.options.networkMode,
              canRun: () => this.#t.canRun(this)
          });
          const e = this.state.status === "pending",
              t = !this.#i.canStart();
          try {
              if (!e) {
                  this.#n({
                      type: "pending",
                      variables: i,
                      isPaused: t
                  }), await this.#t.config.onMutate?.(i, this);
                  const s = await this.options.onMutate?.(i);
                  s !== this.state.context && this.#n({
                      type: "pending",
                      context: s,
                      variables: i,
                      isPaused: t
                  })
              }
              const n = await this.#i.start();
              return await this.#t.config.onSuccess?.(n, i, this.state.context, this), await this.options.onSuccess?.(n, i, this.state.context), await this.#t.config.onSettled?.(n, null, this.state.variables, this.state.context, this), await this.options.onSettled?.(n, null, i, this.state.context), this.#n({
                  type: "success",
                  data: n
              }), n
          } catch (n) {
              try {
                  throw await this.#t.config.onError?.(n, i, this.state.context, this), await this.options.onError?.(n, i, this.state.context), await this.#t.config.onSettled?.(void 0, n, this.state.variables, this.state.context, this), await this.options.onSettled?.(void 0, n, i, this.state.context), n
              } finally {
                  this.#n({
                      type: "error",
                      error: n
                  })
              }
          } finally {
              this.#t.runNext(this)
          }
      }
      #n(i) {
          const e = t => {
              switch (i.type) {
                  case "failed":
                      return {
                          ...t, failureCount: i.failureCount, failureReason: i.error
                      };
                  case "pause":
                      return {
                          ...t, isPaused: !0
                      };
                  case "continue":
                      return {
                          ...t, isPaused: !1
                      };
                  case "pending":
                      return {
                          ...t, context: i.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: i.isPaused, status: "pending", variables: i.variables, submittedAt: Date.now()
                      };
                  case "success":
                      return {
                          ...t, data: i.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1
                      };
                  case "error":
                      return {
                          ...t, data: void 0, error: i.error, failureCount: t.failureCount + 1, failureReason: i.error, isPaused: !1, status: "error"
                      }
              }
          };
          this.state = e(this.state), kt.batch(() => {
              this.#e.forEach(t => {
                  t.onMutationUpdate(i)
              }), this.#t.notify({
                  mutation: this,
                  type: "updated",
                  action: i
              })
          })
      }
  };

function f3() {
  return {
      context: void 0,
      data: void 0,
      error: null,
      failureCount: 0,
      failureReason: null,
      isPaused: !1,
      status: "idle",
      variables: void 0,
      submittedAt: 0
  }
}
var zm = class extends La {
  constructor(i = {}) {
      super(), this.config = i, this.#e = new Map, this.#t = Date.now()
  }
  #e;
  #t;
  build(i, e, t) {
      const n = new d3({
          mutationCache: this,
          mutationId: ++this.#t,
          options: i.defaultMutationOptions(e),
          state: t
      });
      return this.add(n), n
  }
  add(i) {
      const e = wr(i),
          t = this.#e.get(e) ?? [];
      t.push(i), this.#e.set(e, t), this.notify({
          type: "added",
          mutation: i
      })
  }
  remove(i) {
      const e = wr(i);
      if (this.#e.has(e)) {
          const t = this.#e.get(e)?.filter(n => n !== i);
          t && (t.length === 0 ? this.#e.delete(e) : this.#e.set(e, t))
      }
      this.notify({
          type: "removed",
          mutation: i
      })
  }
  canRun(i) {
      const e = this.#e.get(wr(i))?.find(t => t.state.status === "pending");
      return !e || e === i
  }
  runNext(i) {
      return this.#e.get(wr(i))?.find(t => t !== i && t.state.isPaused)?.continue() ?? Promise.resolve()
  }
  clear() {
      kt.batch(() => {
          this.getAll().forEach(i => {
              this.remove(i)
          })
      })
  }
  getAll() {
      return [...this.#e.values()].flat()
  }
  find(i) {
      const e = {
          exact: !0,
          ...i
      };
      return this.getAll().find(t => pd(e, t))
  }
  findAll(i = {}) {
      return this.getAll().filter(e => pd(i, e))
  }
  notify(i) {
      kt.batch(() => {
          this.listeners.forEach(e => {
              e(i)
          })
      })
  }
  resumePausedMutations() {
      const i = this.getAll().filter(e => e.state.isPaused);
      return kt.batch(() => Promise.all(i.map(e => e.continue().catch(Xt))))
  }
};

function wr(i) {
  return i.options.scope?.id ?? String(i.mutationId)
}

function p3(i) {
  return {
      onFetch: (e, t) => {
          const n = async () => {
              const s = e.options,
                  r = e.fetchOptions?.meta?.fetchMore?.direction,
                  a = e.state.data?.pages || [],
                  l = e.state.data?.pageParams || [],
                  o = {
                      pages: [],
                      pageParams: []
                  };
              let u = !1;
              const c = p => {
                      Object.defineProperty(p, "signal", {
                          enumerable: !0,
                          get: () => (e.signal.aborted ? u = !0 : e.signal.addEventListener("abort", () => {
                              u = !0
                          }), e.signal)
                      })
                  },
                  h = Rm(e.options, e.fetchOptions),
                  d = async (p, g, w) => {
                      if (u) return Promise.reject();
                      if (g == null && p.pages.length) return Promise.resolve(p);
                      const y = {
                          queryKey: e.queryKey,
                          pageParam: g,
                          direction: w ? "backward" : "forward",
                          meta: e.options.meta
                      };
                      c(y);
                      const b = await h(y),
                          {
                              maxPages: x
                          } = e.options,
                          k = w ? s3 : n3;
                      return {
                          pages: k(p.pages, b, x),
                          pageParams: k(p.pageParams, g, x)
                      }
                  };
              let f;
              if (r && a.length) {
                  const p = r === "backward",
                      g = p ? m3 : yd,
                      w = {
                          pages: a,
                          pageParams: l
                      },
                      y = g(s, w);
                  f = await d(w, y, p)
              } else {
                  f = await d(o, l[0] ?? s.initialPageParam);
                  const p = i ?? a.length;
                  for (let g = 1; g < p; g++) {
                      const w = yd(s, f);
                      f = await d(f, w)
                  }
              }
              return f
          };
          e.options.persister ? e.fetchFn = () => e.options.persister?.(n, {
              queryKey: e.queryKey,
              meta: e.options.meta,
              signal: e.signal
          }, t) : e.fetchFn = n
      }
  }
}

function yd(i, {
  pages: e,
  pageParams: t
}) {
  const n = e.length - 1;
  return i.getNextPageParam(e[n], e, t[n], t)
}

function m3(i, {
  pages: e,
  pageParams: t
}) {
  return i.getPreviousPageParam?.(e[0], e, t[0], t)
}
var g3 = class {
      #e;
      #t;
      #i;
      #n;
      #a;
      #r;
      #s;
      #l;
      constructor(i = {}) {
          this.#e = i.queryCache || new Vm, this.#t = i.mutationCache || new zm, this.#i = i.defaultOptions || {}, this.#n = new Map, this.#a = new Map, this.#r = 0
      }
      mount() {
          this.#r++, this.#r === 1 && (this.#s = Bm.subscribe(async i => {
              i && (await this.resumePausedMutations(), this.#e.onFocus())
          }), this.#l = ea.subscribe(async i => {
              i && (await this.resumePausedMutations(), this.#e.onOnline())
          }))
      }
      unmount() {
          this.#r--, this.#r === 0 && (this.#s?.(), this.#s = void 0, this.#l?.(), this.#l = void 0)
      }
      isFetching(i) {
          return this.#e.findAll({
              ...i,
              fetchStatus: "fetching"
          }).length
      }
      isMutating(i) {
          return this.#t.findAll({
              ...i,
              status: "pending"
          }).length
      }
      getQueryData(i) {
          const e = this.defaultQueryOptions({
              queryKey: i
          });
          return this.#e.get(e.queryHash)?.state.data
      }
      ensureQueryData(i) {
          const e = this.getQueryData(i.queryKey);
          if (e === void 0) return this.fetchQuery(i);
          {
              const t = this.defaultQueryOptions(i),
                  n = this.#e.build(this, t);
              return i.revalidateIfStale && n.isStaleByTime(dd(t.staleTime, n)) && this.prefetchQuery(t), Promise.resolve(e)
          }
      }
      getQueriesData(i) {
          return this.#e.findAll(i).map(({
              queryKey: e,
              state: t
          }) => {
              const n = t.data;
              return [e, n]
          })
      }
      setQueryData(i, e, t) {
          const n = this.defaultQueryOptions({
                  queryKey: i
              }),
              r = this.#e.get(n.queryHash)?.state.data,
              a = Y4(e, r);
          if (a !== void 0) return this.#e.build(this, n).setData(a, {
              ...t,
              manual: !0
          })
      }
      setQueriesData(i, e, t) {
          return kt.batch(() => this.#e.findAll(i).map(({
              queryKey: n
          }) => [n, this.setQueryData(n, e, t)]))
      }
      getQueryState(i) {
          const e = this.defaultQueryOptions({
              queryKey: i
          });
          return this.#e.get(e.queryHash)?.state
      }
      removeQueries(i) {
          const e = this.#e;
          kt.batch(() => {
              e.findAll(i).forEach(t => {
                  e.remove(t)
              })
          })
      }
      resetQueries(i, e) {
          const t = this.#e,
              n = {
                  type: "active",
                  ...i
              };
          return kt.batch(() => (t.findAll(i).forEach(s => {
              s.reset()
          }), this.refetchQueries(n, e)))
      }
      cancelQueries(i = {}, e = {}) {
          const t = {
                  revert: !0,
                  ...e
              },
              n = kt.batch(() => this.#e.findAll(i).map(s => s.cancel(t)));
          return Promise.all(n).then(Xt).catch(Xt)
      }
      invalidateQueries(i = {}, e = {}) {
          return kt.batch(() => {
              if (this.#e.findAll(i).forEach(n => {
                      n.invalidate()
                  }), i.refetchType === "none") return Promise.resolve();
              const t = {
                  ...i,
                  type: i.refetchType ?? i.type ?? "active"
              };
              return this.refetchQueries(t, e)
          })
      }
      refetchQueries(i = {}, e) {
          const t = {
                  ...e,
                  cancelRefetch: e?.cancelRefetch ?? !0
              },
              n = kt.batch(() => this.#e.findAll(i).filter(s => !s.isDisabled()).map(s => {
                  let r = s.fetch(void 0, t);
                  return t.throwOnError || (r = r.catch(Xt)), s.state.fetchStatus === "paused" ? Promise.resolve() : r
              }));
          return Promise.all(n).then(Xt)
      }
      fetchQuery(i) {
          const e = this.defaultQueryOptions(i);
          e.retry === void 0 && (e.retry = !1);
          const t = this.#e.build(this, e);
          return t.isStaleByTime(dd(e.staleTime, t)) ? t.fetch(e) : Promise.resolve(t.state.data)
      }
      prefetchQuery(i) {
          return this.fetchQuery(i).then(Xt).catch(Xt)
      }
      fetchInfiniteQuery(i) {
          return i.behavior = p3(i.pages), this.fetchQuery(i)
      }
      prefetchInfiniteQuery(i) {
          return this.fetchInfiniteQuery(i).then(Xt).catch(Xt)
      }
      resumePausedMutations() {
          return ea.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve()
      }
      getQueryCache() {
          return this.#e
      }
      getMutationCache() {
          return this.#t
      }
      getDefaultOptions() {
          return this.#i
      }
      setDefaultOptions(i) {
          this.#i = i
      }
      setQueryDefaults(i, e) {
          this.#n.set(Vs(i), {
              queryKey: i,
              defaultOptions: e
          })
      }
      getQueryDefaults(i) {
          const e = [...this.#n.values()];
          let t = {};
          return e.forEach(n => {
              zs(i, n.queryKey) && (t = {
                  ...t,
                  ...n.defaultOptions
              })
          }), t
      }
      setMutationDefaults(i, e) {
          this.#a.set(Vs(i), {
              mutationKey: i,
              defaultOptions: e
          })
      }
      getMutationDefaults(i) {
          const e = [...this.#a.values()];
          let t = {};
          return e.forEach(n => {
              zs(i, n.mutationKey) && (t = {
                  ...t,
                  ...n.defaultOptions
              })
          }), t
      }
      defaultQueryOptions(i) {
          if (i._defaulted) return i;
          const e = {
              ...this.#i.queries,
              ...this.getQueryDefaults(i.queryKey),
              ...i,
              _defaulted: !0
          };
          return e.queryHash || (e.queryHash = Bu(e.queryKey, e)), e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"), e.throwOnError === void 0 && (e.throwOnError = !!e.suspense), !e.networkMode && e.persister && (e.networkMode = "offlineFirst"), e.enabled !== !0 && e.queryFn === Mm && (e.enabled = !1), e
      }
      defaultMutationOptions(i) {
          return i?._defaulted ? i : {
              ...this.#i.mutations,
              ...i?.mutationKey && this.getMutationDefaults(i.mutationKey),
              ...i,
              _defaulted: !0
          }
      }
      clear() {
          this.#e.clear(), this.#t.clear()
      }
  },
  y3 = "VUE_QUERY_CLIENT";

function v3(i) {
  const e = i ? `:${i}` : "";
  return `${y3}${e}`
}

function zo(i, e) {
  if (e) {
      const t = e(i);
      if (t === void 0 && Je(i) || t !== void 0) return t
  }
  if (Array.isArray(i)) return i.map(t => zo(t, e));
  if (typeof i == "object" && b3(i)) {
      const t = Object.entries(i).map(([n, s]) => [n, zo(s, e)]);
      return Object.fromEntries(t)
  }
  return i
}

function Ce(i) {
  return zo(i, e => {
      if (Je(e)) return Ce(pe(e))
  })
}

function b3(i) {
  if (Object.prototype.toString.call(i) !== "[object Object]") return !1;
  const e = Object.getPrototypeOf(i);
  return e === null || e === Object.prototype
}
var w3 = class extends Vm {
      find(i) {
          return super.find(Ce(i))
      }
      findAll(i = {}) {
          return super.findAll(Ce(i))
      }
  },
  k3 = class extends zm {
      find(i) {
          return super.find(Ce(i))
      }
      findAll(i = {}) {
          return super.findAll(Ce(i))
      }
  },
  Wm = class extends g3 {
      constructor(i = {}) {
          const e = {
              defaultOptions: i.defaultOptions,
              queryCache: i.queryCache || new w3,
              mutationCache: i.mutationCache || new k3
          };
          super(e), this.isRestoring = M(!1)
      }
      isFetching(i = {}) {
          return super.isFetching(Ce(i))
      }
      isMutating(i = {}) {
          return super.isMutating(Ce(i))
      }
      getQueryData(i) {
          return super.getQueryData(Ce(i))
      }
      ensureQueryData(i) {
          return super.ensureQueryData(Ce(i))
      }
      getQueriesData(i) {
          return super.getQueriesData(Ce(i))
      }
      setQueryData(i, e, t = {}) {
          return super.setQueryData(Ce(i), e, Ce(t))
      }
      setQueriesData(i, e, t = {}) {
          return super.setQueriesData(Ce(i), e, Ce(t))
      }
      getQueryState(i) {
          return super.getQueryState(Ce(i))
      }
      removeQueries(i = {}) {
          return super.removeQueries(Ce(i))
      }
      resetQueries(i = {}, e = {}) {
          return super.resetQueries(Ce(i), Ce(e))
      }
      cancelQueries(i = {}, e = {}) {
          return super.cancelQueries(Ce(i), Ce(e))
      }
      invalidateQueries(i = {}, e = {}) {
          return new Promise(t => {
              setTimeout(async () => {
                  await super.invalidateQueries(Ce(i), Ce(e)), t()
              }, 0)
          })
      }
      refetchQueries(i = {}, e = {}) {
          return super.refetchQueries(Ce(i), Ce(e))
      }
      fetchQuery(i) {
          return super.fetchQuery(Ce(i))
      }
      prefetchQuery(i) {
          return super.prefetchQuery(Ce(i))
      }
      fetchInfiniteQuery(i) {
          return super.fetchInfiniteQuery(Ce(i))
      }
      prefetchInfiniteQuery(i) {
          return super.prefetchInfiniteQuery(Ce(i))
      }
      setDefaultOptions(i) {
          super.setDefaultOptions(Ce(i))
      }
      setQueryDefaults(i, e) {
          super.setQueryDefaults(Ce(i), Ce(e))
      }
      getQueryDefaults(i) {
          return super.getQueryDefaults(Ce(i))
      }
      setMutationDefaults(i, e) {
          super.setMutationDefaults(Ce(i), Ce(e))
      }
      getMutationDefaults(i) {
          return super.getMutationDefaults(Ce(i))
      }
  },
  _3 = {
      install: (i, e = {}) => {
          const t = v3(e.queryClientKey);
          let n;
          if ("queryClient" in e && e.queryClient) n = e.queryClient;
          else {
              const a = "queryClientConfig" in e ? e.queryClientConfig : void 0;
              n = new Wm(a)
          }
          Ys || n.mount();
          let s = () => {};
          if (e.clientPersister) {
              n.isRestoring.value = !0;
              const [a, l] = e.clientPersister(n);
              s = a, l.then(() => {
                  n.isRestoring.value = !1, e.clientPersisterOnSuccess?.(n)
              })
          }
          const r = () => {
              n.unmount(), s()
          };
          if (i.onUnmount) i.onUnmount(r);
          else {
              const a = i.unmount;
              i.unmount = function() {
                  r(), a()
              }
          }
          i.provide(t, n)
      }
  };

function Um(i = {}) {
  const {
      immediate: e = !1,
      onNeedRefresh: t,
      onOfflineReady: n,
      onRegistered: s,
      onRegisteredSW: r,
      onRegisterError: a
  } = i;
  let l, o;
  const u = async (h = !0) => {
      await o
  };
  async function c() {
      if ("serviceWorker" in navigator) {
          if (l = await Wo(() => import("./workbox-window.prod.es5.f3824607.js"), []).then(({
                  Workbox: h
              }) => new h("/sw.js", {
                  scope: "/",
                  type: "classic"
              })).catch(h => {
                  a?.(h)
              }), !l) return;
          l.addEventListener("activated", h => {
              (h.isUpdate || h.isExternal) && window.location.reload()
          }), l.addEventListener("installed", h => {
              h.isUpdate || n?.()
          }), l.register({
              immediate: e
          }).then(h => {
              r ? r("/sw.js", h) : s?.(h)
          }).catch(h => {
              a?.(h)
          })
      }
  }
  return o = c(), u
}
let Sn, vd;
console.log(location.hostname);
const x3 = async () => {
  vd = await T3(), Sn = zf(J4, {}), Sn.use($y());
  const i = new Wm;
  Um({
      onNeedRefresh() {},
      onOfflineReady() {}
  }), Sn.use(_3, {
      queryClient: i
  }), Sn.use(vd), Sn.mount("#app")
}, T3 = async () => {
  const {
      appRouter: i
  } = await Wo(() => Promise.resolve().then(() => s4), void 0);
  return i
};
x3();
Um({
  onNeedRefresh() {},
  onOfflineReady() {}
});
const S3 = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
S3 && Wo(() => import("./PWAInstallPrompt.795efa97.js"), []).then(i => {
  const e = i.default;
  Sn.component("PWAInstallPrompt", e);
  const t = document.createElement("div");
  document.body.appendChild(t), zf(e).mount(t)
});
export {
  _ as a, m as b, T as c, U as d, ye as e, Te as o, M as r
};
